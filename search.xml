<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>推荐系统 Factorization Machines 因子分解机</title>
      <link href="/2021/11/30/Factorization%20Machines/"/>
      <url>/2021/11/30/Factorization%20Machines/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>因子分解机 (Factorization Machines) 是CTR预估的重要模型之一。要讲述因子分解机FM，就避不开<strong>逻辑回归LR</strong>（logistic Rgeression）和<strong>矩阵分解MF</strong>（Matrix Factorization）。</p><p>转自<a href="https://zhuanlan.zhihu.com/p/153500425">推荐系统玩家 之 因子分解机FM（Factorization Machines） - 知乎 (zhihu.com)</a></p><h2 id="1-因子分解机的演变"><a href="#1-因子分解机的演变" class="headerlink" title="1.因子分解机的演变"></a>1.因子分解机的演变</h2><p>传统的推荐模型<br><img src="https://pic4.zhimg.com/80/v2-bd724d20893bb295c5107411397ed197_720w.jpg" alt="img"></p><p>上图是传统的推荐系统模型的分类，逻辑回归LR模型在传统的推荐模型中占据着非常重要的位置。而因子分解机的出现，也来源于<strong>逻辑回归和矩阵分解</strong>的演化。</p><p>首先我们知道，<strong>逻辑回归</strong>的是对所有特征的一个线性加权组合, 然后再加入Sigmoid逻辑函数：</p><script type="math/tex; mode=display">\large \hat{y}(x)=w_{0}+w_{1} x_{1}+\ldots+w_{n} x_{n}=w_{0}+\sum_{i=1}^{n} w_{i} x_{i} \tag{1}</script><p>对比与矩阵分解，虽然逻辑回归模型已经<strong>不单单</strong>考虑了用户的行为特征，也可以加入年龄，性别，物品的属性，时间，地点等等特征。但是逻辑回归表达能力仍然差的原因是仅仅用了每个单一的特征，而没有考虑到<strong>特征之间的关系</strong>。</p><p>那有没有模型可以加入特征之间的联系呢？</p><p><strong>POLY2模型（Degree-2 Polynomial Margin）</strong>则在LR的基础上采用了一种<strong>暴力的特征组合模式</strong>，即将所有特征两两相交，因此原来的LR模型就变成了：</p><script type="math/tex; mode=display">\large \hat{y}(x)=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n-1} \sum_{j=i\llcorner 1}^{n} w_{i j} x_{i} x_{j} \tag{2}</script><p>其中$\Large w_{i j}$​​是特征组合的$ (i, j)$​​权重。</p><p>也就是说，<strong>POLY2模型</strong>将所有的特征两两相交，暴力的组合了特征。这样以来，就增加了特征的维度，考虑到了特征之间的关系。但是同时，暴力的组合带来的是维度的增加。在机器学习中，我们普遍使用<strong>One-hot</strong>编码，这样的暴力组合，就使得复杂度从$\large n$​​​​上升到了 ,$\large n^2$​​​​ 特征维度也上升，同时数据极度稀疏，在训练过程中很难收敛。</p><p>那么有没有方法可以处理稀疏数据，同时保持特征之间的联系呢？</p><h2 id="2-因子分解机"><a href="#2-因子分解机" class="headerlink" title="2.因子分解机"></a>2.因子分解机</h2><p>用户对电影打分的onehot编码</p><p><img src="https://pic1.zhimg.com/80/v2-a3c949bc9467e00b578f81c81108b4b0_720w.jpg" alt="img"></p><p>上图是电影背景下，用户对电影打分的onehot编码形式。每行代表一个样本，每列都代表一个特征。同时特征可以分为五个部分：用户ID，电影ID，用户对其他电影的打分（归一化），时间信息，以及对上一次电影的打分。</p><p>首先我们直观的看下，为什么<strong>POLY2模型</strong>在很多情况下是不适用的。</p><script type="math/tex; mode=display">\large \hat{y}(x)=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n-1} \sum_{j=i+1}^{n} w_{i j} x_{i} x_{j} \tag{3}</script><p><strong>POLY2模型</strong>的表达式如上， $\Large w_{0}$是常数项， $\Large w_{i}$是一阶特征的系数， $\Large w_{i}w_{j}$是二阶特征的系数，也就是交叉特征的系数。而由于在数据中，不是每个特征组合都有相互作用，因此， $\Large x_{i}\cdot x_{j}$为0。</p><p>举个例子来说，如上图中，我们要估计用户A对电影ST星际迷航（Star Trek）的相互作用，来预测A都ST的打分。显然，上图中A列乘以ST列是等于0的。也就是说，交叉项  $\Large x_{i}\cdot x_{j}$ 为0了，那么对应的  $\Large w_{i}w_{j}$ 在梯度更新时，$\Large\frac{\partial \hat{y}(x)}{\partial w_{i, j}}=x_{i} x_{j}=0$，因此也就会导致  $\Large w_{i}w_{j}$ 的训练不充分且不准确，进而影响模型的效果。</p><p>因此，<strong>因子分解机</strong>的应运而生。</p><p>因子分解机的<strong>优势</strong>是为每个特征学习了一个<strong>隐权重向量（latent vector），</strong>在特征交叉的时候，用这两个特征隐向量内积作为交叉特征的权重。如何理解这个含义呢？</p><p>在这里我们就要提一嘴矩阵分解。矩阵分解其实是将一个稀疏矩阵R分解为两个矩阵内积的形式，通过内积回乘，就能够得到一个满秩的矩阵。如果是电影的评分矩阵，也就是可以对未知的电影评分进行预测。具体可以看这篇文章：</p><p>而因子分解机FM就是在POLY2模型的基础上，融合了矩阵分解的思想。即，对二阶交叉特征的系数以矩阵分解的方式调整，让系数不再是独立无关的，同时解决数据稀疏导致的无法训练参数的问题：</p><script type="math/tex; mode=display">\large\hat{y}(\mathbf{x}):=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j} \tag{4}</script><p>其中，$\large w_{0} \in \mathbb{R}, \quad \mathbf{w} \in \mathbb{R}^{n}, \quad \mathbf{V} \in \mathbb{R}^{n \times k}, V$是一个$\large n * k$的向量矩阵，$\large n$是特征$\large x$的个数，$\large k$是个待确定的参数。</p><p>$\large \left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle$ 表示点乘,即向量对应位置乘积的和</p><script type="math/tex; mode=display">\large \left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle:=\sum_{f=1}^{k} v_{i, f} \cdot v_{j, f} \tag{5}</script><p>由矩阵分解可知，对任意一个正定矩阵$\large \mathbf{W}$，都可以找到一个矩阵$\large \mathbf{V}$，$\large \mathbf{}$且在矩阵$\large \mathbf{V}$维度$\large k$足够大的情况下使得$\large \mathbf{W}=\mathbf{V} \cdot \mathbf{V}^{t}$成立。因此，通过矩阵分解用两个向量 $\Large v_{i}$ 和 $\Large v_{j}$ 的内积近似原先矩阵$\large \mathbf{W}$。</p><p>其次，在拆解为 $\large\mathbf{v}_{i}$ 和之 $\large\mathbf{v}_{j}$ 后，参数更新时是对这两个向量分别更新的，那么在更新时，对于向量，我$\large\mathbf{v}_{i}$们不需要寻找到一组 $\Large x_{i}$和 $\Large x_{j}$同时不为0，我们只需要在$\large x_{i} \neq 0$的情况下，找到任意一个样本$\large x_{k} \neq 0$即可通过 $\Large x_{i}x_{k}$ 来更新 $\Large v_{i}$ 。</p><p>我们举个例子来理解下上面的定义：</p><p>在商品推荐的场景下，样本有两个特征，分别是类品和品牌。某个训练样本的特征组合是（足球，阿迪达斯）。在POLY2模型中，只有当“足球”和“阿迪达斯”同时出现在一个训练样本中时，模型才能够学到这个组合特征对应的权重。而在因子分解机FM中，“足球”的的隐向量也可以根据（足球，耐克）进行更新。“阿迪达斯”的隐向量也可以根据（篮球，阿迪达斯）更新，由此一来，就大幅度的降低了模型对稀疏性的要求。</p><p>更极端的情况，对于一个从未出现的组合（篮球，耐克），因为模型已经学习了“篮球”和“耐克”的隐向量，因此就具备了更新权重  $\Large w$​ 的能力，使其泛化能力大大提高。</p><h2 id="3-降低时间复杂度"><a href="#3-降低时间复杂度" class="headerlink" title="3.降低时间复杂度"></a>3.降低时间复杂度</h2><p>公式（3）的时间复杂度为 $O\left(k n^{2}\right)$ , 我们可以对二阶交叉特征进行化简，使时间复杂度降低到 $O\left(k n\right)$ 。</p><script type="math/tex; mode=display">\large \sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j} \tag{6}</script><p><img src="https://pic1.zhimg.com/80/v2-c3984c164afcb18d65ce0b3ad5f41b74_720w.jpg" alt="img"></p><p>首先矩阵A中的上三角，红色方框部分代表公式（6），也就是因子分解机中二阶交叉项部分。由图可以看出，他是矩阵的全部元素减去对角线元素之和得到的, 即：</p><p><img src="https://pic1.zhimg.com/80/v2-3fa1f4caf873a21f6a9e59fdb769c3c0_720w.jpg" alt="img"></p><script type="math/tex; mode=display">\large \sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j}=\frac{1}{2}\left(\sum_{i=1}^{n} \sum_{j=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j}-\sum_{i=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{i}\right\rangle x_{i} x_{i}\right)</script><p>其中， $\large \sum_{i=1}^{n} \sum_{j=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j}$​ 是矩阵全部元素之和。  $\large \sum_{i=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{i}\right\rangle x_{i} x_{i}$​代表对角线元素之和。</p><p>因为 ：</p><script type="math/tex; mode=display">\large \left\langle\mathbf{v}_{i}, \mathbf{v}_{i}\right\rangle=\sum_{f=1}^{k} v_{i, f}, v_{j, f}</script><p>因此继续化简：</p><script type="math/tex; mode=display">\large =\frac{1}{2}\left(\sum_{i=1}^{n} \sum_{j=1}^{n} \sum_{f=1}^{k} v_{i, f} v_{j, f} x_{i} x_{j}-\sum_{i=1}^{n} \sum_{f=1}^{k} v_{i, f} v_{i, f} x_{i} x_{i}\right)</script><script type="math/tex; mode=display">\large =\frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)\left(\sum_{j=1}^{n} v_{j, f} x_{j}\right)-\sum_{i=1}^{n} v_{i, f}^{2} x_{i}^{2}\right)</script><script type="math/tex; mode=display">\large =\frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)^{2}-\sum_{i=1}^{n} v_{i, f}^{2} x_{i}^{2}\right) \tag{7}</script><p>那么，<strong>因子分解机的二阶表达式</strong>就为：</p><script type="math/tex; mode=display">\large \hat{y}(x):=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)^{2}-\sum_{i=1}^{n} v_{i, f}^{2} x_{i}^{2}\right) \tag{8}</script><p>其复杂度为  $O\left(k n\right)$​​  。考虑到特征的稀疏性，尽管  $\large n$​​可能很大，但很多  $\Large x_{i}$​​ 都是零。因此其实际复杂度应该是 $O(k \bar{n})$​​ ,其中  $\large \bar{n}$​​表示样本不为零的特征维度数量的平均值。</p><h2 id="4-因子分解机FM求解"><a href="#4-因子分解机FM求解" class="headerlink" title="4.因子分解机FM求解"></a>4.因子分解机FM求解</h2><p>我们对公式（8）求偏导，可以计算因子分解模型对参数的梯度：</p><ul><li>当参数为  $\large w_{i}$​​ 时：</li></ul><script type="math/tex; mode=display">\large \frac{\partial \hat{y}(x)}{\partial w_{0}}=1 \tag{9}</script><ul><li>当参数为  $\large w_{i}$ 时，只跟它相关的  $\large x_{i}$ 有关:</li></ul><script type="math/tex; mode=display">\large \frac{\partial \hat{y}(x)}{\partial w_{i}}=x_i \tag{10}</script><p>当参数为   $\large v_{i,f}$​ 时:</p><script type="math/tex; mode=display">\large \begin{aligned} \frac{\partial \hat{y}(x)}{\partial v_{i, f}} &=\frac{\partial \frac{1}{2}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)^{2}-v_{i, f}^{2} x_{i}^{2}\right)}{\partial v_{i, f}} \\ &=\frac{1}{2}\left(2 x_{i} \sum_{i=1}^{n} v_{i, f} x_{i}-2 v_{i, f} x_{i}^{2}\right) \\ &=x_{i} \sum_{j=1}^{n} v_{j, f} x_{j}-v_{i, f} x_{i}^{2} \end{aligned} \tag{11}</script><p>因此，<strong>因子分解机FM模型对参数的梯度为</strong>：</p><script type="math/tex; mode=display">\large \frac{\partial \hat{y}(x)}{\partial \theta}= \begin{cases}1, & \text { if } \theta \text { is } w_{0} \\ x_{i}, & \text { if } \theta \text { is } w_{i} \\ x_{i} \sum_{j=1}^{n} v_{j, f} x_{j}-v_{i, f} x_{i}^{2} & \text { if } \theta \text { is } v_{i, f}\end{cases} \tag{12}</script><h2 id="5-损失函数选取及算法流程"><a href="#5-损失函数选取及算法流程" class="headerlink" title="5.损失函数选取及算法流程"></a>5.损失函数选取及算法流程</h2><p>至此，我们就推导出了因子分解机的表达式以及参数的梯度。那么，损失函数在这里我们以以下两个为例, 并用梯度下降法求解：</p><h3 id="回归问题：平方差损失函数"><a href="#回归问题：平方差损失函数" class="headerlink" title="回归问题：平方差损失函数"></a>回归问题：平方差损失函数</h3><script type="math/tex; mode=display">\large Loss =\frac{1}{2} \sum_{i=1}^{n}\left(\hat{y}_{i}-y_{i}\right)^{2}</script><p>求偏导得：</p><script type="math/tex; mode=display">\large \frac{\partial L}{\partial \hat{y}(x)}=(\hat{y}(x)-y)</script><p>平方损失函数的梯度为：</p><script type="math/tex; mode=display">\large \frac{\partial L}{\partial \theta}=(\hat{y}(x)-y) * \frac{\partial \hat{y}(x)}{\partial \theta}</script><h3 id="分类问题：对数损失函数"><a href="#分类问题：对数损失函数" class="headerlink" title="分类问题：对数损失函数"></a>分类问题：对数损失函数</h3><script type="math/tex; mode=display">\large L o s s=\frac{1}{2} \sum_{i=1}^{n}-\ln \left(\sigma\left(\hat{y}_{i} y_{i}\right)\right)^{2}</script><p>其中：</p><script type="math/tex; mode=display">\large \sigma(\hat{y} y)=\frac{1}{1+e^{-\hat{y} y}}</script><script type="math/tex; mode=display">\large \frac{\partial(\sigma(\hat{y} y))}{\partial \hat{y}}=\sigma(\hat{y} y) *[1-\sigma(\hat{y} y)] * y</script><p>对数函数下的梯度为：</p><script type="math/tex; mode=display">\large \frac{\partial L}{\partial \theta}=\frac{1}{\sigma(\hat{y} y)} * \sigma(\hat{y} y) *\left[1-\sigma(\hat{y} y] * y * \frac{\partial \hat{y}(x)}{\partial \theta}\right.</script><script type="math/tex; mode=display">\large =[1-\sigma(\hat{y} y)] * y * \frac{\partial \hat{y}(x)}{\partial \theta}</script><h3 id="算法流程-以对数损失函数为例）"><a href="#算法流程-以对数损失函数为例）" class="headerlink" title="算法流程(以对数损失函数为例）"></a>算法流程(以对数损失函数为例）</h3><ol><li>初始化权重 $\large w_{0}, w_{1}, \ldots, w_{n}$​​ 和矩阵  $\mathbf{V}$​​</li><li>对每一个样本：</li></ol><script type="math/tex; mode=display">\large w_{0}=w_{0}-\alpha[1-\sigma(\hat{y} y)] * y</script><p>对特征 $i \in(1, \ldots, n)$​ :</p><script type="math/tex; mode=display">\large w_{i}=w_{i}-\alpha[1-\sigma(\hat{y} y)] * y * x_{i}</script><p>对  $f \in(1, \ldots, k)$​ :</p><script type="math/tex; mode=display">\large v_{i, f}=v_{i, f}-\alpha[1-\sigma(\hat{y} y)] * y *\left[x_{i} \sum_{j=1}^{n} v_{j, f} x_{j}-v_{i, f} x_{i}^{2}\right]</script><ol><li>重复步骤2，直到满足终止条件。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/u014595019/article/details/80586438">Matrix Factorization 学习记录（一）：基本原理及实现_Multiangle’s Notepad-CSDN博客</a></p><p><a href="http://www.d2l.ai/chapter_recommender-systems/fm.html">16.9. Factorization Machines — Dive into Deep Learning 0.17.0 documentation (d2l.ai)</a></p><p><a href="https://blog.csdn.net/qq_19446965/article/details/82079367?tdsourcetag=s_pctim_aiomsg">推荐系统中的矩阵分解总结_Rnan_prince的博客-CSDN博客_推荐系统矩阵分解</a></p><p><a href="https://zhuanlan.zhihu.com/p/35262187">推荐系统之矩阵分解家族 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/153500425">推荐系统玩家 之 因子分解机FM（Factorization Machines） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/145120275">推荐系统玩家 之 矩阵分解(Matrix Factorization)的基本方法 及其 优缺点 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/pinard/p/6370127.html">分解机(Factorization Machines)推荐算法原理 - 刘建平Pinard - 博客园 (cnblogs.com)</a></p><p><a href="http://xiang578.com/post/fm.html">(FM) Factorization Machines | 算法花园 (xiang578.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/24798389">浅谈张量分解（一）：如何简单地进行张量分解？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/24824550">浅谈张量分解（二）：张量分解的数学基础 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/25512080">浅谈张量分解（三）：如何对稀疏矩阵进行奇异值分解？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/wy-ei/p/11534427.html">论文阅读 - Factorization Machines - wy-ei - 博客园 (cnblogs.com)</a></p><p>《深度学习推荐系统》王喆</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 推荐系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用</title>
      <link href="/2021/11/27/C++%E5%BC%95%E7%94%A8/"/>
      <url>/2021/11/27/C++%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基本用法"><a href="#一-基本用法" class="headerlink" title="一. 基本用法"></a>一. 基本用法</h2><h3 id="1-例子1"><a href="#1-例子1" class="headerlink" title="1. 例子1"></a>1. 例子1</h3><p>使用引用改变值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(x) std::cout&lt;&lt;x&lt;&lt;std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; ref = a;<span class="comment">//相当于创建了一个别名</span></span><br><span class="line">    ref = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出2</p><p>需要注意的是，并不存在真正的引用类型的“变量”ref,ref只是a的一个引用，在编译过后也不会存在ref和a两个变量，ref只存在于源代码中。</p><h3 id="2-例子2"><a href="#2-例子2" class="headerlink" title="2. 例子2"></a>2. 例子2</h3><p>给函数传递引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(x) std::cout&lt;&lt;x&lt;&lt;std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">Increment</span>(a);</span><br><span class="line">    <span class="built_in">LOG</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出6</p><h2 id="二-需要注意的点"><a href="#二-需要注意的点" class="headerlink" title="二. 需要注意的点"></a>二. 需要注意的点</h2><h3 id="1-一旦声明了一个引用，就不能改变它引用的东西"><a href="#1-一旦声明了一个引用，就不能改变它引用的东西" class="headerlink" title="1.  一旦声明了一个引用，就不能改变它引用的东西"></a>1.  一旦声明了一个引用，就不能改变它引用的东西</h3><p>错误示范</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br></pre></td></tr></table></figure><p>上述代码只是简单地将a的值更改为8，并没有将原本对a的引用改成对b的引用</p><p>因此，引用声明的时候必须赋值。</p><h3 id="2-与指针的异同"><a href="#2-与指针的异同" class="headerlink" title="2. 与指针的异同"></a>2. 与指针的异同</h3><p>引用能做的指针都能做，指针比引用更为强大，且指针是实际存在的变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake整理与Linux 工程目录结构</title>
      <link href="/2021/11/25/CMake%E6%95%B4%E7%90%86%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2021/11/25/CMake%E6%95%B4%E7%90%86%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一-CMake使用示例与整理总结"><a href="#一-CMake使用示例与整理总结" class="headerlink" title="一. CMake使用示例与整理总结"></a>一. CMake使用示例与整理总结</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/wzzfeitian/article/details/40963457">cmake使用示例与整理总结_carl的修行-CSDN博客</a></p><p><a href="https://www.quarkhackers.space/2021/11/18/CMake工程目录结构/">Linux CMake工程目录结构 | 蘑菇的博客 (quarkhackers.space)</a></p><h2 id="1-cmake中一些预定义变量"><a href="#1-cmake中一些预定义变量" class="headerlink" title="1. cmake中一些预定义变量"></a>1. cmake中一些预定义变量</h2><ul><li><p><strong>PROJECT_SOURCE_DIR </strong>工程的根目录</p></li><li><p><strong>PROJECT_BINARY_DIR</strong> 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}/build</p></li><li><p><strong>CMAKE_INCLUDE_PATH</strong> 环境变量,非cmake变量</p></li><li><p><strong>CMAKE_LIBRARY_PATH</strong> 环境变量</p></li><li><p><strong>CMAKE_CURRENT_SOURCE_DIR</strong> 当前处理的CMakeLists.txt所在的路径</p></li><li><p><strong>CMAKE_CURRENT_BINARY_DIR</strong>  target编译目录</p><ul><li>使用<strong>ADD_SURDIRECTORY(src bin)</strong>可以更改此变量的值<br><strong>SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)</strong>并不会对此变量有影响,只是改变了最终目标文件的存储路径</li></ul></li></ul><ul><li><p><strong>CMAKE_CURRENT_LIST_FILE</strong> 输出调用这个变量的CMakeLists.txt的完整路径</p></li><li><p><strong>CMAKE_CURRENT_LIST_LINE</strong> 输出这个变量所在的行</p></li><li><p><strong>CMAKE_MODULE_PATH</strong> 定义自己的cmake模块所在的路径</p><ul><li><strong>SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)</strong>,然后可以用INCLUDE命令来调用自己的模块</li></ul></li></ul><ul><li><p><strong>EXECUTABLE_OUTPUT_PATH</strong> 重新定义目标二进制可执行文件的存放位置</p></li><li><p><strong>LIBRARY_OUTPUT_PATH</strong> 重新定义目标链接库文件的存放位置</p></li><li><p><strong>PROJECT_NAME</strong> 返回通过PROJECT指令定义的项目名称</p></li><li><p><strong>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</strong> 用来控制IF ELSE语句的书写方式</p></li></ul><p>系统信息</p><ul><li><strong>CMAKE_MAJOR_VERSION</strong> cmake主版本号,如2.8.6中的2</li><li><strong>CMAKE_MINOR_VERSION</strong> cmake次版本号,如2.8.6中的8</li><li><strong>CMAKE_PATCH_VERSION</strong> cmake补丁等级,如2.8.6中的6</li><li><strong>CMAKE_SYSTEM</strong> 系统名称,例如Linux-2.6.22</li><li><strong>CAMKE_SYSTEM_NAME</strong> 不包含版本的系统名,如Linux</li><li><strong>CMAKE_SYSTEM_VERSION</strong> 系统版本,如2.6.22</li><li><strong>CMAKE_SYSTEM_PROCESSOR</strong> 处理器名称,如i686<ul><li>UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin</li><li>WIN32 在所有的win32平台为TRUE,包括cygwin</li></ul></li></ul><p>开关选项</p><ul><li><strong>BUILD_SHARED_LIBS</strong> 控制默认的库编译方式。如果未进行设置,使用<strong>ADD_LIBRARY</strong>时又没有指定库类型,默认编译生成的库都是静态库 （可在t3中稍加修改进行验证）</li><li><strong>CMAKE_C_FLAGS</strong> 设置C编译选项</li><li><strong>CMAKE_CXX_FLAGS</strong> 设置C++编译选项</li></ul><h2 id="2-cmake常用命令"><a href="#2-cmake常用命令" class="headerlink" title="2. cmake常用命令"></a>2. cmake常用命令</h2><h3 id="基本语法规则"><a href="#基本语法规则" class="headerlink" title="基本语法规则"></a>基本语法规则</h3><ul><li><p>cmake变量使用<strong>${}</strong>方式取值,但是在<strong>IF</strong>控制语句中是直接使用变量名</p></li><li><p>环境变量使用<strong>$ENV{}</strong>方式取值,使用<strong>SET(ENV{VAR} VALUE)</strong>赋值</p></li><li><p>指令(参数1 参数2…)<br>参数使用括弧括起,参数之间使用空格或分号分开。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以ADD_EXECUTABLE指令为例：</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.c func.c)或者</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.c;func.c)</span><br></pre></td></tr></table></figure></li><li><p>指令是大小写无关的,参数和变量是大小写相关的。推荐全部使用大写指令。</p></li></ul><h3 id="部分常用命令列表："><a href="#部分常用命令列表：" class="headerlink" title="部分常用命令列表："></a>部分常用命令列表：</h3><ul><li><p><strong>PROJECT</strong></p><ul><li><strong>PROJECT(projectname [CXX] [C] [Java])</strong><br>指定工程名称,并可指定工程支持的语言。支持语言列表可忽略,默认支持所有语言</li></ul></li><li><p><strong>SET</strong></p><ul><li><strong>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</strong><br>定义变量(可以定义多个<strong>VALUE</strong>,如<strong>SET(SRC_LIST main.c util.c reactor.c))</strong></li></ul></li><li><p><strong>MESSAGE</strong></p><ul><li><strong>MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] “message to display” …)</strong><br>向终端输出用户定义的信息或变量的值<br><strong>SEND_ERROR</strong>, 产生错误,生成过程被跳过<br><strong>STATUS</strong>, 输出前缀为—的信息<br><strong>FATAL_ERROR</strong>, 立即终止所有cmake过程</li></ul></li><li><p><strong>ADD_EXECUTABLE</strong></p><ul><li><strong>ADD_EXECUTABLE(bin_file_name ${SRC_LIST})</strong>生成可执行文件</li></ul></li><li><p><strong>ADD_LIBRARY</strong></p><ul><li><strong>ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] SRC_LIST)</strong><br>生成动态库或静态库<br><strong>SHARED</strong> 动态库<br><strong>STATIC</strong> 静态库<br><strong>MODULE</strong> 在使用dyld的系统有效,若不支持dyld,等同于<strong>SHARED</strong><br><strong>EXCLUDE_FROM_ALL</strong> 表示该库不会被默认构建</li></ul></li><li><p><strong>SET_TARGET_PROPERTIES</strong></p><ul><li>设置输出的名称,设置动态库的版本和API版本</li></ul></li><li><p><strong>CMAKE_MINIMUM_REQUIRED</strong></p><ul><li><strong>CMAKE_MINIMUM_REQUIRED(VERSION version_number [FATAL_ERROR])</strong><br>声明CMake的版本要求</li></ul></li><li><p><strong>ADD_SUBDIRECTORY</strong></p><ul><li><strong>ADD_SUBDIRECTORY(src_dir [binary_dir] [EXCLUDE_FROM_ALL])</strong><br>向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制的存放位置<br><strong>EXCLUDE_FROM_ALL</strong>含义：将这个目录从编译过程中排除</li></ul></li><li><p><strong>SUBDIRS</strong></p><ul><li>deprecated,不再推荐使用<br>(hello sample)相当于分别写<strong>ADD_SUBDIRECTORY(hello),ADD_SUBDIRECTORY(sample)</strong></li></ul></li><li><p><strong>INCLUDE_DIRECTORIES</strong></p><ul><li><strong>INCLUDE_DIRECTORIES([AFTER | BEFORE] [SYSTEM] dir1 dir2 … )</strong><br>向工程添加多个特定的头文件搜索路径,路径之间用空格分隔,如果路径包含空格,可以使用双引号将它括起来,默认的行为为追加到当前头文件搜索路径的后面。有如下两种方式可以控制搜索路径添加的位置：<ul><li><strong>CMAKE_INCLUDE_DIRECTORIES_BEFORE</strong>,通过SET这个cmake变量为on,可以将添加的头文件搜索路径放在已有路径的前面</li><li>通过<strong>AFTER</strong>或<strong>BEFORE</strong>参数,也可以控制是追加还是置前</li></ul></li></ul></li><li><p><strong>LINK_DIRECTORIES</strong></p><ul><li><strong>LINK_DIRECTORIES(dir1 dir2 …)</strong><br>添加非标准的共享库搜索路径</li></ul></li><li><p><strong>TARGET_LINK_LIBRARIES</strong></p><ul><li><strong>TARGET_LINK_LIBRARIES(target lib1 lib2 …)</strong><br>为target添加需要链接的共享库</li></ul></li><li><p><strong>ADD_DEFINITIONS</strong></p><ul><li>向C/C++编译器添加-D定义<br><strong>ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)</strong>,参数之间用空格分隔</li></ul></li><li><p><strong>ADD_DEPENDENCIES</strong></p><ul><li><strong>ADD_DEPENDENCIES(target-name depend-target1 depend-target2 …)</strong><br>定义target依赖的其他target,确保target在构建之前,其依赖的target已经构建完毕</li></ul></li><li><p><strong>AUX_SOURCE_DIRECTORY</strong></p><ul><li><strong>AUX_SOURCE_DIRECTORY(dir DIR_SRCS)</strong><br>发现一个目录下所有的源代码文件并将列表存储在一个变量中<br>把当前目录下的所有源码文件名赋给变量<strong>DIR_SRCS</strong></li></ul></li><li><p><strong>EXEC_PROGRAM</strong></p><ul><li><p><strong>EXEC_PROGRAM(Executable [dir where to run] [[ARGS<args>]][OUTPUT_VARIABLE ] [RETURN_VALUE <value>])</strong></p></li><li><p>用于在指定目录运行某个程序（默认为当前CMakeLists.txt所在目录）,通过ARGS添加参数,通过<strong>OUTPUT_VARIABLE</strong>和RETURN_VALUE获取输出和返回值,如下示例:</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在src中运行ls命令,在src/CMakeLists.txt添加</span></span><br><span class="line"><span class="keyword">EXEC_PROGRAM</span>(ls ARGS <span class="string">&quot;*.c&quot;</span> OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)</span><br><span class="line"><span class="keyword">IF</span> (<span class="keyword">not</span> LS_RVALUE)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;ls result: &quot;</span> <span class="variable">$&#123;LS_OUTPUT&#125;</span>) </span><br><span class="line">    <span class="comment">#缩进仅为美观,语法无要求</span></span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">not</span> LS_RVALUE)</span><br></pre></td></tr></table></figure></li><li><p><strong>INCLUDE</strong></p><ul><li><strong>INCLUDE(file [OPTIONAL])</strong> 用来载入CMakeLists.txt文件<br><strong>INCLUDE(module [OPTIONAL])</strong>用来载入预定义的cmake模块<br><strong>OPTIONAL</strong>参数的左右是文件不存在也不会产生错误<br>可以载入一个文件,也可以载入预定义模块（模块会在<strong>CMAKE_MODULE_PATH</strong>指定的路径进行搜索）<br>载入的内容将在处理到<strong>INCLUDE</strong>语句时直接执行</li></ul></li><li><p><strong>FIND_</strong></p><ul><li><p><strong>FIND_FILE(<VAR> name path1 path2 …)</strong> <strong>VAR</strong>变量代表找到的文件全路径,包含文件名</p></li><li><p><strong>FIND_LIBRARY(<VAR> name path1 path2 …)</strong> <strong>VAR</strong>变量代表找到的库全路径,包含库文件名</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FIND_LIBRARY</span>(libX X11 /usr/lib)</span><br><span class="line"><span class="keyword">IF</span> (<span class="keyword">NOT</span> libx)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(FATAL_ERROR <span class="string">&quot;libX not found&quot;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">NOT</span> libX)</span><br></pre></td></tr></table></figure></li><li><p><strong>FIND_PATH(<VAR> name path1 path2 …)</strong> <strong>VAR</strong>变量代表包含这个文件的路径</p></li><li><p><strong>FIND_PROGRAM(<VAR> name path1 path2 …) VAR</strong>变量代表包含这个程序的全路径</p></li><li><p><strong>FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE] [[REQUIRED | COMPONENTS] [componets …]]) </strong></p><p>用来调用预定义在<strong>CMAKE_MODULE_PATH</strong>下的<strong>Find<name>.cmake</strong>模块,你也可以自己定义<strong>Find<name></strong> 模块,通过<strong>SET(CMAKE_MODULE_PATH dir)</strong>将其放入工程的某个目录供工程使用</p></li></ul></li><li><p><strong>IF</strong></p><ul><li><p>语法:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span> (expression)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ELSE</span> (expression)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDIF</span> (expression) <span class="comment"># 一定要有ENDIF与IF对应</span></span><br></pre></td></tr></table></figure></li><li><p><strong>IF (expression), expression</strong>不为：空,0,N,NO,OFF,FALSE,NOTFOUND或<var>_NOTFOUND,为真</p><p><strong>IF (not exp)</strong>, 与上面相反<br><strong>IF (var1 AND var2)</strong><br><strong>IF (var1 OR var2)</strong><br><strong>IF (COMMAND cmd)</strong> 如果cmd确实是命令并可调用,为真<br><strong>IF (EXISTS dir) IF (EXISTS file)</strong> 如果目录或文件存在,为真<br><strong>IF (file1 IS_NEWER_THAN file2)</strong>,当file1比file2新,或file1/file2中有一个不存在时为真,文件名需使用全路径<br><strong>IF (IS_DIRECTORY dir)</strong> 当dir是目录时,为真<br><strong>IF (DEFINED var)</strong> 如果变量被定义,为真<br><strong>IF (var MATCHES regex)</strong> 此处<strong>var</strong>可以用<strong>var</strong>名,也可以用<strong>${var}</strong><br><strong>IF (string MATCHES regex)</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当给定的变量或者字符串能够匹配正则表达式regex时为真。比如：</span><br><span class="line"><span class="keyword">IF</span> (<span class="string">&quot;hello&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;ell&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span> (<span class="string">&quot;hello&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;ell&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>数字比较表达式</strong></p><p><strong>IF (variable LESS number)</strong><br><strong>IF (string LESS number)</strong><br><strong>IF (variable GREATER number)</strong><br><strong>IF (string GREATER number)</strong><br><strong>IF (variable EQUAL number)</strong><br><strong>IF (string EQUAL number)</strong></p></li><li><p><strong>按照字母表顺序进行比较</strong></p><p><strong>IF (variable STRLESS string)</strong><br><strong>IF (string STRLESS string)</strong><br><strong>IF (variable STRGREATER string)</strong><br><strong>IF (string STRGREATER string)</strong><br><strong>IF (variable STREQUAL string)</strong><br><strong>IF (string STREQUAL string)</strong></p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">一个小例子,用来判断平台差异：</span><br><span class="line"><span class="keyword">IF</span> (WIN32)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS “This is windows.”)</span><br><span class="line"><span class="keyword">ELSE</span> (WIN32)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS “This is <span class="keyword">not</span> windows”)</span><br><span class="line"><span class="keyword">ENDIF</span> (WIN32)</span><br><span class="line">上述代码用来控制在不同的平台进行不同的控制,但是,阅读起来却并不是那么舒服,<span class="keyword">ELSE</span>(WIN32)之类的语句很容易引起歧义。</span><br><span class="line">可以<span class="keyword">SET</span>(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS <span class="keyword">ON</span>)</span><br><span class="line">这时候就可以写成:</span><br><span class="line"><span class="keyword">IF</span> (WIN32)</span><br><span class="line"><span class="keyword">ELSE</span> ()</span><br><span class="line"><span class="keyword">ENDIF</span> ()</span><br><span class="line">配合<span class="keyword">ELSEIF</span>使用,可能的写法是这样:</span><br><span class="line"><span class="keyword">IF</span> (WIN32)</span><br><span class="line">    <span class="comment">#do something related to WIN32</span></span><br><span class="line"><span class="keyword">ELSEIF</span> (UNIX)</span><br><span class="line">    <span class="comment">#do something related to UNIX</span></span><br><span class="line"><span class="keyword">ELSEIF</span>(APPLE)</span><br><span class="line">    <span class="comment">#do something related to APPLE</span></span><br><span class="line"><span class="keyword">ENDIF</span> (WIN32)</span><br></pre></td></tr></table></figure></li><li><p><strong>WHILE</strong></p><ul><li><p>语法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHILE</span>(condition)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDWHILE</span>(condition)</span><br></pre></td></tr></table></figure><p>其真假判断条件可以参考IF指令</p></li></ul></li><li><p><strong>FOREACH</strong></p><p><strong>FOREACH</strong>指令的使用方法有三种形式：</p><ul><li><p><strong>列表</strong></p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var arg1 arg2 ...)</span><br><span class="line">     COMMAND1(ARGS ...)</span><br><span class="line">     COMMAND2(ARGS ...)</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">FOREACH</span>(F <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line">     <span class="keyword">MESSAGE</span>(<span class="variable">$&#123;F&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(F)</span><br></pre></td></tr></table></figure></li><li><p><strong>范围</strong></p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var RANGE total)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从<span class="number">0</span>到total以１为步进</span><br><span class="line"><span class="keyword">FOREACH</span>(VAR RANGE <span class="number">10</span>)</span><br><span class="line">   <span class="keyword">MESSAGE</span>(<span class="variable">$&#123;VAR&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(VAR)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">012345678910</span></span><br></pre></td></tr></table></figure></li><li><p><strong>范围和步进</strong></p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var RANGE start stop [step])</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure><p>从start开始到stop结束,以step为步进,<br><strong>注意：</strong>直到遇到ENDFOREACH指令,整个语句块才会得到真正的执行。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(A RANGE <span class="number">5</span> <span class="number">15</span> <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(<span class="variable">$&#123;A&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(A)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">581114</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-cmake中如何生成动态库和静态库"><a href="#3-cmake中如何生成动态库和静态库" class="headerlink" title="3. cmake中如何生成动态库和静态库"></a>3. cmake中如何生成动态库和静态库</h2><p>参考<strong>ADD_LIBRARY</strong>和SET_TARGET_PROPERTIES用法<br>t3示例</p><h2 id="4-cmake中如何使用动态库和静态库（查找库的路径）"><a href="#4-cmake中如何使用动态库和静态库（查找库的路径）" class="headerlink" title="4. cmake中如何使用动态库和静态库（查找库的路径）"></a>4. cmake中如何使用动态库和静态库（查找库的路径）</h2><p>参考<strong>INCLUDE_DIRECTORIES</strong>, <strong>LINK_DIRECTORIES</strong>, <strong>TARGET_LINK_LIBRARIES</strong>用法<br>t4示例使用动态库或静态库<br>t5示例如何使用cmake预定义的cmake模块(以FindCURL.cmake为例演示)<br>t6示例如何使用自定义的cmake模块(编写了自定义的FindHELLO.cmake)<br>注意读t5和t6的CMakeLists.txt和FindHELLO.cmake中的注释部分</p><h2 id="5-cmake中如何指定生成文件的输出路径"><a href="#5-cmake中如何指定生成文件的输出路径" class="headerlink" title="5. cmake中如何指定生成文件的输出路径"></a>5. cmake中如何指定生成文件的输出路径</h2><p>如上<strong>ADD_SUBDIRECTORY</strong>的时候指定目标二进制文件输出路径（推荐使用下面这种）<br>使用SET命令重新定义<strong>EXECUTABLE_OUTPUT_PATH</strong>和<strong>LIBRARY_OUTPUT_PATH</strong>变量来指定最终的二进制文件的位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure><p>上面的两条命令通常紧跟<strong>ADD_EXECUTABLE</strong>和<strong>ADD_LIBRARY</strong>,与其写在同一个CMakeLists.txt即可</p><h2 id="6-cmake中如何增加编译选项"><a href="#6-cmake中如何增加编译选项" class="headerlink" title="6. cmake中如何增加编译选项"></a>6. cmake中如何增加编译选项</h2><p>使用变量<strong>CMAKE_C_FLAGS</strong>添加C编译选项<br>使用变量<strong>CMAKE_CXX_FLAGS</strong>添加C++编译选项<br>使用A<strong>DD_DEFINITION</strong>添加</p><h2 id="7-cmake中如何增加头文件路径"><a href="#7-cmake中如何增加头文件路径" class="headerlink" title="7. cmake中如何增加头文件路径"></a>7. cmake中如何增加头文件路径</h2><p>参考<strong>INCLUDE_DIRECTORIES</strong>命令用法</p><h2 id="8-cmake中如何在屏幕上打印信息"><a href="#8-cmake中如何在屏幕上打印信息" class="headerlink" title="8. cmake中如何在屏幕上打印信息"></a>8. cmake中如何在屏幕上打印信息</h2><p>参考<strong>MESSAGE</strong>用法</p><h2 id="9-cmake中如何给变量赋值"><a href="#9-cmake中如何给变量赋值" class="headerlink" title="9. cmake中如何给变量赋值"></a>9. cmake中如何给变量赋值</h2><p>参考<strong>SET</strong>和<strong>AUX_SOURCE_DIRECTORY</strong>用法</p><p>建议：在Project根目录先建立build,然后在build文件夹内运行cmake ..，这样就不会污染源代码, 如果不想要这些自动生成的文件了，只要简单的删除build文件夹就可以</p><h1 id="二-Linux-CMake工程目录结构"><a href="#二-Linux-CMake工程目录结构" class="headerlink" title="二. Linux CMake工程目录结构"></a>二. Linux CMake工程目录结构</h1><h2 id="主文件目录"><a href="#主文件目录" class="headerlink" title="主文件目录"></a>主文件目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./lib/</span><br><span class="line">./src/</span><br><span class="line">./build</span><br><span class="line">./CMakeLists.txt</span><br></pre></td></tr></table></figure><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="./CMakeLists.txt"></a>./CMakeLists.txt</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_MINIMUM_REQUIRED( VERSION 3.10 )</span><br><span class="line"></span><br><span class="line">PROJECT(MAIN)</span><br><span class="line"></span><br><span class="line">ADD_SUBDIRECTORY(./lib )</span><br><span class="line"></span><br><span class="line">ADD_SUBDIRECTORY(./src)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="lib-CMakeLists-txt"><a href="#lib-CMakeLists-txt" class="headerlink" title="./lib/CMakeLists.txt"></a>./lib/CMakeLists.txt</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AUX_SOURCE_DIRECTORY(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line">SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line">ADD_LIBRARY(LIB STATIC $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure><h2 id="src-CMakeLists-txt"><a href="#src-CMakeLists-txt" class="headerlink" title="./src/CMakeLists.txt"></a>./src/CMakeLists.txt</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line">  </span><br><span class="line">SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line">AUX_SOURCE_DIRECTORY(./ DIR_SRCS)</span><br><span class="line"></span><br><span class="line">ADD_EXECUTABLE(MAIN $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line">TARGET_LINK_LIBRARIES(MAIN LIB)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vscode调试"><a href="#vscode调试" class="headerlink" title="vscode调试"></a>vscode调试</h2><h3 id="CMakeLists-txt-1"><a href="#CMakeLists-txt-1" class="headerlink" title="./CMakeLists.txt"></a>./CMakeLists.txt</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_MINIMUM_REQUIRED( VERSION 3.10 )</span><br><span class="line"></span><br><span class="line">PROJECT(MAIN)</span><br><span class="line"></span><br><span class="line">add_definitions(-std=c++14)</span><br><span class="line">SET(CMAKE_BUILD_TYPE &quot;Debug&quot;)</span><br><span class="line">SET(CMAKE_CXX_FLAG_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)</span><br><span class="line">SET(CMAKE_CXX_FLAG_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)</span><br><span class="line"></span><br><span class="line">ADD_SUBDIRECTORY(./lib )</span><br><span class="line"></span><br><span class="line">ADD_SUBDIRECTORY(./src)</span><br></pre></td></tr></table></figure><h3 id="修改launch-json"><a href="#修改launch-json" class="headerlink" title="修改launch.json"></a>修改launch.json</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/bin/MAIN&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bert微调</title>
      <link href="/2021/11/16/bert_finetune/"/>
      <url>/2021/11/16/bert_finetune/</url>
      
        <content type="html"><![CDATA[<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/98855346">什么是BERT？ - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/48612853">词向量之BERT - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/103226488">BERT 详解 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/48508221">详解Transformer （Attention Is All You Need） - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/406786658">从Transformer到Bert - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zh-v2.d2l.ai/chapter_natural-language-processing-pretraining/bert-pretraining.html">14.10. 预训练BERT — 动手学深度学习 2.0.0-alpha2 documentation (d2l.ai)</a></p></li><li><p><a href="https://www.bilibili.com/video/av246993280?p=49">(强推)李宏毅2021春机器学习课程_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://www.bilibili.com/video/av847491605">70 BERT微调【动手学深度学习v2】_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://www.jianshu.com/p/2daf69f8408f">Bert细节整理 - 简书 (jianshu.com)</a></p></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><ul><li><a href="http://www.d2l.ai/chapter_natural-language-processing-applications/natural-language-inference-bert.html">http://www.d2l.ai/chapter_natural-language-processing-applications/natural-language-inference-bert.html</a></li></ul><h2 id="一-回顾Transformer"><a href="#一-回顾Transformer" class="headerlink" title="一. 回顾Transformer"></a>一. 回顾Transformer</h2><p>Transformer就是结合了自注意力机制的encoder-decoder网络。</p><p><img src="https://z3.ax1x.com/2021/11/16/IhZm6A.jpg" style="zoom:50%;" /></p><p>图的左边是Encoder右边是Decoder</p><h2 id="二-BERT是什么有什么用"><a href="#二-BERT是什么有什么用" class="headerlink" title="二. BERT是什么有什么用"></a>二. BERT是什么有什么用</h2><h3 id="1-BERT的优点"><a href="#1-BERT的优点" class="headerlink" title="1.BERT的优点"></a>1.BERT的优点</h3><p>​       在我们熟知的图像处理方向，模型微调的技术已经十分的成熟，我们CNN在学习过程中可以提取到一些深层特征和浅层特征，浅层的CNN网络往往学习到一些边缘，形状的很低级的特征，而深层网络可以学习到更加高级的特征，这些特征在许多图像处理问题中是通用的，所以可以载入预先训练好的模型权重，根据具体问题修改输出层进行再训练就可以取得比较好的效果。</p><p>​        在NLP领域的模型预训练和微调，就是采用的BERT,我们可以用特定的文本处理任务训练BERT,再将训练好的BERT模型进行魔改以适应不同的任务。</p><p>​        BERT有如下的特点：</p><ul><li><p>采用MLM对双向的Transformers进行预训练，以生成深层的双向语言表征。</p></li><li><p>预训练后，只需要添加一个额外的输出层进行fine-tune，就可以在各种各样的下游任务中取得很好的表现。在这过程中并不需要对BERT进行任务特定的结构修改。</p></li></ul><h3 id="2-BERT与Transformer的联系"><a href="#2-BERT与Transformer的联系" class="headerlink" title="2. BERT与Transformer的联系"></a>2. BERT与Transformer的联系</h3><p>我们可能都知道BERT只采用了Transformer的Encoder部分，但实际上这样的说法很容易让人产生误解，让人以为BERT只是Transformer的缩小版而已，实际上BERT模型比是Transformer大几个数量级。</p><p>下图更加直观地展示了BERT与Transformer之间的关系。</p><p><img src="https://z3.ax1x.com/2021/11/16/IhZNXn.jpg" style="zoom:80%;" /><br>BERT将Transformer的编码器部分进行叠加。</p><p>论文中的BERT提供了简单和复杂两个模型，对应的超参数分别如下：</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BBERT%7D_%7B%5Cmathbf%7BBASE%7D%7D" alt="[公式]"> : L=12，H=768，A=12，参数总量110M；</li><li><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BBERT%7D_%7B%5Cmathbf%7BLARGE%7D%7D" alt="[公式]"> : L=24，H=1024，A=16，参数总量340M；</li></ul><p>在上面的超参数中，L表示网络的层数（即Transformer blocks的数量），A表示Multi-Head Attention中self-Attention的数量，filter的尺寸是4H。</p><h2 id="三-BERT预训练"><a href="#三-BERT预训练" class="headerlink" title="三. BERT预训练"></a>三. BERT预训练</h2><h3 id="1-关于自监督学习Self-supervised-learning"><a href="#1-关于自监督学习Self-supervised-learning" class="headerlink" title="1. 关于自监督学习Self-supervised-learning"></a>1. 关于自监督学习Self-supervised-learning</h3><p><img src="https://z3.ax1x.com/2021/11/16/IhZyp4.png" style="zoom:67%;" /><br>自监督学习与监督学习的区别在于标签并不是特意标注的，而是通过训练数据集自己产生的，而BERT可以看作是一种自监督学习模型，即BERT在进行与训练的时候所用的标签其实就是来自与文本数据自身。</p><p>具体是如何做到的呢？主要是通过两个预训练任务的设计来实现的，一个是MLM(Masked Language Model),另一个是NSP(Next Sentence Prediction),这个之后再解释。</p><h3 id="2-BERT输入表示"><a href="#2-BERT输入表示" class="headerlink" title="2. BERT输入表示"></a>2. BERT输入表示</h3><p><img src="https://z3.ax1x.com/2021/11/16/IhZbjA.jpg" style="zoom: 80%;" /></p><p>BERT的输入为每一个token对应的表征<em>（图中的粉红色块就是token，黄色块就是token对应的表征）</em>，并且单词字典是采用WordPiece算法来进行构建的。</p><p><img src="https://z3.ax1x.com/2021/11/16/Ihep9g.jpg"  /></p><p>每一个token对应的表征组成一个编码向量（长度是512），该编码向量是3个嵌入特征的单位和，这三个词嵌入特征是：</p><ol><li><p>WordPiece 嵌入：</p><p>WordPiece是指将单词划分成一组有限的公共子词单元，能在单词的有效性和字符的灵活性之间取得一个折中的平衡。例如将‘playing’被拆分成了‘play’和‘ing’；</p></li><li><p>位置嵌入（Position Embedding）：</p><p>位置嵌入是指将单词的位置信息编码成特征向量，位置嵌入是向模型中引入单词位置关系的至关重要的一环。</p><p>位置嵌入其实就是一种代替位置编码的方法，当初讲自注意力机制的时候，使用的是不用带参数的位置编码，并且采用的是三角函数，为的是让输入数据带有位置信息，而BERT延续了这一思想，只不过将参数全部改成了可以学习的参数。</p></li><li><p>分割嵌入（Segment Embedding）：用于区分两个句子，例如B是否是A的下文（对话场景，问答场景等）。对于句子对，第一个句子的特征值是0，第二个句子的特征值是1。</p></li></ol><p>两个特殊符号<code>[CLS]</code>和<code>[SEP]</code>，其中<code>[CLS]</code>表示该特征用于分类模型，对非分类模型，该符合可以省去。<code>[SEP]</code>表示分句符号，用于断开输入语料中的两个句子。</p><h3 id="3-BERT预训练任务"><a href="#3-BERT预训练任务" class="headerlink" title="3. BERT预训练任务"></a>3. BERT预训练任务</h3><h4 id="3-1-Masked-Language-Model（MLM）"><a href="#3-1-Masked-Language-Model（MLM）" class="headerlink" title="3.1 Masked Language Model（MLM）"></a>3.1 Masked Language Model（MLM）</h4><p>​        所谓MLM是指在训练的时候随即从输入预料上mask掉一些单词，然后通过的上下文预测该单词，该任务非常像完形填空。</p><p>​        mask的好处，即预测一个词汇时，模型并不知道输入对应位置的词汇是否为正确的词汇（ 10% 概率），这就迫使模型更多地依赖于上下文信息去预测词汇，并且赋予了模型一定的纠错能力。</p><p><img src="https://z3.ax1x.com/2021/11/16/IheVEV.png" style="zoom: 50%;" /></p><p>这个mask可以是特殊符号‘<mask>’也可以是随机选取一些乱七八糟的符号，又或者是原来正确的符号。</p><p>在BERT的实验中，15%的WordPiece Token会被随机Mask掉。在训练模型时，一个句子会被多次喂到模型中用于参数学习，但是Google并没有在每次都mask掉这些单词，而是在确定要Mask掉的单词之后，80%的时候会直接替换为[Mask]，10%的时候将其替换为其它任意单词，10%的时候会保留原始Token。</p><ul><li>80%：<code>my dog is hairy -&gt; my dog is [mask]</code></li><li>10%：<code>my dog is hairy -&gt; my dog is apple</code></li><li>10%：<code>my dog is hairy -&gt; my dog is hairy</code></li></ul><p>​        这么做的原因是如果句子中的某个Token100%都会被mask掉，那么在fine-tuning的时候模型就会有一些没有见过的单词。加入随机Token的原因是因为Transformer要保持对每个输入token的分布式表征，否则模型就会记住这个[mask]是token ’hairy‘，但是实际fine-tune的时候并没有[mask]这个符号。至于随机单词带来的负面影响，因为一个单词被随机替换掉的概率只有15%*10% =1.5%，这个负面影响其实是可以忽略不计的。</p><h4 id="3-2-Next-Sentence-Prediction（NSP）"><a href="#3-2-Next-Sentence-Prediction（NSP）" class="headerlink" title="3.2 Next Sentence Prediction（NSP）"></a>3.2 Next Sentence Prediction（NSP）</h4><p>​        为了帮助 理解两个⽂本序列之间的关系，BERT在预训练中考虑了⼀个⼆元分类任务——下⼀句预测。在为预训练⽣成 句⼦对时，有⼀半的时间它们确实是标签为“真”的连续句⼦；在另⼀半的时间⾥，第⼆个句⼦是从语料库 中随机抽取的，标记为“假”。</p><ul><li>预测一个句子对中的两个句子是否相邻</li><li>训练样本中：<ul><li>50%概率选择相邻句子对:<cls>this movie is great <seq>i like it<sep></li><li>50%概率选择随机句子对:<cls>this movie is great <seq>hello world<sep></li><li>将<cls>对应的输出放到一个全连接层来预测</li></ul></li></ul><p><img src="https://z3.ax1x.com/2021/11/16/Iheu34.png" style="zoom: 50%;" /></p><p>​       关于NSP是否有用是存在争议的，(参见RoBERTa这篇论文)。因为选定一个句子作为前一个句子，大部分情况下随机选到的句子都不是后一个句子，也就是BERT是很容易判断出来两个句子是否相邻的。对此也有人提出了改进方法SOP，SOP更加侧重于判断两个句子的前后关系，而不是两个句子是否相邻。</p><h4 id="Tips-BERT预训练是多任务模型的预训练，因此NSP和MLM两个任务的训练是同时进行的。"><a href="#Tips-BERT预训练是多任务模型的预训练，因此NSP和MLM两个任务的训练是同时进行的。" class="headerlink" title="Tips: BERT预训练是多任务模型的预训练，因此NSP和MLM两个任务的训练是同时进行的。"></a>Tips: BERT预训练是多任务模型的预训练，因此NSP和MLM两个任务的训练是同时进行的。</h4><h2 id="四-BERT微调fine-tune"><a href="#四-BERT微调fine-tune" class="headerlink" title="四. BERT微调fine-tune"></a>四. BERT微调fine-tune</h2><h3 id="1-自然语言推理-Natural-Language-Inference"><a href="#1-自然语言推理-Natural-Language-Inference" class="headerlink" title="1. 自然语言推理(Natural Language Inference)"></a>1. 自然语言推理(Natural Language Inference)</h3><p>自然语言推理研究是否有假设可以从前提推断出来，其中两者都是文本序列。换句话说，自然语言推理决定了一对文本序列之间的逻辑关系。这种关系通常分为三种类型：</p><ul><li><em>蕴含（entailment）</em>：假设可以从前提中推断出来。</li><li><em>矛盾（contradiction）</em>：可以从前提中推断假设的否定。</li><li><em>中立（neutral）</em>：所有其他情况。</li></ul><p>自然语言推理也被称为识别文本蕴含任务。例如，下面的词元对将被标记为<em>蕴含（entailment）</em>，因为假设中的 “显示亲情” 可以从前提中的 “相互拥抱” 推断出来。</p><blockquote><p>前提：两个女人互相拥抱。</p><p>假设：两个女人表现出亲情。</p></blockquote><p>以下是 <em>矛盾</em> 的例子，因为 “运行编码示例” 表示 “没有睡觉” 而不是 “睡觉”。</p><blockquote><p>前提：一个男人正在运行从 “潜入深度学习” 中的编码示例。</p><p>假设：那个男人在睡觉。</p></blockquote><p>第三个例子显示了 <em> 中立性 </em> 关系，因为 “正在为我们表演” 这一事实既不能推断 “著名的” 也不是 “不出名”。</p><blockquote><p>前提：音乐家们正在为我们表演。</p><p>假设：音乐家很有名。</p></blockquote><h3 id="2-NLI微调模型"><a href="#2-NLI微调模型" class="headerlink" title="2. NLI微调模型"></a>2. NLI微调模型</h3><p>​        BERT在预训练好之后就可以通过更改输出层来完成不同的任务，本节所讲的fine-tune应用是自然语言推理Natural Language Inference</p><p><img src="https://z3.ax1x.com/2021/11/16/IheluR.png" style="zoom: 80%;" /></p><p>本次微调所用的输出层很简单，直接在BERT输出层添加一个多层感知机。</p><h3 id="3-SNLI数据集"><a href="#3-SNLI数据集" class="headerlink" title="3. SNLI数据集"></a>3. SNLI数据集</h3><p>To Be Continued !</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英文论文套话</title>
      <link href="/2021/11/14/en_paper_tips/"/>
      <url>/2021/11/14/en_paper_tips/</url>
      
        <content type="html"><![CDATA[<h2 id="一-常用句式"><a href="#一-常用句式" class="headerlink" title="一. 常用句式"></a>一. 常用句式</h2><h3 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h3><h3 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h3><p>In recent years, DG has received increasing attention from the research community due to its importance to practical applications.</p><p>To overcome the domain shift problem, as well as the absence of target data, the problem of domain generalization (DG) is introduced .</p><p>In this survey paper, we aim to provide a timely and comprehensive literature review.   </p><p>In the context of DG,(就DG而言)</p><h3 id="3-Related-work"><a href="#3-Related-work" class="headerlink" title="3. Related work"></a>3. Related work</h3><h3 id="4-Formulation"><a href="#4-Formulation" class="headerlink" title="4. Formulation"></a>4. Formulation</h3><h3 id="5-Implementation"><a href="#5-Implementation" class="headerlink" title="5. Implementation"></a>5. Implementation</h3><h3 id="6-Results"><a href="#6-Results" class="headerlink" title="6. Results"></a>6. Results</h3><h3 id="7-Limitations-and-Discussion"><a href="#7-Limitations-and-Discussion" class="headerlink" title="7. Limitations and Discussion"></a>7. Limitations and Discussion</h3><h2 id="二-替换词"><a href="#二-替换词" class="headerlink" title="二. 替换词"></a>二. 替换词</h2><h3 id="1-To-Be-Continued"><a href="#1-To-Be-Continued" class="headerlink" title="1. To Be Continued~"></a>1. To Be Continued~</h3><p>未完待续~</p><h3 id="2-To-Be-Continued"><a href="#2-To-Be-Continued" class="headerlink" title="2. To Be Continued~"></a>2. To Be Continued~</h3><p>未完待续~</p><h3 id="3-To-Be-Continued"><a href="#3-To-Be-Continued" class="headerlink" title="3. To Be Continued~"></a>3. To Be Continued~</h3><p>未完待续~</p>]]></content>
      
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自注意力</title>
      <link href="/2021/10/14/self_attention/"/>
      <url>/2021/10/14/self_attention/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们前面说过，注意力机制包含几个重要的参数，query，key，value，针对不同的问题，往往需要选择合适的变量来作为query，key,和value，当遇到query,key,value都是同一个东西，同一种参数的时候，这样的机制叫做自注意力机制。</p><h2 id="1-自注意力"><a href="#1-自注意力" class="headerlink" title="1. 自注意力"></a>1. 自注意力</h2><p>假设我们有一个输入序列</p><script type="math/tex; mode=display">\mathbf{x}_{1}, \ldots, \mathbf{x}_{n}, \forall \mathbf{x}_{i} \in \mathbb{R}^{d}</script><p>xi是第i个时间步的输入，d是输入值的特征维度，自注意力池化层将xi同时作为query,key,value，对序列抽取特征得到</p><script type="math/tex; mode=display">\mathbf{y}_{1}, \ldots, \mathbf{y}_{n}</script><p>其中  </p><script type="math/tex; mode=display">\mathbf{y}_{i}=f\left(\mathbf{x}_{i},\left(\mathbf{x}_{1}, \mathbf{x}_{1}\right), \ldots,\left(\mathbf{x}_{n}, \mathbf{x}_{n}\right)\right) \in \mathbb{R}^{d}</script><p>xi作为query，key-value对包含了所有的xi对，对应序列中的每一个元素xi都会输出一个yi。</p><p><a href="https://imgtu.com/i/f4TBZ9"><img src="https://z3.ax1x.com/2021/08/17/f4TBZ9.png" alt="f4TBZ9.png"></a></p><h2 id="2-与CNN-RNN对比"><a href="#2-与CNN-RNN对比" class="headerlink" title="2. 与CNN,RNN对比"></a>2. 与CNN,RNN对比</h2><p><a href="https://imgtu.com/i/f4q77Q"><img src="https://z3.ax1x.com/2021/08/17/f4q77Q.png" alt="f4q77Q.png"></a></p><p>对于CNN，k就是指卷积核的大小，n是输入数据量，d是指数据维度，并行度就是说每个输出之间可以各自独立运算出结果，第一个输出的结果不取决于上一个输出，这样的话就很方便进行并行的计算，大家可以同时计算，这样的计算效率就比较高。<br><a href="https://imgtu.com/i/f4OIoQ"><img src="https://z3.ax1x.com/2021/08/17/f4OIoQ.png" alt="f4OIoQ.png"></a></p><p>最长路径我理解的是输入信息在前向计算和反向传播过程中影响到另一个输入所需要走过的最长路径。</p><p><a href="https://imgtu.com/i/f4quYn"><img src="https://z3.ax1x.com/2021/08/17/f4quYn.png" alt="f4quYn.png"></a></p><p>自注意力的计算复杂度比较高，尤其是输入序列较长的时候，根据之前计算yi的公式，我们需要把序列中的每个元素都进行计算，这带来了比较大的计算负担。但是最大路径很短，这在网路示意图中可以很明显的看到，当序列很长的时候可以很快获取到距离比较远的信息。且相较于RNN多级传递可以有较少的信息损失。</p><p>我们都知道RNN适合处理序列但处理长序列就会有长程依赖的问题，为了解决这个问题提出了LSTM，但LSTM正如它的名字长短时记忆网络，终究只是比较长的短时记忆网络，原有局限性有改善但是依旧存在，因此结合自注意力池化可以做得更好，付出的代价就是高昂的计算成本。</p><h2 id="3-位置编码"><a href="#3-位置编码" class="headerlink" title="3. 位置编码"></a>3. 位置编码</h2><p>跟CNN和RNN不同，自注意力并没有记录位置信息。</p><p><a href="https://imgtu.com/i/f5pDXR"><img src="https://z3.ax1x.com/2021/08/17/f5pDXR.png" alt="f5pDXR.png" style="zoom:50%;" /></a></p><p>意思就是当我输入序列顺序打乱，输出的顺序也会打乱，但是对应位置上的输出本身内容并不会发生改变，但是我们知道在处理序列的时候元素的顺序也是信息的一部分，比如在在翻译任务里面语序的不同往往对应不同的输出。</p><p>一个解决办法就是把位置信息添加到输入序列中，让输入数据本身就带有位置信息。</p><h4 id="位置矩阵"><a href="#位置矩阵" class="headerlink" title="位置矩阵"></a>位置矩阵</h4><p>假设长度为n的序列是$\mathbf{X} \in \mathbb{R}^{n \times d}$，那么使用一个位置编码矩阵$\mathbf{P} \in \mathbb{R}^{n \times d}$,​将P加在X上，将X+P作为输入。其中P本身包含了许多关于X元素的位置信息，那么我们的目标就是找到一个合理的算法能够有效的提取X的位置信息并且存储在P里面。</p><p>P的计算公式如下：</p><p>$p_{i, 2 j}=\sin \left(\frac{i}{10000^{2 j / d}}\right), \quad p_{i, 2 j+1}=\cos \left(\frac{i}{10000^{2 j / d}}\right)$</p><p>i代表序列的第几个元素，即所谓的位置，j代表第几个特征维度。奇数列和偶数列不一样。</p><p>这是位置矩阵的图像。</p><p><a href="https://imgtu.com/i/f5PQpD"><img src="https://z3.ax1x.com/2021/08/17/f5PQpD.png" alt="f5PQpD.png"  /></a></p><p>途中的Row(position)对应的是位置矩阵的n，即第几个元素，不同的col列对应不同的特征维度。</p><p>模型需要有一定能力才能够学习到输入数据和位置信息之间的关系，这个位置矩阵存储的是相对位置信息。</p><p>我觉得可以借助信号处理的知识来理解这个位置矩阵，在信号与系统我们可以知道，对于任意一个时序信号我们都可以通过傅里叶变换将一个信号变换到频域，这个信号就会存在许多频域的分量。每一个频率分量在时域上进行叠加就得到一个完整的信号。</p><p>我们可以将输入序列X的每一维特征类比到频域的每一个频率分量即col6,col7都对应一个频率分量，然后不同的位置i或者时间点t即Row（position）就对应输入信号的不同的相位。不同的时间点i之间的差就可以类比相位差。</p><p>我们知道正弦信号具有周期性，所以其实相位差代表的就是相对位置关系，所以我们可以认为位置矩阵存储的是相对位置关系。</p><p><a href="https://imgtu.com/i/f5Abse"><img src="https://z3.ax1x.com/2021/08/17/f5Abse.png" alt="f5Abse.png" style="zoom: 80%;" /></a></p><h4 id="绝对位置信息"><a href="#绝对位置信息" class="headerlink" title="绝对位置信息"></a>绝对位置信息</h4><p>或者可以借助计算机使用的二进制编码来理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 in binary is 000</span><br><span class="line">1 in binary is 001</span><br><span class="line">2 in binary is 010</span><br><span class="line">3 in binary is 011</span><br><span class="line">4 in binary is 100</span><br><span class="line">5 in binary is 101</span><br><span class="line">6 in binary is 110</span><br><span class="line">7 in binary is 111</span><br></pre></td></tr></table></figure><p>我们也可以将$0~7$这个序列的每个元素都由长度为3的特征表示，低位的特征变化频率就比高位的变化要快。</p><p><a href="https://imgtu.com/i/f5mh3q"><img src="https://z3.ax1x.com/2021/08/17/f5mh3q.png" alt="f5mh3q.png"></a></p><h4 id="相对位置信息"><a href="#相对位置信息" class="headerlink" title="相对位置信息"></a>相对位置信息</h4><p>位置位于$i+\delta$​处的位置编码可由线性投影位置$i$​处的位置编码来表示​</p><p>记$\omega_{j}=1 / 10000^{2 j / d}$，那么</p><p>$\left[\begin{array}{cc}\cos \left(\delta \omega_{j}\right) &amp; \sin \left(\delta \omega_{j}\right) \\ -\sin \left(\delta \omega_{j}\right) &amp; \cos \left(\delta \omega_{j}\right)\end{array}\right]\left[\begin{array}{c}p_{i, 2 j} \\ p_{i, 2 j+1}\end{array}\right]=\left[\begin{array}{c}p_{i+\delta, 2 j} \\ p_{i+\delta, 2 j+1}\end{array}\right]$</p><p>这样就意味着输入序列的两个元素之间的相对位置关系固定的情况下，不管其中一个元素的绝对位置在哪，它们之间的相对位置关系都可以用同一个投影矩阵表示，毕竟这个投影矩阵和绝对位置$i$​没有关系。如果要用一个参数$W$​，表示相对位置关系采用这样的形式就可以不用顾及元素出现在序列的哪一个位置。</p><p>其实也可以用相位差来类比，正弦信号相乘会引起相位变化。</p><p><a href="https://imgtu.com/i/f5Kkct"><img src="https://z3.ax1x.com/2021/08/17/f5Kkct.md.jpg" alt="f5Kkct.md.jpg"></a></p><p>可以看到，在与投影矩阵相乘之后，原来的正弦函数发生了相位偏移。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>自注意力池化层将$x_i$​当作key,value,query来对序列抽取特征​</li><li>完全并行，最长序列为1(对于任何一个输出都参考了整个序列的信息)，长序列计算成本高</li><li>位置编码在输入中加入位置信息，使得自注意力能够记忆位置信息。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/14/hello-world/"/>
      <url>/2021/10/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
