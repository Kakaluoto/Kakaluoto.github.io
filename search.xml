<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【06】【C++】C++继承、虚函数、接口(纯虚函数)</title>
      <link href="/2024/12/12/06_C++%E7%BB%A7%E6%89%BF_%E8%99%9A%E5%87%BD%E6%95%B0_%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2024/12/12/06_C++%E7%BB%A7%E6%89%BF_%E8%99%9A%E5%87%BD%E6%95%B0_%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++继承"></a>C++继承</h1><h2 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h2><p>代码样例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xa, <span class="type">float</span> ya)</span> </span>&#123;</span><br><span class="line">        x += xa;</span><br><span class="line">        y += ya;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *Name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; Name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">1</span>;</span><br><span class="line">    player.y = <span class="number">2</span>;</span><br><span class="line">    player.<span class="built_in">Move</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(Player) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(Entity) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line">16</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>可以看到继承父类的Player占用内存比父类大，这是因为多了Name成员变量。</p><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>虚函数允许我们在子类中重写方法。假设B是A的子类，如果在A类中创建一个方法并使用virtual修饰，我们就可以选择在B类中重写那个方法，让它做其他的事情。</p><h2 id="demo1-普通继承"><a href="#demo1-普通继承" class="headerlink" title="demo1 普通继承"></a>demo1 普通继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;mName) : <span class="built_in">m_Name</span>(mName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    std::cout &lt;&lt; e-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;steve&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity</span><br><span class="line">steve</span><br></pre></td></tr></table></figure><p>符合预期，没什么异常</p><h2 id="demo2-多态"><a href="#demo2-多态" class="headerlink" title="demo2 多态"></a>demo2 多态</h2><p>如果我们使用多态的概念，那么上个demo的写法就会有问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;mName) : <span class="built_in">m_Name</span>(mName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    std::cout &lt;&lt; e-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;steve&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    Entity* entity = p;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entity</span><br><span class="line">steve</span><br><span class="line">Entity</span><br></pre></td></tr></table></figure><p>这是因为当我们调用某个方法时，会调通属于该类型的方法。可以进一步观察下面的例子。对于PrintName而言它的参数是Entity类型，这意味着当我们调用GetName函数时，如果是Entity类型，那么它会从Entity类中找到GetName函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;mName) : <span class="built_in">m_Name</span>(mName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; e-&gt;GetName() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;steve&quot;</span>);</span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; p-&gt;GetName() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">PrintName</span>(p);</span><br><span class="line"><span class="comment">//    Entity* entity = p;</span></span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity</span><br><span class="line">Entity</span><br></pre></td></tr></table></figure><p>如果想让C++在调用GetName意识到，PrintName函数中传递的是Player而不是Entity，就需要使用虚函数。虚函数引入了一种叫做Dynamic Dispatch(动态联编)的东西，它通常通过V表(虚函数表)来实现编译。V表就是一个表，它包含基类中所有虚函数的映射，这样我们可以在它运行时，将它们映射到正确的覆写(override)函数。简而言之，如果你想覆写一个函数，你必须将基类中的基函数声明为虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;mName) : <span class="built_in">m_Name</span>(mName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;steve&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintName</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加了virtual声明之后就相当于告诉编译器，为GetName函数生成一个V表，以便能够成功通过映射找到子类覆写的函数。除此之外，在C++11中引入了”将覆写函数标记为关键字override”的特性。定义PrintName函数，通过基类Entity实现多态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;mName) : <span class="built_in">m_Name</span>(mName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;steve&quot;</span>);</span><br><span class="line">    <span class="built_in">PrintName</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过加入override关键字可以显式的告诉编译器这是一个覆写函数，使代码更具可读性，帮助预防bug的发生，比如函数名的一些拼写错误，因为找不到可以覆写的函数，或者当我们尝试覆写一个非虚函数也会报错(只有被覆写的虚函数才能被标记为override)。</p><p>但是虚函数可能会带来两种与虚函数相关的运行时成本。首先我们需要额外的内存来存储V表，这样才能分配到正确的函数，包括基类中需要有一个成员指针指向V表。其次，每次我们调用虚函数需要遍历这个表来确定要映射到哪个函数，这带来了额外的开销。</p><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>C++的纯虚函数本质上与其他语言(如Java或C#)中的抽象方法或接口相同，纯虚函数允许我们在基类中定义一个没有实现的函数，然后强制子类去实现该函数。 </p><h2 id="demo1-1"><a href="#demo1-1" class="headerlink" title="demo1"></a>demo1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;mName) : <span class="built_in">m_Name</span>(mName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; e-&gt;GetName() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">PrintName</span>(e);</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;steve&quot;</span>);</span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; p-&gt;GetName() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">PrintName</span>(p);</span><br><span class="line"><span class="comment">//    Entity* entity = p;</span></span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时Entity* e = new Entity();爆红，如果Player子类去掉函数的具体实现一样也会爆红。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202412120137911.png" alt="image-20241212013606795"></p><h2 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h2><p>假设现在我们想要一个函数，可以打印输入变量的类名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(??? obj)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;obj-&gt;<span class="built_in">GetClassName</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在问号处，我们需要一个类型，该类型能够保证我们有GetClassName函数，这个类型就是所谓的接口(C++使用抽象类实现接口)。以下代码定义了Printable接口，Entity实现了接口函数，Player对Entity实现的接口函数进行了覆写。Printable入参不关心输入参数的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;mName) : <span class="built_in">m_Name</span>(mName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;steve&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(e);</span><br><span class="line">    <span class="built_in">Print</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity</span><br><span class="line">Player</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【05】【C++】C++析构函数</title>
      <link href="/2024/12/11/05_C++%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>/2024/12/11/05_C++%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>构造函数是创建一个新的实例对象时运行，析构函数则是在销毁一个对象时运行。析构函数同时适用于栈和堆分配的对象。如果使用new分配一个对象，当你调用delete时，析构函数会被调用。析构函数使用的目的往往是为了释放资源。</p><p>代码样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        x = <span class="number">0.0f</span>;</span><br><span class="line">        y = <span class="number">0.0f</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Deleted Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line">Created Entity</span><br><span class="line">0---0</span><br><span class="line">Deleted Entity</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【04】【C++】C++中的枚举</title>
      <link href="/2024/12/09/04_C++%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE/"/>
      <url>/2024/12/09/04_C++%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举值默认从0开始，类内部的枚举并不是一个命名空间，因为每个实例用的枚举都一样，所以可以不构造实例直接通过类进行访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">        D, E = <span class="number">5</span>, F,G,H=<span class="number">1</span>,I,J,K</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test test;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; Test::D &lt;&lt; Test::E &lt;&lt; Test::F &lt;&lt; Test::G&lt;&lt; Test::H&lt;&lt; Test::I&lt;&lt; Test::J&lt;&lt; Test::K&lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出为05671234</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【03】【C++】C++中的静态</title>
      <link href="/2024/12/06/03_C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81/"/>
      <url>/2024/12/06/03_C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h1><p>static关键字在C++中有两个意思，这取决于上下文，其中之一是在类或结构体外使用static关键字，另一种是在类或结构体内使用static。类外部的static静态变量，意味着你声明为static的符号，链接只是在内部，这意味这它只能对你定义它的翻译单元可见。类内部的static静态变量，将与类的所有实例共享内存，这意味着该静态变量在你类中创建的所有实例中只有一个实例。对于static方法而言，这在告诉编译器这个方法只会在当前翻译单元中被用到，其他翻译单元不会调用，这将会影响链接过程。</p><p>静态变量或者函数意味着，当需要将这些函数或变量与实际定义的符号链接时，链接器不会在这个翻译单元的作用域之外寻找那个符号的定义。</p><h1 id="类与结构体之外的静态"><a href="#类与结构体之外的静态" class="headerlink" title="类与结构体之外的静态"></a>类与结构体之外的静态</h1><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s_val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s_val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Static.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>文件结构如上，可以成功编译，main输出10</p><h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Static.cpp</span></span><br><span class="line"><span class="type">int</span> s_val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>去掉static就会报错，链接错误</p><p>一种解决方案是使用extern,告诉编译器在别的翻译单元寻找s_Val的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> s_val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s_val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，main的输出值是5。</p><h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h2><p>如果尝试将Static.cpp的变量修改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Static.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> s_val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s_val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmake编译报错undefined reference to `s_val’，因为链接器在全局作用域下找不到Static.cpp里的s_val。</p><h1 id="类或结构体内的静态"><a href="#类或结构体内的静态" class="headerlink" title="类或结构体内的静态"></a>类或结构体内的静态</h1><p>如果类成员变量被static修饰，意味着该类的所有实例均共享同一个该静态成员变量。静态方法无法访问类的实例，因为你不知道应该访问类的哪个实例。静态类变量和静态类方法不需要通过实例进行访问。</p><h2 id="Example-1-1"><a href="#Example-1-1" class="headerlink" title="Example 1"></a>Example 1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">4</span>;</span><br><span class="line">    e1.y = <span class="number">5</span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码编译失败，因为类或结构体的静态变量需要在类或结构体之外定义，类的静态成员变量需要在类外分配内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">4</span>;</span><br><span class="line">    e1.y = <span class="number">5</span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功编译通过。</p><p>实际上修改静态成员变量可以使用如下方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    Entity::x = <span class="number">2</span>;</span><br><span class="line">    Entity::y = <span class="number">3</span>;</span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法同理。</p><h2 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2"></a>Example 2</h2><p>静态方法不能访问非静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line">    Entity::<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDE静态检查无法通过。因为每个非静态方法总是会获取当前类的一个实例作为参数。</p><h1 id="C-中的局部静态"><a href="#C-中的局部静态" class="headerlink" title="C++中的局部静态"></a>C++中的局部静态</h1><p>声明一个变量我们需要考虑两个事情，变量的生存期和变量的作用域。静态局部变量相当于在函数内部声明了一个变量，它的生命周期基本上相当于整个程序的生命周期，但是它的作用范围被限制在这个函数内部。你可以在任何作用域中声明局部静态变量，可以是函数内，也可以是if语句块内，或者其他地方。</p><h2 id="Example-1-2"><a href="#Example-1-2" class="headerlink" title="Example 1"></a>Example 1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Func</span>();</span><br><span class="line">    <span class="built_in">Func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多解释，输出1和2。如果去掉static，不管调用Func几次，输出都一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【02】【C++】C++类</title>
      <link href="/2024/11/14/02_C++%E7%B1%BB/"/>
      <url>/2024/11/14/02_C++%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><h2 id="C-的类长什么样？"><a href="#C-的类长什么样？" class="headerlink" title="C++的类长什么样？"></a>C++的类长什么样？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">0</span>;</span><br><span class="line">    player.y = <span class="number">0</span>;</span><br><span class="line">    player.speed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上Class就构成了C++最简单的一个类，但是如果编译就会发现报错，这是因为C++类成员变量不经过任何声明默认就是私有的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\MyCppProject\untitled\main.cpp:12:12: error: &#x27;int Player::x&#x27; is private within this context</span><br><span class="line">   12 |     player.x = 0;</span><br></pre></td></tr></table></figure><p>当定义成如下形式，就可以正常访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>加入方法的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span> </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="C-类与结构体的比较"><a href="#C-类与结构体的比较" class="headerlink" title="C++类与结构体的比较"></a>C++类与结构体的比较</h2><p>C++类成员方法和成员变量默认都是private的，但是在struct中它们是public的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span> </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">0</span>;</span><br><span class="line">    player.y = <span class="number">0</span>;</span><br><span class="line">    player.speed = <span class="number">0</span>;</span><br><span class="line">    player.<span class="built_in">move</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们去掉public的声明形式，编译不会通过，因为x,y以及move函数都是不可见无法访问的，但是当你将类换成结构体就可以访问了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span> </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">0</span>;</span><br><span class="line">    player.y = <span class="number">0</span>;</span><br><span class="line">    player.speed = <span class="number">0</span>;</span><br><span class="line">    player.<span class="built_in">move</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至可以在struct里进行private声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span> </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就又回到了最初Class里定义成priavte的状态，即外部无法访问。</p><p>从技术上来说Class和Struc的区别就这些了，除了可见性之外，Class支持的特性Struct也都支持(比如继承)，但当我们实际使用时，更推荐当仅仅需要将不同变量进行组合时使用Struct，需要涉及到方法时使用Class。</p><h2 id="麻雀虽小五脏俱全的类"><a href="#麻雀虽小五脏俱全的类" class="headerlink" title="麻雀虽小五脏俱全的类"></a>麻雀虽小五脏俱全的类</h2><p>这是一个小demo，之后的学习将以这个demo为基础引入各种概念进行改进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">        m_LogLevel = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LogLevelError &lt;= m_LogLevel) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Error]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LogLevelWarning &lt;= m_LogLevel) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[WARNING]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LogLevelInfo &lt;= m_LogLevel) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Info]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log log;</span><br><span class="line">    log.<span class="built_in">SetLevel</span>(log.LogLevelWarning);</span><br><span class="line">    log.<span class="built_in">Warn</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Error</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Info</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】Redis 极简入门课件</title>
      <link href="/2023/07/11/Redis/"/>
      <url>/2023/07/11/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-极简入门课件"><a href="#Redis-极简入门课件" class="headerlink" title="Redis 极简入门课件"></a>Redis 极简入门课件</h1><p>参考视频链接<a href="https://www.bilibili.com/video/BV15L411D7yo/?spm_id_from=333.999.0.0&amp;vd_source=38756f21987432261a67b61d2801bded">Redis极简入门：纯小白成长为大白，只需4个半小时~_哔哩哔哩_bilibili</a></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/redis.webp" alt="img"></p><h1 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h1><p>1&gt;了解NoSQL概念</p><p>2&gt;了解Redis概念，定位，优点，缺点</p><p>3&gt;掌握Redis常用五大类型</p><p>4&gt;掌握Redis Key 与Value值设计</p><p>5&gt;掌握Redis全局命令</p><p>6&gt;掌握Redis 安全与事务操作</p><p>7&gt;了解Redis持久化策略</p><p>8&gt;了解Redis内存淘汰机制与过期Key清理</p><p>9&gt;掌握Java集成Redis操作</p><p>10&gt;完成综合案例设计与实现</p><h1 id="认识-Redis"><a href="#认识-Redis" class="headerlink" title="认识 Redis"></a>认识 Redis</h1><h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><p>目前数据库分：关系型数据库与非关系型数据库</p><p>常用的关系型数据库： Oracle，<strong>MySQL</strong>，SqlServer，DB2</p><p>常用的非关系数据库：<strong>Redis</strong>，MongoDB，ElasticSearch， Hbase，Neo4j</p><p>那啥是非关系数据库呢？此处涉及到新名词：NoSQL</p><p><strong>NoSQL</strong>最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库，它们不保证关系数据的ACID特性。详情见：百度百科：<a href="https://baike.baidu.com/item/NoSQL/8828247?fr=aladdin">https://baike.baidu.com/item/NoSQL/8828247?fr=aladdin</a></p><h2 id="NoSQL分类"><a href="#NoSQL分类" class="headerlink" title="NoSQL分类"></a>NoSQL分类</h2><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220829191301206.webp" alt="image-20220829191301206">*</p><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p>是以key-value形式存储,和传统的关系型数据库不一样.不一定遵循传统数据库的一些基本要求.(非关系型的,分布式的,开源的,水平可拓展的)</p><p>优点:<br>    <strong>对数据高并发读写</strong>(直接是内存中进行读写的)<br>    对海量数据的高效率存储和访问<br>    对数据的可拓展性和高可用性.<br>    <strong>单线程操作</strong>,每个操作都是原子操作,没有并发相关问题(redis 6)</p><p>缺点:<br>    redis(ACID处理非常简单)<br>    无法做太复杂的关系数据库模型</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220829191453155.webp" alt="image-20220829191453155">*</p><h3 id="谁在用Redis"><a href="#谁在用Redis" class="headerlink" title="谁在用Redis"></a>谁在用Redis</h3><p>比较著名的公司有：<br>github、blizzard、stackoverflow、flickr</p><p>国内<br>新浪微博（全球最大的redis集群）【2017】<br>    2200+亿 commands/day 5000亿Read/day 500亿Write/day<br>    18TB+ Memory<br>    500+ Servers in 6 IDC 2000+instances<br>淘宝<br>腾讯微博</p><h3 id="怎么学redis"><a href="#怎么学redis" class="headerlink" title="怎么学redis"></a>怎么学redis</h3><p>redis在线入门 ： <a href="http://try.redis.io/">http://try.redis.io/</a><br>redis 中文资料站： <a href="http://www.redis.cn/">http://www.redis.cn/</a><br><a href="https://www.runoob.com/redis/redis-tutorial.html">https://www.runoob.com/redis/redis-tutorial.html</a></p><h3 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h3><p>题外话：</p><p>Redis是使用C写的程序，目前主流在Linux操作系统，官方不提供Window版，最新的Redis版：Redis7.x</p><p>官网下载：<a href="https://redis.io/download/">https://redis.io/download/</a></p><p>Redis 的Window版是微软公司自行移植的，目前最新版：Redis-x64-3.2.100</p><p>window版：<a href="https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100">https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100</a></p><p>新版控的同学：</p><p>1&gt;购买阿里云Redis</p><p><a href="https://www.aliyun.com/minisite/goods?taskPkg=amb618all&amp;pkgSid=442814&amp;recordId=4183761&amp;userCode=sd4xtwwm">https://www.aliyun.com/minisite/goods?taskPkg=amb618all&amp;pkgSid=442814&amp;recordId=4183761&amp;userCode=sd4xtwwm</a></p><p>2&gt;购买阿里云ECS</p><p>购买服务器，自己搭建最新版的Redis</p><p>3&gt;安装虚拟机：Linux，再安装最新版Redis</p><p>这个，项目三讲Linux操作系统时再教。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h4><p>版本：Redis-x64-3.2.100.msi</p><p>傻瓜式安装,下一步,下一步就可以了</p><p><strong>注意：添加到环境变量中</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/32fe25ef354f50b88cb9ec6edc4afa32929c18dc.webp" alt="img">*</p><p><strong>注意：默认端口</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/1f9feadca039131f886b976ce275f2c4ed990adc.webp" alt="Windowsä¸å®è£Redisæå¡">*</p><p><strong>注意：最大内存</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/486884883913e8e5b969e909352f477047187ddc.webp" alt="Windowsä¸å®è£Redisæå¡">*</p><p><strong>测试是否成功</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220829193133720.webp" alt="image-20220829193133720">*</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220829193150712.webp" alt="image-20220829193150712">*</p><h4 id="客户端—redisclient"><a href="#客户端—redisclient" class="headerlink" title="客户端—redisclient"></a><strong>客户端</strong>—redisclient</h4><p>打开CMD命令框，输入命令：<strong>java -jar  redisclient.jar</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220829192445744.webp" alt="image-20220829192445744"></p><h4 id="客户端—RedisDesktopClient"><a href="#客户端—RedisDesktopClient" class="headerlink" title="客户端—RedisDesktopClient"></a><strong>客户端</strong>—RedisDesktopClient</h4><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220829192521886.webp" alt="image-20220829192521886"></p><h4 id="客户端—rdm"><a href="#客户端—rdm" class="headerlink" title="客户端—rdm"></a><strong>客户端</strong>—rdm</h4><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220829192607349.webp" alt="image-20220829192607349"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>Redis支持的存储数据类型有很多：</p><p>常用：<strong>string</strong>（字符串），<strong>hash</strong>（哈希），<strong>list</strong>（列表），<strong>set</strong>（集合）及<strong>zset</strong>(sorted set：有序集合)</p><p>不常用：HyperLogLog，Bitmap(位图)，Bloom Filter(布隆过滤器)，Geospatial(地理位置) ，Module(模块)， Streams(流信息)</p><p>此处重点讲解常用的类型。</p><p><strong>命令格式</strong></p><p>类型命令    key       参数数据</p><p>   set           name    dafei</p><p><strong>操作建议</strong></p><p>Redis操作有点类似Java的Map集合，都是key-value形式存储数据，在学习过程中，可以进行类比。</p><p>另外Redis中的key大部分为String类型，value值根据缓存数据结构可以选用：string，hash，list，set，zset等类型。</p><p><strong>注意：下面讲的各种类型，表述的是缓存数据的value类型。</strong></p><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型包含多种类型的特殊类型，并且是二进制安全的，其值可以是数值，可以是字符串，也可以是二进制数据。</p><p>类似Java中：<strong>Map<String,  String/Number>  map</strong></p><p>在Redis内容数据存储结构：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220829195054925.webp" alt="image-20220829195054925">*</p><h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a><strong>常用的命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>set key value</td><td>将key-value缓存redis中</td><td>set name dafei</td></tr><tr><td>get key</td><td>从redis中获取key对应value值</td><td>get name</td></tr><tr><td>incr key</td><td>将key对应value值 + 1</td><td>incr age</td></tr><tr><td>decr key</td><td>将key对应value值-1</td><td>decr age</td></tr><tr><td>setex key seconds value</td><td>将key-value缓存到redis中，seconds 秒后失效</td><td>setex  sex  10  man</td></tr><tr><td>ttl key</td><td>查看key存活时间</td><td>ttl sex</td></tr><tr><td>del  key</td><td>从redis中删除key</td><td>del name</td></tr><tr><td>setnx key value</td><td>如果key已经存，不做任何操作，如果key不存，直接添加</td><td>setnx  name xiaofei</td></tr></tbody></table></div><h3 id="非常用命令"><a href="#非常用命令" class="headerlink" title="非常用命令"></a><strong>非常用命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>incrby key increment</td><td>给key对应值加increment</td><td>incrby age 10</td></tr><tr><td>mset k1 v1 k2 v2….</td><td>批量添加k1v1 k2v2 key value对</td><td>mset name dafei age 18</td></tr><tr><td>mget k1  k2….</td><td>批量获取k1, k2的值</td><td>mget name  age</td></tr><tr><td>append key  value</td><td>在key对应的value值中拼+value</td><td>append name yes</td></tr><tr><td>setrange key  offset  value</td><td>修改key对应的value值,替换为指定value,冲offset索引位置开始</td><td>setrange name 2   xx</td></tr></tbody></table></div><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1&gt;计数器</p><p>如：视频播放数系统就是使用redis作为视频播放数计数的基础组件。</p><p><strong>incr  viewnum 1</strong></p><p>2&gt;共享session</p><p>出于负载均衡的考虑，分布式服务会将用户信息的访问均衡到不同服务器上，用户刷新一次访问可能会需要重新登录，为避免这个问题可以用redis将用户session集中管理，  在这种模式下只要保证redis的高可用和扩展性的，每次获取用户更新或查询登录信息都直接从redis中集中获取。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220831190303396.webp" alt="image-20220831190303396"></p><p><strong>user_login_info:uid——&gt;{“id”:1, “name”:”dafei”, “age”:18}</strong></p><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型是String类型的field和value的映射表，或者说是一个String集合。它特别适合存储对象，相比较而言，将一个对象存储在Hash类型里要比存储在String类型里占用更少的内存空间。</p><p>类似Java中：<strong>Map<String, Map<String, ?>&gt; map</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220831190853799.webp" alt="image-20220831190853799">*</p><h3 id="常用的命令-1"><a href="#常用的命令-1" class="headerlink" title="常用的命令"></a><strong>常用的命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>hset key field  value</td><td>将field  value对缓存到redis中hash中，键值为key</td><td>hset user name dafei</td></tr><tr><td>hget key field</td><td>从key对应hash列表中获取field字段</td><td>hget user  name</td></tr><tr><td>hexists key  field</td><td>判断key对应的hash列表是否存在 field字段</td><td>hexists user age</td></tr><tr><td>hdel key  field</td><td>删除key对应hash列表中field字段</td><td>hdel user age</td></tr><tr><td>hincrby  key  field  increment</td><td>给key对应hash列表中field字段 + increment</td><td>hincrby user  age 10</td></tr><tr><td>hlen key</td><td>查看key对应的hash列表field的数量</td><td>hlen user</td></tr><tr><td>hkeys  key</td><td>获取key对应的hash列表所有的field值</td><td>hkeys  user</td></tr><tr><td>hvals  key</td><td>获取key对应的hash列表所有的field对应的value值</td><td>kvals  user</td></tr><tr><td>hgetall key</td><td>获取key对应的hash列表中所有的field及其对应的value值</td><td>hgetall user</td></tr></tbody></table></div><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>Hash结构相对于字符串序列化缓存信息更加直观，并且在更新操作上更加便捷。</p><p><strong>共享session设计</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String userame;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span>  <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;dafei&quot;</span>, <span class="string">&quot;666&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>登录缓存：</p><p>key：<strong>user_token</strong>                value：<strong>new User(“dafei”, “666”, 18)</strong></p><p>-——————————————————————————————————————————————-</p><p>方案1： 将user对象转换json格式字符串存redis  【侧重于查， 改非常麻烦】</p><p>key                            value</p><p>-——————————————————————————————————————————————</p><p><strong>user_token</strong>   ：   <strong>“{name:dafei, age:18, password:666}”</strong></p><p>方案2： 将user对象转换hash对象存redis【侧重于改，查询相对麻烦】</p><p>key                            value</p><p>-——————————————————————————————————————————————</p><p><strong>user_token</strong>   ：  <strong>{</strong></p><p>​                                    <strong>name：ddafei</strong></p><p>​                                    <strong>age ：    18</strong></p><p>​                                    <strong>password： 666</strong></p><p>​                                 <strong>}</strong></p><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类似Java中的Queue,也可以当做List来用.</p><p>List类型是一个链表结构的集合，其主要功能有push、pop、获取元素等，更详细的说,List类型是一个双端链表的结构，我们可以通过相关操作进行集合的头部或者尾部添加删除元素，List的设计非常简单精巧，即可以作为栈,又可以作为队列，满足绝大多数需求.</p><p>类似Java中：<strong>Map<String, List>  map</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220831194916914.webp" alt="image-20220831194916914">*</p><h3 id="常用的命令-2"><a href="#常用的命令-2" class="headerlink" title="常用的命令"></a><strong>常用的命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>rpush  key  value</td><td>从右边往key集合中添加value值</td><td>rpush hobby java</td></tr><tr><td>lrange key start stop</td><td>从左边开始列表key集合，从start位置开始，stop位置结束</td><td>lrange hobby 0 -1</td></tr><tr><td>lpush key value</td><td>从左边往key集合中添加value值</td><td>lpush hobby c++</td></tr><tr><td>lpop key</td><td>弹出key集合中最左边的数据</td><td>lpop hobby</td></tr><tr><td>rpop key</td><td>弹出key集合中最右边的数据</td><td>rpop hobby</td></tr><tr><td>llen key</td><td>获取列表长度</td><td>llen hooby</td></tr></tbody></table></div><h3 id="非常用命令-1"><a href="#非常用命令-1" class="headerlink" title="非常用命令"></a><strong>非常用命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>linsert key before pivot value</td><td>操作key集合，在pivot值之前插入value</td><td>linsert hobby before java  c#</td></tr><tr><td>linsert key  after  pivot value</td><td>操作key集合，在pivot值之后插入value</td><td>linsert hobby after  java  c#</td></tr><tr><td>lset key  index  value</td><td>操作key集合，更新索引index位置值为value</td><td>lset hobby 1  go</td></tr><tr><td>lrem key count  value</td><td>操作key集合，删除 count个 value值</td><td>lrem hobby 3   go</td></tr><tr><td>ltrim   key  start stop</td><td>操作key集合，从start到stop截取自列表</td><td>ltrim  hobby 2   4</td></tr><tr><td>lindex  key  index</td><td>操作key集合，获取索引为index位置的数据</td><td>lindex  hobby 1</td></tr></tbody></table></div><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>1&gt;用户收藏文章列表：</p><p>key：user_favor_article_list</p><p>value: [aid1, aid2, aid3……]</p><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Set集合是String类型的无序集合,set是通过HashTable实现的，对集合我们可以取<strong>交集、并集、差集。</strong></p><p>类似Java中：<strong>Map<String, Set>  map</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220901191547262.webp" alt="image-20220901191547262">*</p><h3 id="常用的命令-3"><a href="#常用的命令-3" class="headerlink" title="常用的命令"></a><strong>常用的命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>sadd key  members [….]</td><td>往key 集合中添加member元素</td><td>sadd myset a  b  c</td></tr><tr><td>smembers key</td><td>遍历key集合中所有的元素</td><td>smembers myset</td></tr><tr><td>srem  key members [….]</td><td>删除key集合中members元素</td><td>srem myset a</td></tr><tr><td>spop key count</td><td>从key集合中随机弹出count个元素</td><td>spop myset 1</td></tr></tbody></table></div><h3 id="非常用命令-2"><a href="#非常用命令-2" class="headerlink" title="非常用命令"></a><strong>非常用命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td><strong>sdiff key1   key2</strong></td><td><strong>返回key1中特有的元素(差集)</strong></td><td><strong>sdiff key1 key2</strong></td></tr><tr><td>sidiffstore  dest  key1 key2</td><td>返回key1中特有的元素，并将返回值缓存到dest集合中</td><td>sidiffstore  dest  key1 key2</td></tr><tr><td><strong>sinter key1 key2</strong></td><td><strong>返回key1跟key2集合的交集</strong></td><td><strong>sinter key1 key2</strong></td></tr><tr><td>sinterstore  dest key1 key2</td><td>返回key1跟key2集合的交集，并将返回值缓存到dest集合中</td><td>sinterstore  dest key1 key2</td></tr><tr><td><strong>sunion key1  key2</strong></td><td><strong>返回key1跟key2集合的并集</strong></td><td><strong>sunion key1  key2</strong></td></tr><tr><td>sunionstore dest key1  key2</td><td>返回key1跟key2集合的并集，并将返回值缓存到dest集合中</td><td>sunionstore dest key1  key2</td></tr><tr><td>smove source destination member</td><td>将source集合中member元素移动到destination集合中</td><td>smove key1  key2 aa</td></tr><tr><td>sismember key member</td><td>判断member元素是否在key集合中</td><td>sismember key1   aa</td></tr><tr><td>srandmember  key  count</td><td>随机获取set集合中count 个元素</td><td>srandmember key1 1</td></tr></tbody></table></div><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>1，去重；</p><p>2，抽奖;</p><p>​           1：准备一个抽奖池:sadd luckydraw 1 2 3 4 5 6 7 8 9 10 11 12 13</p><p>​           2：抽3个三等奖:spop luckydraw 3</p><p>​           3：抽2个二等奖:spop luckydraw 2</p><p>​           4：抽1个:一等奖:spop luckydraw 1</p><h2 id="Sorted-set-类型"><a href="#Sorted-set-类型" class="headerlink" title="Sorted set 类型"></a>Sorted set 类型</h2><p>Sorted set 也称Zset类型，是一种具有排序效果的set集合。它跟set集合一样也是 string 类型元素的集合，且不允许重复的成员。并且要求每个元素都会关联一个double 类型的分数。后续可以通过分数来为集合中的成员进行从小到大的排序。</p><p>Sorted set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p>数据缓存结构：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220901200221440.webp" alt="image-20220901200221440">*</p><h3 id="常用的命令-4"><a href="#常用的命令-4" class="headerlink" title="常用的命令"></a><strong>常用的命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>zadd key score member</td><td>往key集合中添加member元素，分数为score</td><td>zadd players 100  a</td></tr><tr><td>zincrby  key increment  member</td><td>将key集合中的member元素 分数 + increment</td><td>zadd players 100  a</td></tr><tr><td>zrange  key  start  stop [withscores]</td><td>将key集合中的元素按分数升序排列 [显式分数]</td><td>zrange players 0 -1  withscores</td></tr><tr><td>zrevrange key  start  stop [withscores]</td><td>将key集合中的元素按分数降序排列 [显式分数]</td><td>zrevrange players 0 -1  withscores</td></tr><tr><td>zrank  key  member</td><td>返回member元素在key结合中的正序排名</td><td>zrank players  a</td></tr><tr><td>zrevrank key  member</td><td>返回member元素在key结合中的倒序排名</td><td>zrevrank players  a</td></tr><tr><td>zcard  key</td><td>返回key集合元素个数</td><td>zcard  players</td></tr></tbody></table></div><h3 id="非常用命令-3"><a href="#非常用命令-3" class="headerlink" title="非常用命令"></a><strong>非常用命令</strong></h3><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>zrangebyscore  key  min  max  [withscores]</td><td>按[min, max) 分数范围返回key集合中元素(正序)</td><td>zrangebyscore players  200 300  withscores</td></tr><tr><td>zrevrangebyscore key  min  max  [withscores]</td><td>按[min, max) 分数范围返回key集合中元素(倒序)</td><td>zrevrangebyscore players  200 300  withscores</td></tr><tr><td>zrem key member</td><td>删除key集合中member元素与分数</td><td>zrem players  a</td></tr><tr><td>zremrangebyscore  key min max  withscores</td><td>按[min, max) 分数范围删除key集合中元素</td><td>zremrangebyscore  players  200 300  withscores</td></tr><tr><td>zremrangebyrank  key start  stop</td><td>删除key集合正序排名落在[start, stop) 范围元素</td><td>zremrangebyrank  players  10  20</td></tr><tr><td>zcount key min max</td><td>按照分数范围[min, max]统计key集合中元素个数</td><td>zcount  players  100 300</td></tr></tbody></table></div><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p><h2 id="类型总结"><a href="#类型总结" class="headerlink" title="类型总结"></a>类型总结</h2><p>一个问题，Redis在项目中如何使用？</p><p>思考点：</p><p>1&gt;项目是否需要使用到缓存？使用</p><p>2&gt;使用缓存是否选用Redis？选用</p><p>3&gt;使用Redis那该怎么设计Key-Value值？</p><p>这里重点讨论Redis的KV对的设计。</p><h3 id="Value设计"><a href="#Value设计" class="headerlink" title="Value设计"></a>Value设计</h3><p>先说value值的设计其实就是value类型选用： String， Hash， List， Set， Sort Set</p><p>一般考虑：</p><ul><li>是否需要排序？要使用Sort Set</li><li>缓存的数据是多个值还是单个值，</li><li>多个值：允许重复选List  不允许重复选择Set</li><li>单个值：简单值选择String， 对象值选择Hash</li></ul><p>一种取巧的方式：</p><ul><li>是否需要排序？要使用Sort Set</li><li>剩下使用String</li></ul><p>操作方式：</p><p>所有value之后都转换成json格式字符串，然后缓存到Redis，原因：Java操作方便，减少泛型操作麻烦</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;list = ...</span><br><span class="line">Set&lt;String&gt; set = ....</span><br><span class="line">Map&lt;String, Object&gt; map = ....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;Object&gt;  list = redis对象.getList</span><br><span class="line">Set&lt;Object&gt; set =redis对象.getSet   </span><br><span class="line">Map&lt;Object, Object&gt; map  =  redis对象.getMap</span><br></pre></td></tr></table></figure><p>不管存放啥数据类型，从reds中获取出来都是Object类型，后续对象强制转换麻烦，干脆直接使用字符串。</p><h3 id="Key设计"><a href="#Key设计" class="headerlink" title="Key设计"></a>Key设计</h3><p>Redis 的key 设计讲究4个性：</p><h4 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a><strong>唯一性</strong></h4><p>Redis 类似Map集合，key必须保证唯一，缓存同一个key时，后者会覆盖前者，所有必须要求唯一，那如何保证唯一呢？</p><p>最常用的方式：<strong>使用缓存数据的主键作为key</strong>。</p><p>比如：缓存员工信息</p><p>key                             value</p><p>-———————————————————————————————-</p><p>1                                员工1</p><p>2                                员工2</p><p>其中的1， 2 是员工的id</p><h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a><strong>可读性</strong></h4><p>可读性是保证Redis的key能做到见名知意，上面的员工id1， 员工id2 虽说能保证key唯一，但可读性非常差，维护key时，无法从， 1， 2中快速判断该key对应value值。所以一一般在保证key唯一的前提下，给key加上前缀：</p><p>key                                       value</p><p>-———————————————————————————————-</p><p>employee_info:id1            员工1</p><p>employee_info:id2            员工2</p><p>employee_info:id1     employee_info:id2  这样子设计key，可读性就好多了。</p><p>可读性前缀的设计规范千奇百怪，我个人比较推崇的：</p><ul><li><p>普通单值</p><p>key                                       value</p><p>-———————————————————————————————-</p><p>employe_info:id1              员工对象信息</p></li></ul><ul><li><p>类似关系型数据库设计</p><p><strong>表名:主键名:主键值:列名</strong></p><p>key                                       value</p><p>-———————————————————————————————-</p><p>employee : id : 1:info        员工对象信息</p></li></ul><ul><li><p>通用玩法</p><p><strong>业务模块名:业务逻辑含义:其他:value类型</strong></p><p>key                                                        value</p><p>-———————————————————————————————————</p><p>employee :base.info:id1:hash         员工对象信息</p><p><strong>业务模块名</strong>：表示该key属于哪个功能模块</p><p><strong>业务逻辑含义段</strong>：这里可以使用  <strong>.</strong>  分开， 具体业务逻辑表示</p><p>​    比如：缓存员工权限</p><p>​    employee:auth.permission:id1:set     员工权限集合</p><p><strong>其他</strong>：一般设置唯一标识，比如主键</p><p><strong>value类型</strong>：key对应value类型值，提高可读性。</p></li></ul><h4 id="灵活性—项目二重点讲"><a href="#灵活性—项目二重点讲" class="headerlink" title="灵活性—项目二重点讲"></a><strong>灵活性</strong>—项目二重点讲</h4><p>这个难介绍，一般key保证唯一时，可以使用主键，有的使用，一个主键不能表达出全部意思，可以使用联合主键。</p><p>比如：</p><p>id为1的朋友圈下id为A的评论。</p><p>key                                                        value</p><p>-———————————————————————————————————</p><p>post:1:reply:A                                    评论内容</p><p>post:1:reply:B                                    评论内容</p><h4 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a><strong>时效性</strong></h4><p>Redis key一定要设置过期时间。要跟自己的业务场景，需要对key设置合理的过期时间。可以在写入key时，就要追加过期时间；也可以在按照需要动态设置。</p><p>这里要注意：</p><ul><li>不设置过期时间，这种key为永久key，会一直占用内存不释放，时间久了，数量一多，就容易达到服务器的内存上限，导致宕机，开发时一般配合Key过期策略使用哦。</li><li>key的时效性设置，必须根据业务场景进行评估，设置合理有效期；</li></ul><h1 id="Redis全局命令"><a href="#Redis全局命令" class="headerlink" title="Redis全局命令"></a>Redis全局命令</h1><p>全局命令针对的是所有的key，大部分用来做运维，做管理的</p><p>常用的全局key</p><div class="table-container"><table><thead><tr><th>命令格式</th><th>功能</th><th>案例</th></tr></thead><tbody><tr><td>keys  pattern</td><td>按照pattern 匹配规则，列表redis中所有的key</td><td>keys xxx:*</td></tr><tr><td>exists  key</td><td>判断key是否存在</td><td>exists name</td></tr><tr><td>expire key  seconds</td><td>给key设置过期时间，超时：seconds</td><td>expire name 10</td></tr><tr><td>persist key</td><td>取消key过期时间</td><td>persist  name</td></tr><tr><td>select  index</td><td>切换数据库，默认是第0个，共有【0,15】个</td><td>select 0</td></tr><tr><td>move key   db</td><td>从当前数据库将key移动到指定db库</td><td>move name 1</td></tr><tr><td>randomkey</td><td>随机返回一个key</td><td>randomkey</td></tr><tr><td>rename key newkey</td><td>将key改名为newkey</td><td>rename name  newname</td></tr><tr><td>echo message</td><td>打印message信息</td><td>echo  message</td></tr><tr><td>dbsize</td><td>查看key个数</td><td>dbsize</td></tr><tr><td>info</td><td>查看redis数据库信息</td><td>info</td></tr><tr><td>config get  *</td><td>查看所有redis配置信息</td><td>config get *</td></tr><tr><td>flushdb</td><td>清空当前数据库</td><td>flushdb</td></tr><tr><td>flushall</td><td>清空所有数据库</td><td>flushall</td></tr></tbody></table></div><h1 id="Redis安全性"><a href="#Redis安全性" class="headerlink" title="Redis安全性"></a>Redis安全性</h1><p>因为Redis速度非常快，所以在一台比较好的服务器下,一个外部用户在一秒内可以进行15w次的密码尝试，这意味你需要设定非常强大的密码来方式暴力破解。此时就需要对Redis进行密码设置啦。</p><p><strong>Linux系统</strong></p><p>编辑 redis.conf文件，找到下面进行保存修改<br><strong>requirepass 自定义密码</strong></p><p>重启Redis服务，访问时，使用带密码的命令：</p><p><strong>redis-cli -a 自定义密码</strong></p><p>否则会提示： (error)NOAUTH Authentication required.</p><p>Window系统</p><p>跟Linux系统一样，区别是，window系统的文件是</p><p><strong>redis.window-service.config</strong></p><h1 id="Redis事务-拓展"><a href="#Redis事务-拓展" class="headerlink" title="Redis事务[拓展]"></a>Redis事务[拓展]</h1><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><p>借用：菜鸟教程中例子</p><p>它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag <span class="string">&quot;C++&quot;</span> <span class="string">&quot;Programming&quot;</span> <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) 1) <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">   2) <span class="string">&quot;C++&quot;</span></span><br><span class="line">   3) <span class="string">&quot;Programming&quot;</span></span><br></pre></td></tr></table></figure><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>Redis事务可以理解为一个<strong>打包的批量执行脚本</strong>，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> name dafei</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> age 18</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr age </span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get age</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (<span class="built_in">integer</span>) 19</span><br><span class="line">4) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">5) <span class="string">&quot;19&quot;</span></span><br><span class="line">6) <span class="string">&quot;dafei&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><h1 id="Redis持久化机制-拓展"><a href="#Redis持久化机制-拓展" class="headerlink" title="Redis持久化机制[拓展]"></a>Redis持久化机制[拓展]</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先来一个小实验，大家可以一起实现一下</p><p>步骤1：在Redis中添加2个key-value对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> aa aa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bb bb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br></pre></td></tr></table></figure><p>步骤2：重启Redis 服务器，在执行keys * 观察数据</p><p>步骤3：分析结果</p><p>会出现一下几种结果：</p><ul><li>之前的key在，aa  bb 都在（最理想的结果）</li><li>之前的key在，aa也在，bb不见了</li><li>之前的key在，aa， bb 不在</li><li>之前的key， aa， bb 都不在了（最坏的结果）</li></ul><p>思考：</p><p>为啥会这样？以我们对内存的操作理解，按道理重启之后数据应该全丢失了，为啥Redis 可能丢失，也可能不丢失，为何？</p><p>这里就涉及到Redis的持久化机制了。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220902113153504.webp" alt="image-20220902113153504">*</p><p>Redis持久化机制目前以后3种，分别为：</p><p>1&gt;<strong>快照方式</strong>（RDB, Redis DataBase）</p><p>2&gt;<strong>文件追加方式</strong>（AOF, Append Only File）</p><p>3&gt;<strong>混合持久化方式</strong>（Redis4版本之后）</p><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><p>Snapshotting(快照)默认方式，将内存数据中以快照的方式写入到二进制文件中，默认为dump.rdb。触发RDB持久化过程分手动触发与自动触发。</p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><p><strong>手动触发</strong></p><p>使用save命令：会阻塞当前Redis服务器，知道RDB过程完成为主，如果内存数据较多，会造成长时间阻塞，影响其他命令的使用，不建议轻易使用</p><p>使用bgsave命令：Redis进程执行fork指令创建子进程，由子进程实现RDB持久化，有需要时建议使用bgsave命令。</p><p><strong>自动触发</strong></p><p>使用save相关配置，格式： save m n      表示m秒内数据集存在n次修改时会自动触发bgsave命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>  #<span class="number">900</span>秒内如果超过<span class="number">1</span>个Key被修改则发起快照保存</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span> #<span class="number">300</span>秒内如果超过<span class="number">10</span>个key被修改,则发起快照保存</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220902151151422.webp" alt="image-20220902151151422">*</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>RDB快照文件是一个紧凑压缩的二进制文件，非常使用用于备份，全量复制等场景。开发中可以按照每6小时执行一次bgsave备份，用于容灾备份。</p></li><li><p>Redis加载RDB恢复数据远远快于AOF方式</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>RDB无法做到实时持久化/秒级持久化，每次bgsave时都需要fork子进程，频繁执行有时间成本。</li><li>RDB快照文件不同版本格式不一样，容易引起兼容问题。</li></ul><h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>AOF与RDB不一样，它是一独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。解决了数据持久化的实时性的问题。</p><p>Redis默认是不开启的，需要使用时，需要配置： <strong>appendonly yes</strong></p><p>AOF 有3种文件同步策略</p><div class="table-container"><table><thead><tr><th>策略</th><th>解释</th></tr></thead><tbody><tr><td>appendfsync always</td><td>收到命令就立即写到磁盘,效率最慢.但是能保证完全的持久化</td></tr><tr><td>appendfsync everysec</td><td>每秒写入磁盘一次,在性能和持久化方面做了很好的折中</td></tr><tr><td>appendfsync no</td><td>完全以依赖os，一般同步周期是30秒</td></tr></tbody></table></div><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220902152951385.webp" alt="image-20220902152951385">*</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>AOF方式数据安全性更高，配置得当，最多损失1秒的数据量</li><li><p>在不小心执行flushall命令，也可以通过AOF方式恢复(删除最后一个命令即可)</p></li><li><p>AOF 日志是一个增量日志文件，不会存在断电时出现损坏问题。即使出现问题，redis-check-aof 工具也能够轻松修复它。</p></li><li>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相同数据量来说，AOF文件体积通常大于RDB文件</li><li>数据持久化性能上来说，AOF 比 RDB 慢</li></ul><h2 id="RDB-AOF混合方式"><a href="#RDB-AOF混合方式" class="headerlink" title="RDB-AOF混合方式"></a>RDB-AOF混合方式</h2><p>混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件。即以 RDB 作为全量备份，AOF 作为增量备份，来提高备份效率。这样既能保证 Redis 重启时的速度，又能防止数据丢失的风险， 这就是 Redis 4.0 之后推出的 <strong>RDB-AOF 混合持久化模式，其作为默认配置来使用</strong>。</p><h2 id="持久化机制选择"><a href="#持久化机制选择" class="headerlink" title="持久化机制选择"></a>持久化机制选择</h2><ul><li><p>如果对数据安全性有非常高的要求，建议 RDB 和 AOF 同时启用。</p></li><li><p>如果对数据安全性要求不是很高，能够容忍数据的丢失，建议单独使用 RDB。</p></li><li><p>不推荐单独使用 AOF，因为对于进行数据库备份、更快重启以及 AOF 引擎中出现错误的情况来说，RDB 是更好的选择。</p></li><li><p>如果没特殊要求，Redis又是4.x版本以上，可以选择RDB-AOF混合方式。</p></li></ul><p>如果不是混合模式，而是普通的RDB与AOF一起启动时，Redis加载数据执行流程</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220902153031549.webp" alt="image-20220902153031549">*</p><h1 id="Redis内存淘汰机制-拓展"><a href="#Redis内存淘汰机制-拓展" class="headerlink" title="Redis内存淘汰机制[拓展]"></a>Redis内存淘汰机制[拓展]</h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><p>Redis 启动会加载一个配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory &lt;byte&gt;   //内存上限</span><br></pre></td></tr></table></figure><p>默认值为 0 (window版的限制为100M)，表示默认设置Redis内存上限。但是真实开发还是需要提前评估key的体量，提前设置好内容上限。</p><p>此时思考一个问题，开发中，在设置完内存上限之后，如果Redis key达到上限了，该怎么办？这就设置到Redis的内存淘汰机制了。</p><h2 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h2><p>Redis内存淘汰机制也可以称之为key内卷机制，当资源不足时，该如何选择？</p><p>常见的内存淘汰机制分为四大类：</p><ul><li><strong>LRU：</strong>LRU是Least recently used，最近最少使用的意思，简单的理解就是从数据库中删除最近最少访问的数据，该算法认为，你长期不用的数据，那么被再次访问的概率也就很小了，淘汰的数据为最长时间没有被使用，仅与时间相关。</li></ul><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220902161050652.webp" alt="image-20220902161050652"></p><ul><li><p><strong>LFU：</strong>LFU是Least Frequently Used，最不经常使用的意思，简单的理解就是淘汰一段时间内，使用次数最少的数据，这个与频次和时间相关。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220902161057116.webp" alt="image-20220902161057116"></p></li><li><p><strong>TTL：</strong>Redis中，有的数据是设置了过期时间的，而设置了过期时间的这部分数据，就是该算法要解决的对象。如果你快过期了，不好意思，我内存现在不够了，反正你也要退休了，提前送你一程，把你干掉吧。</p></li><li><p>随机淘汰：生死有命，富贵在天，是否被干掉，全凭天意了。</p></li></ul><h2 id="Redis淘汰策略"><a href="#Redis淘汰策略" class="headerlink" title="Redis淘汰策略"></a>Redis淘汰策略</h2><p>Redis 通过配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemroy-policy  </span><br></pre></td></tr></table></figure><p>来配置指定具体的淘汰机制，可供选择的值有：</p><p>　通过maxmemroy-policy可以配置具体的淘汰机制，看了网上很多文章说只有6种，其实有8种，可以看Redis5.0的配置文件，上面有说明：</p><ul><li>volatile-lru -&gt; 找出已经设置过期时间的数据集，将最近最少使用（被访问到）的数据干掉。</li><li>volatile-ttl -&gt; 找出已经设置过期时间的数据集，将即将过期的数据干掉。</li><li>volatile-random -&gt; 找出已经设置过期时间的数据集，进行无差别攻击，随机干掉数据。</li><li>volatile-lfu -&gt; 找出已经设置过期时间的数据集，将一段时间内，使用次数最少的数据干掉。</li></ul><ul><li>allkeys-lru -&gt;与第1个差不多，数据集从设置过期时间数据变为全体数据。</li><li>allkeys-lfu -&gt; 与第4个差不多，数据集从设置过期时间数据变为全体数据。</li><li>allkeys-random -&gt; 与第3个差不多，数据集从设置过期时间数据变为全体数据。</li></ul><ul><li>no-enviction -&gt; 什么都不干，报错，告诉你内存不足，这样的好处是可以保证数据不丢失</li></ul><p><strong>系统默认选择： noenviction</strong> </p><h1 id="过期Key处理-拓展"><a href="#过期Key处理-拓展" class="headerlink" title="过期Key处理[拓展]"></a>过期Key处理[拓展]</h1><p>接下讨论一个问题：Redis的key过期了，该如何清理问题。</p><p>Redis给出3种实现方案：</p><p><strong>惰性删除</strong>：当访问Key时，才去判断它是否过期，如果过期，直接干掉。这种方式对CPU很友好，但是一个key如果长期不用，一直存在内存里，会造成内存浪费。</p><p><strong>定时删除</strong>：设置键的过期时间的同时，创建一个定时器，当到达过期时间点，立即执行对Key的删除操作，这种方式对CPU不友好，得额外让出CPU维护定时器。</p><p><strong>定期删除</strong>：隔一段时间，对数据进行一次检查，删除里面的过期Key，至于要删除多少过期Key，检查多少数据，则由算法决定。</p><p><strong>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，可以很好地在合理使用CPU和避免浪费内存之间取得平衡。</strong></p><h1 id="Redis编程"><a href="#Redis编程" class="headerlink" title="Redis编程"></a>Redis编程</h1><h2 id="概况-1"><a href="#概况-1" class="headerlink" title="概况"></a>概况</h2><p>Redis编程就是使用编程方式操作Redis，当前Redis支持的编程语言有：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220716145405471.webp" alt="image-20220716145405471"></p><p>这里以Java为开发语言，选择Java点击进去</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220716145807103.webp" alt="image-20220716145807103"></p><p>java实现操作Redis的客户端有很多，其中名气最高的：<strong>Redisson</strong>，<strong>Jedis</strong>，<strong>lettuce</strong> 3个客户端，其中Jedis，lettuce侧重于单例Redis 数据库的 CRUD（增删改查），Redisson 侧重于分布式开发。当前重点讲解Jedis与lettuce的使用，后续有机会再重点讲解Redisson使用。</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>项目使用的SpringBoot，所以重点讲解SpringBoot继承Jedis</p><p><strong>步骤1：建项目，导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2：导入配置文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#redis配置--jedis版</span></span><br><span class="line"><span class="attr">jedis:</span></span><br><span class="line">  <span class="attr">pool:</span></span><br><span class="line">    <span class="comment">#redis服务器的IP</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment">#redis服务器的Port</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#数据库密码</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="comment">#连接超时时间</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">7200</span></span><br><span class="line">    <span class="comment">#最大活动对象数</span></span><br><span class="line">    <span class="attr">maxTotall:</span> <span class="number">100</span></span><br><span class="line">    <span class="comment">#最大能够保持idel状态的对象数</span></span><br><span class="line">    <span class="attr">maxIdle:</span> <span class="number">100</span></span><br><span class="line">    <span class="comment">#最小能够保持idel状态的对象数</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">50</span></span><br><span class="line">    <span class="comment">#当池内没有返回对象时，最大等待时间</span></span><br><span class="line">    <span class="attr">maxWaitMillis:</span> <span class="number">10000</span></span><br><span class="line">    <span class="comment">#当调用borrow Object方法时，是否进行有效性检查</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#当调用return Object方法时，是否进行有效性检查</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1.</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">30000</span></span><br><span class="line">    <span class="comment">#向调用者输出“链接”对象时，是否检测它的空闲超时；</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3.</span></span><br><span class="line">    <span class="attr">numTestsPerEvictionRun:</span> <span class="number">50</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤3：加载配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jedis.pool&quot;)</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  maxTotall;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  maxIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  minIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  maxWaitMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>  testOnBorrow;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>  testOnReturn;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  timeBetweenEvictionRunsMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>  testWhileIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  numTestsPerEvictionRun;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤4：编写Jedis配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jedis连接池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedisProperties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JedisPool <span class="title function_">jedisPool</span><span class="params">(JedisProperties jedisProperties)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        config.setMaxTotal(jedisProperties.getMaxTotall());</span><br><span class="line">        config.setMaxIdle(jedisProperties.getMaxIdle());</span><br><span class="line">        config.setMinIdle(jedisProperties.getMinIdle());</span><br><span class="line">        config.setMaxWait(Duration.ofMillis(jedisProperties.getMaxWaitMillis()));</span><br><span class="line">        config.setTestOnBorrow(jedisProperties.isTestOnBorrow());</span><br><span class="line">        config.setTestOnReturn(jedisProperties.isTestOnReturn());</span><br><span class="line">        config.setTimeBetweenEvictionRuns(Duration.ofMillis(jedisProperties.getTimeBetweenEvictionRunsMillis()));</span><br><span class="line">        config.setTestWhileIdle(jedisProperties.isTestWhileIdle());</span><br><span class="line">        config.setNumTestsPerEvictionRun(jedisProperties.getNumTestsPerEvictionRun());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(jedisProperties.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, jedisProperties.getHost(), jedisProperties.getPort(),</span><br><span class="line">                    jedisProperties.getTimeout(), jedisProperties.getPassword());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, jedisProperties.getHost(), jedisProperties.getPort(),</span><br><span class="line">                jedisProperties.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤5：编写测试类，实现测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(jedisPool);</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();</span><br><span class="line">        <span class="comment">//需求：往redis中添加kv对： name：dafei</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;dafei&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作技巧：jedis中方法跟Redis中命令一样</strong></p><h2 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h2><p>Lettuce 之所以能流行，因为它抱了根好大腿-Spring-data。Spring-data-redis底层就封装了Lettuce，接下来看下Springboot版的lettuce实现。</p><p><strong>步骤1：导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>步骤2：Redis配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><p><strong>步骤3：编写测试类，实现测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LettureTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//约定：</span></span><br><span class="line">    <span class="comment">// 操作redis的key  是字符串</span></span><br><span class="line">    <span class="comment">// value是字符串类型或字符串类型元素</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//name：dafei</span></span><br><span class="line">        template.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;dafei&quot;</span>);</span><br><span class="line">        System.out.println(template.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作string</span></span><br><span class="line">        <span class="comment">//template.opsForValue().xx();</span></span><br><span class="line">        <span class="comment">// 操作hash</span></span><br><span class="line">        <span class="comment">//template.opsForHash().xx();</span></span><br><span class="line">        <span class="comment">// 操作list</span></span><br><span class="line">        <span class="comment">//template.opsForList().xx();</span></span><br><span class="line">        <span class="comment">// 操作set</span></span><br><span class="line">        <span class="comment">//template.opsForSet().xx();</span></span><br><span class="line">        <span class="comment">// 操作zset</span></span><br><span class="line">        <span class="comment">//template.opsForZSet().xx();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//spring-data-redis  方法是redis 命令全称</span></span><br><span class="line">        <span class="comment">//template.opsForList().rightPush()  //rpush</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//全局命令在template类上</span></span><br><span class="line">        <span class="comment">//template.keys(&quot;*&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>操作技巧：Lettuce中方法跟Redis中命令全称</strong></p><h1 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h1><p>类似效果：<a href="https://www.mafengwo.cn/gonglve/ziyouxing/2339.html">https://www.mafengwo.cn/gonglve/ziyouxing/2339.html</a></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20220902213752150.webp" alt="image-20220902213752150">*</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库】数据库杂记(一)之JDBC</title>
      <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%82%E8%AE%B0(%E4%B8%80)%E4%B9%8BJDBC/"/>
      <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%82%E8%AE%B0(%E4%B8%80)%E4%B9%8BJDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库杂记-一-之JDBC"><a href="#数据库杂记-一-之JDBC" class="headerlink" title="数据库杂记(一)之JDBC"></a>数据库杂记(一)之JDBC</h1><h2 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1. JDBC"></a>1. JDBC</h2><h3 id="1-1-JDBC-QuickStart"><a href="#1-1-JDBC-QuickStart" class="headerlink" title="1.1 JDBC QuickStart"></a>1.1 JDBC QuickStart</h3><p>使用JDBC操作数据库的步骤</p><ol><li>注册驱动</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure><ol><li>获取连接</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password)</span><br></pre></td></tr></table></figure><ol><li>定义SQL语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update...&quot;</span>;</span><br></pre></td></tr></table></figure><ol><li>获取执行SQL对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure><ol><li>执行SQL</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure><ol><li>处理返回结果</li><li>释放资源</li></ol><h3 id="1-2-JDBC-API"><a href="#1-2-JDBC-API" class="headerlink" title="1.2 JDBC API"></a>1.2 JDBC API</h3><h4 id="1-2-1-DriverManage-驱动管理类-作用"><a href="#1-2-1-DriverManage-驱动管理类-作用" class="headerlink" title="1.2.1 DriverManage(驱动管理类)作用:"></a>1.2.1 DriverManage(驱动管理类)作用:</h4><ul><li>注册驱动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 注册驱动</span></span><br><span class="line"><span class="comment">//在加载类的时候会调用静态方法 </span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line"><span class="comment">// 向 DriverManager 注册给定驱动程序。新加载的驱动程序类应该调用 registerDriver 方法让 DriverManager 知道自己。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(Driver driver)</span> </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>获取数据库链接<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 获取数据库连接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/sql_store?useUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;2154477&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-2-Connection-数据库连接对象-作用"><a href="#1-2-2-Connection-数据库连接对象-作用" class="headerlink" title="1.2.2 Connection(数据库连接对象)作用"></a>1.2.2 Connection(数据库连接对象)作用</h4><ul><li>获取执行SQL的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取执行SQL的对象</span></span><br><span class="line"><span class="comment">// 普通执行SQL对象</span></span><br><span class="line">Statement <span class="title function_">createStatement</span><span class="params">()</span></span><br><span class="line"><span class="comment">//预编译SQL的执行SQL对象:防止SQL注入</span></span><br><span class="line">PreparedStatement <span class="title function_">preparedStatement</span><span class="params">(sql)</span></span><br><span class="line"><span class="comment">//执行存储过程的对象</span></span><br><span class="line">CallableStatement <span class="title function_">prepareCall</span><span class="params">(sql)</span></span><br></pre></td></tr></table></figure><ul><li>事务管理</li></ul><p>MySQL事务管理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启事务:<span class="keyword">BEGIN</span>;</span><br><span class="line">提交事务:<span class="keyword">COMMIT</span>;</span><br><span class="line">回滚事务:<span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line">MySQL默认自动提交事务</span><br></pre></td></tr></table></figure><p>JDBC事务管理:Connection 接口中定义了3个对应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启事务:setAutoCommit(<span class="type">boolean</span> autoCommit);<span class="literal">true</span> 为自动提交事务;<span class="literal">false</span>为手动提交事务</span><br><span class="line">提交事务:commit();</span><br><span class="line">回滚事务:rollback();</span><br></pre></td></tr></table></figure><p>样例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line">        <span class="comment">//2. 获取连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/sql_store?useUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;2154477&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;UPDATE shippers_copy SET name = &#x27;a&#x27; WHERE shipper_id = 5&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;UPDATE shippers_copy SET name = &#x27;b&#x27; WHERE shipper_id = 4&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 获取执行sql的对象</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//5. 执行sql,返回受影响的行数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> stmt.executeUpdate(sql1);</span><br><span class="line">            <span class="comment">//6. 处理结果</span></span><br><span class="line">            System.out.println(cnt1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//int i = 3/0;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//5. 执行sql,返回受影响的行数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> stmt.executeUpdate(sql2);</span><br><span class="line">            <span class="comment">//6. 处理结果</span></span><br><span class="line">            System.out.println(cnt2);</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception throwables) &#123;</span><br><span class="line">            <span class="comment">//回滚事务</span></span><br><span class="line">            conn.rollback();</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-Statement-作用"><a href="#1-2-3-Statement-作用" class="headerlink" title="1.2.3 Statement 作用"></a>1.2.3 Statement 作用</h4><p>执行SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(sql)</span>:执行DML、DDL语句</span><br><span class="line">    返回值:(<span class="number">1</span>)DML语句影响的行数 (<span class="number">2</span>)DDL语句执行后，执行成功也可能返回<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">(sql)</span>:执行DQL语句</span><br><span class="line">    返回值:ResultSet结果集对象</span><br></pre></td></tr></table></figure><h4 id="1-2-4-ResultSet-结果集对象"><a href="#1-2-4-ResultSet-结果集对象" class="headerlink" title="1.2.4 ResultSet(结果集对象)"></a>1.2.4 ResultSet(结果集对象)</h4><p>封装了DQL查询语句的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet stmt.executeQuery(sql):执行DQL语句，返回ResultSet对象</span><br></pre></td></tr></table></figure><p>获取查询结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">    (<span class="number">1</span>)将光标从当前位置向前移动一行，默认初始指向数据行的上一行</span><br><span class="line">    (<span class="number">2</span>)判断当前行是否为有效行</span><br><span class="line">    返回值:<span class="literal">true</span> 有效行 <span class="literal">false</span> 无效行</span><br><span class="line">        </span><br><span class="line">xxx <span class="title function_">getXxx</span><span class="params">(参数)</span>:获取数据</span><br><span class="line">        xxx:数据类型:<span class="type">int</span> <span class="title function_">getInt</span><span class="params">(参数)</span>;String <span class="title function_">getString</span><span class="params">(参数)</span></span><br><span class="line">        参数:<span class="type">int</span> :列的编号，从<span class="number">1</span>开始</span><br><span class="line">            String :列的名称</span><br></pre></td></tr></table></figure><p>样例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取数据库连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/learn_jdbc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;100228&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义Sql语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * from user;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取执行SQL的对象statement</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行sql语句,获的res对象</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.处理结果，遍历res中的所有数据</span></span><br><span class="line">    <span class="comment">//5.1光标下移一行，并判断当前行是否有效</span></span><br><span class="line">    <span class="keyword">while</span> (res.next())&#123;</span><br><span class="line">        <span class="comment">//5.2获取数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> res.getInt(<span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> res.getString(<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> res.getInt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(id);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.释放资源</span></span><br><span class="line">    res.close();</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-5-PreparedStatement"><a href="#1-2-5-PreparedStatement" class="headerlink" title="1.2.5 PreparedStatement"></a>1.2.5 PreparedStatement</h4><p>预编译SQL语句并执行，预防SQL注入问题</p><p>SQL注入DEMO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin_Inject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line">        <span class="comment">//2. 获取连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db1?useUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;2154477&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收用户输入 用户名和密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;szhgfewbhf&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        System.out.println(sql);</span><br><span class="line"><span class="comment">//select * from tb_user where username = &#x27;szhgfewbhf&#x27; and password = &#x27;&#x27; or &#x27;1&#x27; = &#x27;1&#x27;</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断登录是否成功,如果拿到数据就登陆成功</span></span><br><span class="line">        <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Login Success!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Login failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7. 释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取PreparedStatement对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SQL语句中的参数值,使用?占位符代替</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><p>PreparedStatement是将特殊字符进行了转义，转义的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;szhgfewbhf&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;\&#x27;</span><span class="keyword">or</span> \<span class="string">&#x27;1\&#x27;</span> <span class="operator">=</span> \<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>设置参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement对象: setXxx(参数<span class="number">1</span>,参数<span class="number">2</span>):给?赋值</span><br><span class="line">    Xxx:数据类型;如setInt(参数<span class="number">1</span>,参数<span class="number">2</span>)</span><br><span class="line">    参数:</span><br><span class="line">参数<span class="number">1</span>:?的位置编号,从<span class="number">1</span>开始</span><br><span class="line">        参数<span class="number">2</span>:?的值</span><br></pre></td></tr></table></figure><p>执行SQL不需要再传递sql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executeUpdate();</span><br><span class="line">executeQuery();</span><br></pre></td></tr></table></figure><h4 id="1-2-6-PreparedStatement简要原理"><a href="#1-2-6-PreparedStatement简要原理" class="headerlink" title="1.2.6 PreparedStatement简要原理"></a>1.2.6 PreparedStatement简要原理</h4><p>PreparedStatement 好处：</p><ul><li>预编译SQL，性能更高</li><li>防止SQL注入：==将敏感字符进行转义==</li></ul><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210725195756848.webp" alt=""></p><p>Java代码操作数据库流程如图所示：</p><ul><li><p>将sql语句发送到MySQL服务器端</p></li><li><p>MySQL服务端会对sql语句进行如下操作</p><ul><li><p>检查SQL语句</p><p>检查SQL语句的语法是否正确。</p></li><li><p>编译SQL语句。将SQL语句编译成可执行的函数。</p><p>检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。</p></li><li><p>执行SQL语句</p></li></ul></li><li><p>开启预编译功能</p><p>在代码中编写url时需要加上以下参数。而我们之前根本就没有开启预编译功能，只是解决了SQL注入漏洞。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useServerPrepStmts<span class="operator">=</span><span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * PreparedStatement原理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPreparedStatement2</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="comment">// useServerPrepStmts=true 参数开启预编译功能</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收用户输入 用户名和密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义sql</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取pstmt对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 设置？的值</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>,name);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>,pwd);</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    rs = pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置？的值</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>,<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    rs = pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断登录是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功~&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录失败~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-数据库连接池"><a href="#1-3-数据库连接池" class="headerlink" title="1.3 数据库连接池"></a>1.3 数据库连接池</h3><h4 id="1-3-1-数据库连接池简介"><a href="#1-3-1-数据库连接池简介" class="headerlink" title="1.3.1  数据库连接池简介"></a>1.3.1  数据库连接池简介</h4><blockquote><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul></blockquote><p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。</p><p>而数据库使用了数据库连接池后，就能达到Connection对象的复用，如下图</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210725210432985.webp" alt="image-20210725210432985" style="zoom:80%;" /></p><p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p><h4 id="1-3-2-数据库连接池实现"><a href="#1-3-2-数据库连接池实现" class="headerlink" title="1.3.2  数据库连接池实现"></a>1.3.2  数据库连接池实现</h4><ul><li><p>标准接口：==DataSource==</p><p>官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection <span class="title function_">getConnection</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>那么以后就不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</p></li><li><p>常见的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul><p>我们现在使用更多的是Druid，它的性能比其他两个会好一些。</p></li><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><p>一般通过创建配置文件来保存数据库连接池的初始化参数,创建druid.properties<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/db1?useServerPrepStmts=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;userSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">2154477</span></span><br><span class="line"><span class="comment"># 初始化连接数量</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 最大等待时间</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure></p><p>样例demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 导入jar包</span></span><br><span class="line">    <span class="comment">//2. 定义配置文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 加载配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//4. 获取连接池对象</span></span><br><span class="line"></span><br><span class="line">    prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\main\\resources\\druid.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">    <span class="comment">//5. 获取数据库连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">    System.out.println(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【高光谱】如何科学地利用高光谱图像合成对应的RGB图像?</title>
      <link href="/2023/05/19/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E5%88%A9%E7%94%A8%E9%AB%98%E5%85%89%E8%B0%B1%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90%E5%AF%B9%E5%BA%94%E7%9A%84RGB%E5%9B%BE%E5%83%8F/"/>
      <url>/2023/05/19/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E5%88%A9%E7%94%A8%E9%AB%98%E5%85%89%E8%B0%B1%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90%E5%AF%B9%E5%BA%94%E7%9A%84RGB%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="如何科学地利用高光谱图像合成对应的RGB图像"><a href="#如何科学地利用高光谱图像合成对应的RGB图像" class="headerlink" title="如何科学地利用高光谱图像合成对应的RGB图像?"></a>如何科学地利用高光谱图像合成对应的RGB图像?</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>参考链接:</p><p><a href="https://www.zhihu.com/question/265276755">色匹配函数是什么？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/84891237">23. 颜色知识1-人类的视觉系统与颜色 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/24214731">色彩空间基础 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/24281841">色彩空间表示与转换 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/freshair_cnblog/p/11493706.html">CIE XYZ - freshair_cn - 博客园 (cnblogs.com)</a></p><p><a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">CIE 1931 color space - Wikipedia</a></p><p><a href="https://zh.wikipedia.org/wiki/CIE_1931色彩空间">CIE 1931色彩空间 - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p><a href="http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">RGB/XYZ Matrices (brucelindbloom.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/37800433">调色名词浅析——Gamma（伽玛）校正 - 知乎 (zhihu.com)</a></p><p>前置条件：</p><ul><li>必须有高光谱图像</li><li>必须有波段信息，(你需要知道高光谱图像每个通道对应的波长是多少)</li></ul><p>对于波段信息，我的波段信息是从软件ENVI中获取的txt文件<br>本文以128波段的高光谱图像为例，txt文件详细内容在文末给出</p><p>先上流程图，随后再逐一解释：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/%E6%B5%81%E7%A8%8B%E5%9B%BE.svg" style="zoom:200%;" /></p><h2 id="2-计算色匹配函数"><a href="#2-计算色匹配函数" class="headerlink" title="2. 计算色匹配函数"></a>2. 计算色匹配函数</h2><p>色匹配函数其实就是如下三条曲线(使用python手动绘制):</p><p>CIE-XYZ色匹配函数曲线如下:</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/xyz_cmf.svg" alt=""></p><h3 id="2-1-什么是色匹配函数"><a href="#2-1-什么是色匹配函数" class="headerlink" title="2.1 什么是色匹配函数"></a>2.1 什么是色匹配函数</h3><p>追根溯源的话，得从我们人类的视网膜说起。大部分人类的视网膜上有三种感知颜色的感光细胞，叫做视锥细胞，分别对不同波长的光线敏感，称为 L/M/S 型细胞。三种视锥细胞最敏感的波长分别是橙红色（长波，Long），绿色（中波，Medium），蓝色（短波，Short）。这三种视锥细胞的归一化感光曲线如下图所示</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/v2-217757e4c4dc1c63956cb2f2cfdab9f8_720w.webp" alt="img"></p><p>不仅如此，人类眼睛对不同颜色光线混合的反应还是 <strong>线性</strong> 的。根据 <a href="https://en.wikipedia.org/wiki/Grassmann&#39;s_law_(optics">格拉斯曼定律（Grassmann’s Law）</a>)，两束不同颜色的光$C_1$和 $C_2$，假设某个视锥细胞对他们的反应分别是 $r_1$ 和 $r_2$，现在将他们按照一个比例混合，得到第三种颜色 $C_3=\alpha C_1 + \beta C_2$，那么视锥细胞对这个混合颜色的反应也将是前两个反应的线性叠加 $r_3=\alpha r_1 + \beta r_2$。</p><p>格拉斯曼定律是一个实验规律，并没有物理或者生物学上的依据。然而这个规律大大简化了我们对人类彩色视觉系统的建模，并且给我们使用线性代数理论分析人类彩色视觉系统提供了一个前提和基础。</p><p>前面已经提到，人类视网膜上有三种感知色彩的视锥细胞，所以理论上我们用三种颜色的光就可以混合出自然界中任何一种颜色来。在 20 世纪 20 年代，David Wright 和 John Guild 各自独立地领导了一些实验，通过三种颜色的光源进行匹配，得到了人眼对于不同颜色光的匹配函数。此后，多名科学家多次进行了类似的实验，加深了我们对人类彩色视觉的认识。</p><p>实验过程大致是这样的，把一个屏幕用不透光的挡板分割成两个区域，左边照射某个被测试的颜色的光线，这里记为$C$（以下用大写字母表明颜色，用小写字母表明分量大小），右边同时用三种颜色的光同时照射，这里记为$R$，$G$，$B$。然后，调节右边三种颜色光源的强度，直到左右两边的颜色看上去一样为止。假设这个时候三种颜色的光源强度分别为$r$，$g$，$b$，那么根据光色叠加的线性性质，我们可以写出</p><script type="math/tex; mode=display">C = rR + gG + bB</script><p>也就是说，只要按照 (r,g,b) 的分量来混合 (R,G,B) 三种颜色的光，就可以得到 C 这个颜色的光。于是在这一系列实验里，科学家们把左边的颜色按着光谱顺序，挨个测试了一遍，得到了纯光谱色的混合叠加的数据，这就是 <a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">色匹配函数（Color Matching Function）</a> ，并且在这个基准下定义的色彩空间，就是 CIE RGB 色彩空间。下图是 CIE RGB 的色匹配函数曲线，（图片数据来自<a href="http://cvrl.ioo.ucl.ac.uk/">CVRL main (ucl.ac.uk)</a>）。浅色的细线代表实验中不同参与者个人的色匹配函数曲线，中间深色的粗线代表数据的平均值。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/v2-cff378c686cc8b62190b52ff3bd3c41c_720w.webp" alt="img"></p><p>可以看到，曲线上出现了负数，这是怎么回事？回想一下前面描述的实验过程，左边是被测试的光色，右边是可调节的三色光的混合。如果碰到一种情况，右边三色光无论如何调节比例，都不能混合出左边的颜色，比如某种颜色的光强度已经减小为 0 了，然而看趋势还需要继续减小才能与左边的光色相匹配，怎么办？这时候需要往左边的光色中混入三色光中的一种或者几种，继续调节，直到两边的颜色匹配。在左边（被测试）的色光中添加，那就是相当于在右边的混合光中减去，这就导致了色匹配函数曲线上出现了负数。实际上，这相当于就是光线的「减法」了。</p><p>比如，对于 555nm 的黄色光，色匹配函数的值是 (1.30, 0.97, -0.01)，意味着将 1.30 份的红光与 0.97 份的绿光混合放在右边，左边放上 1 份的 555nm 的黄光，以及 0.01 份的蓝光，这样左右两边的光色看上去就一样了。</p><p>因为有部分出现了负数，在使用和计算上都有不方便，因此就对这个匹配函数进行了一下线性变换，变换到一个所有分量都是正的空间中。变换后的色彩空间就是 CIE XYZ 色彩空间。 （图片数据来自<a href="http://cvrl.ioo.ucl.ac.uk/">CVRL main (ucl.ac.uk)</a>）</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/v2-f14f4f1abe2b6192c7104baa1bbf046f_720w.webp" alt="img"></p><p>CIE RGB 色彩空间和 CIE XYZ 色彩空间是完全等价的，两者只是差了一个线性变换。由于允许「减法」的存在，因此 CIE RGB 空间是能够表示所有颜色的；同样的，CIE XYZ 空间也能。</p><p>在计算机问世之前，计算带有负值乘法的曲线是很麻烦的；XYZ就是为了把RGB空间转换成另一个没有负值的、方便计算的空间。很明显，XYZ的三色刺激值是想象出来的。</p><p>XYZ不用于描述颜色，而用于说明光波如何组合会产生什么样的颜色，因此XYZ是独立于设备的。</p><p>对于某些计算任务来说，查表可能变得不切实际。CIE XYZ颜色匹配函数可以通过高斯函数的和来近似。</p><p>设$g(x)$表示分段高斯函数，定义如下:</p><script type="math/tex; mode=display">g(x;\mu,\sigma_1,\sigma_2) = \begin{cases}exp(-\frac{1}{2}(x-\mu)^2/\sigma_1^2)&, {x<\mu}\\exp(-\frac{1}{2}(x-\mu)^2/\sigma_2^2)&, {x<\mu}\end{cases}</script><p>也就是说，$g(x)$类似于钟形曲线，其峰值在$x=μ$处，$σ1$的扩散/标准偏差在平均值的左侧，$σ2$的扩散在平均值右侧。使用以纳米为单位测量的波长$λ$，我们可以近似1931色匹配函数：</p><script type="math/tex; mode=display">\begin{aligned}{\overline {x}}(\lambda )&=1.056g(\lambda ;599.8,37.9,31.0)+0.362g(\lambda ;442.0,16.0,26.7)\\[2mu]&\quad -0.065g(\lambda ;501.1,20.4,26.2),\\[5mu]{\overline {y}}(\lambda )&=0.821g(\lambda ;568.8,46.9,40.5)+0.286g(\lambda ;530.9,16.3,31.1),\\[5mu]{\overline {z}}(\lambda )&=1.217g(\lambda ;437.0,11.8,36.0)+0.681g(\lambda ;459.0,26.0,13.8).\end{aligned}</script><p>以上数据来自维基百科:<a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">CIE 1931 color space - Wikipedia</a></p><h2 id="3-根据光谱数据计算XYZ空间值"><a href="#3-根据光谱数据计算XYZ空间值" class="headerlink" title="3. 根据光谱数据计算XYZ空间值"></a>3. 根据光谱数据计算XYZ空间值</h2><p>给定这些缩放了颜色匹配函数，带有频谱功率分布$I(\lambda)$的一个颜色的RGB 三色刺激值给出为：</p><script type="math/tex; mode=display">R= \int_0^\infty I(\lambda)\,\overline{r}(\lambda)\,d\lambda \\G= \int_0^\infty I(\lambda)\,\overline{g}(\lambda)\,d\lambda \\B= \int_0^\infty I(\lambda)\,\overline{b}(\lambda)\,d\lambda</script><p>实际上计算时多采用XYZ色彩空间，故对频谱分布函数积分时一般使用如下公式:</p><script type="math/tex; mode=display">X= \int_0^\infty I(\lambda)\,\overline{x}(\lambda)\,d\lambda \\Y= \int_0^\infty I(\lambda)\,\overline{y}(\lambda)\,d\lambda \\Z= \int_0^\infty I(\lambda)\,\overline{z}(\lambda)\,d\lambda</script><p>其中$\lambda$代表波长，$I(\lambda)$对应了该波段下的能量强度值(其实就是灰度值) 。</p><p>$\overline{x}(\lambda),\overline{y}(\lambda),\overline{z}(\lambda)$ 分别代表了刚才说的色匹配函数。</p><h2 id="4-将XYZ色彩空间变换到RGB色彩空间"><a href="#4-将XYZ色彩空间变换到RGB色彩空间" class="headerlink" title="4. 将XYZ色彩空间变换到RGB色彩空间"></a>4. 将XYZ色彩空间变换到RGB色彩空间</h2><p>由于 CIE RGB 和 CIE XYZ 两者其实是同一个线性空间的不同表达，因此两者的转换可以通过转换矩阵实现。</p><p>由于 CIE XYZ 空间是一个很方便的线性空间，与具体设备无关，因此常用来做各种颜色空间转换的中间媒介。设想某个颜色的光，经过色匹配函数的计算，得到了三个 XYZ 的值，如果直接将这三个值作为 RGB 颜色显示到屏幕上，显然是不对的。我们必须把 XYZ 的值转换到屏幕的 RGB 空间中的值。</p><script type="math/tex; mode=display">\begin{bmatrix}R_{lin}\\G_{lin}\\B_{lin}\end{bmatrix} = M\begin{bmatrix}X\\Y\\Z\end{bmatrix}</script><p>由于不同的显示效果的需求，存在不同RGB色彩空间。不同的RGB色彩空间色域存在差异。</p><p>不同RGB色彩空间的转换矩阵在如下链接中可以找到:</p><p><a href="http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">RGB/XYZ Matrices (brucelindbloom.com)</a></p><p>因为白色参考点相关的内容确实还没有搞懂，但是对于本文要实现的目标不影响，所以挑选不同的转换矩阵尝试就好了，本文使用D50白色参考点，sRGB色域:</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/transfer_matrix.png" alt=""></p><h2 id="5-伽马校正"><a href="#5-伽马校正" class="headerlink" title="5. 伽马校正"></a>5. 伽马校正</h2><p>在转换完之后，我们只是得到了一个线性的 RGB 值，要被显示器正确显示的话，还需要进行 gamma 校正。每个 RGB 空间对应的 gamma 校正公式不完全一致，大多数情况下都是 $C=C_{lin}^{1/\gamma}$，其中 $γ=2.2$，少数情况，比如 Apple RGB 采用的是 $γ=1.8 $的情况，再比如上面选择的 sRGB 空间，采用了一种分段的非线性函数进行校正：</p><script type="math/tex; mode=display">C = \begin{cases}12.92C_{lin} &,C_{lin} \leq 0.0031308 \\1.055C_{lin}^{1/2.4} - 0.055 &,C_{lin} \gt 0.0031308\end{cases}</script><p>在粗略的场景下，也可以直接使用 γ=2.2 的公式代替。</p><h2 id="6-代码实现"><a href="#6-代码实现" class="headerlink" title="6. 代码实现"></a>6. 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorRGB</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, wave_length</span>):</span><br><span class="line">        <span class="comment"># 波长</span></span><br><span class="line">        self.wavelengths = wave_length</span><br><span class="line">        <span class="comment"># self.transform_matrix = [[2.36461385, -0.89654057, -0.46807328],</span></span><br><span class="line">        <span class="comment">#                          [-0.51516621, 1.4264081, 0.0887581],</span></span><br><span class="line">        <span class="comment">#                          [0.0052037, -0.01440816, 1.00920446]]</span></span><br><span class="line"><span class="comment"># 转换矩阵</span></span><br><span class="line">        self.transform_matrix = [[<span class="number">3.1338561</span>, -<span class="number">1.6168667</span>, -<span class="number">0.4906146</span>],</span><br><span class="line">                                 [-<span class="number">0.9787684</span>, <span class="number">1.9161415</span>, <span class="number">0.0334540</span>],</span><br><span class="line">                                 [<span class="number">0.0719453</span>, -<span class="number">0.2289914</span>, <span class="number">1.4052427</span>]]</span><br><span class="line"><span class="comment"># g(x;u,sigma1,sigma2)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">piecewise_gaussian</span>(<span class="params">self, x, u, sigma1, sigma2</span>):</span><br><span class="line">        <span class="keyword">return</span> np.where(x &lt; u, np.exp(-<span class="number">0.5</span> * (x - u) ** <span class="number">2</span> / sigma1 ** <span class="number">2</span>), np.exp(-<span class="number">0.5</span> * (x - u) ** <span class="number">2</span> / sigma2 ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x_gaussian</span>(<span class="params">self, wavelength, adj=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> adj:</span><br><span class="line">            adj = [&#123;<span class="string">&quot;u&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma2&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;u&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma2&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;u&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma2&quot;</span>: <span class="number">0</span>&#125;]</span><br><span class="line">        result = <span class="number">0.362</span> * self.piecewise_gaussian(wavelength,</span><br><span class="line">                                                 <span class="number">442.0</span> + adj[<span class="number">0</span>][<span class="string">&quot;u&quot;</span>],</span><br><span class="line">                                                 <span class="number">16.0</span> + adj[<span class="number">0</span>][<span class="string">&quot;sigma1&quot;</span>],</span><br><span class="line">                                                 <span class="number">26.7</span> + adj[<span class="number">0</span>][<span class="string">&quot;sigma2&quot;</span>])</span><br><span class="line">        result += -<span class="number">0.065</span> * self.piecewise_gaussian(wavelength,</span><br><span class="line">                                                   <span class="number">501.1</span> + adj[<span class="number">1</span>][<span class="string">&quot;u&quot;</span>],</span><br><span class="line">                                                   <span class="number">20.4</span> + adj[<span class="number">1</span>][<span class="string">&quot;sigma1&quot;</span>],</span><br><span class="line">                                                   <span class="number">26.2</span> + adj[<span class="number">1</span>][<span class="string">&quot;sigma2&quot;</span>])</span><br><span class="line">        result += <span class="number">1.056</span> * self.piecewise_gaussian(wavelength,</span><br><span class="line">                                                  <span class="number">599.8</span> + adj[<span class="number">2</span>][<span class="string">&quot;u&quot;</span>],</span><br><span class="line">                                                  <span class="number">37.9</span> + adj[<span class="number">2</span>][<span class="string">&quot;sigma1&quot;</span>],</span><br><span class="line">                                                  <span class="number">31.0</span> + adj[<span class="number">2</span>][<span class="string">&quot;sigma2&quot;</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">y_gaussian</span>(<span class="params">self, wavelength, adj=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> adj:</span><br><span class="line">            adj = [&#123;<span class="string">&quot;u&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma2&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;u&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma2&quot;</span>: <span class="number">0</span>&#125;]</span><br><span class="line">        result = <span class="number">0.286</span> * self.piecewise_gaussian(wavelength,</span><br><span class="line">                                                 <span class="number">530.9</span> + adj[<span class="number">0</span>][<span class="string">&quot;u&quot;</span>],</span><br><span class="line">                                                 <span class="number">16.3</span> + adj[<span class="number">0</span>][<span class="string">&quot;sigma1&quot;</span>],</span><br><span class="line">                                                 <span class="number">31.1</span> + adj[<span class="number">0</span>][<span class="string">&quot;sigma2&quot;</span>])</span><br><span class="line">        result += <span class="number">0.821</span> * self.piecewise_gaussian(wavelength,</span><br><span class="line">                                                  <span class="number">568.8</span> + adj[<span class="number">1</span>][<span class="string">&quot;u&quot;</span>],</span><br><span class="line">                                                  <span class="number">46.9</span> + adj[<span class="number">1</span>][<span class="string">&quot;sigma1&quot;</span>],</span><br><span class="line">                                                  <span class="number">40.5</span> + adj[<span class="number">1</span>][<span class="string">&quot;sigma2&quot;</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">z_gaussian</span>(<span class="params">self, wavelength, adj: <span class="built_in">list</span> = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> adj:</span><br><span class="line">            adj = [&#123;<span class="string">&quot;u&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma2&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;u&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma1&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sigma2&quot;</span>: <span class="number">0</span>&#125;]</span><br><span class="line">        result = <span class="number">0.980</span> * self.piecewise_gaussian(wavelength,</span><br><span class="line">                                                 <span class="number">437.0</span> + adj[<span class="number">0</span>][<span class="string">&quot;u&quot;</span>],</span><br><span class="line">                                                 <span class="number">11.8</span> + adj[<span class="number">0</span>][<span class="string">&quot;sigma1&quot;</span>],</span><br><span class="line">                                                 <span class="number">36.0</span> + adj[<span class="number">0</span>][<span class="string">&quot;sigma2&quot;</span>])</span><br><span class="line">        result += <span class="number">0.681</span> * self.piecewise_gaussian(wavelength,</span><br><span class="line">                                                  <span class="number">459.0</span> + adj[<span class="number">1</span>][<span class="string">&quot;u&quot;</span>],</span><br><span class="line">                                                  <span class="number">26.0</span> + adj[<span class="number">1</span>][<span class="string">&quot;sigma1&quot;</span>],</span><br><span class="line">                                                  <span class="number">13.8</span> + adj[<span class="number">1</span>][<span class="string">&quot;sigma2&quot;</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="comment"># color matching function</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算色匹配函数值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_CIE_XYZ_weights</span>(<span class="params">self, adj_x: <span class="built_in">list</span> = <span class="literal">None</span>, adj_y: <span class="built_in">list</span> = <span class="literal">None</span>, adj_z: <span class="built_in">list</span> = <span class="literal">None</span></span>):</span><br><span class="line">        cie_x = self.x_gaussian(self.wavelengths, adj=adj_x)</span><br><span class="line">        cie_y = self.y_gaussian(self.wavelengths, adj=adj_y)</span><br><span class="line">        cie_z = self.z_gaussian(self.wavelengths, adj=adj_z)</span><br><span class="line">        <span class="keyword">return</span> cie_x, cie_y, cie_z</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示CIE-xyz色匹配函数曲线</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_weights_curve</span>(<span class="params">self, adj_x: <span class="built_in">list</span> = <span class="literal">None</span>, adj_y: <span class="built_in">list</span> = <span class="literal">None</span>, adj_z: <span class="built_in">list</span> = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># adj_x = [&#123;&quot;u&quot;: 50, &quot;sigma1&quot;: 0, &quot;sigma2&quot;: 0&#125;,</span></span><br><span class="line">        <span class="comment">#          &#123;&quot;u&quot;: 50, &quot;sigma1&quot;: 0, &quot;sigma2&quot;: 0&#125;,</span></span><br><span class="line">        <span class="comment">#          &#123;&quot;u&quot;: 50, &quot;sigma1&quot;: 0, &quot;sigma2&quot;: 0&#125;]</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># adj_y = [&#123;&quot;u&quot;: -50, &quot;sigma1&quot;: 0, &quot;sigma2&quot;: 0&#125;,</span></span><br><span class="line">        <span class="comment">#          &#123;&quot;u&quot;: -50, &quot;sigma1&quot;: 0, &quot;sigma2&quot;: 0&#125;]</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># adj_z = [&#123;&quot;u&quot;: 0, &quot;sigma1&quot;: 10, &quot;sigma2&quot;: 10&#125;,</span></span><br><span class="line">        <span class="comment">#          &#123;&quot;u&quot;: 0, &quot;sigma1&quot;: 10, &quot;sigma2&quot;: 30&#125;]</span></span><br><span class="line">        <span class="comment"># rgb_generator.show_weights_curve(adj_x=adj_x, adj_y=adj_y, adj_z=adj_z)</span></span><br><span class="line">        cie_x, cie_y, cie_z = self.get_CIE_XYZ_weights(adj_x=adj_x, adj_y=adj_y, adj_z=adj_z)</span><br><span class="line">        plt.figure(<span class="string">&quot;xyz_cmf&quot;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&quot;wave length/nm&quot;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&quot;value&quot;</span>)</span><br><span class="line">        plt.plot(self.wavelengths, cie_x, linewidth=<span class="number">1.5</span>, color=<span class="string">&quot;r&quot;</span>, label=<span class="string">&quot;x&quot;</span>)</span><br><span class="line">        plt.plot(self.wavelengths, cie_y, linewidth=<span class="number">1.5</span>, color=<span class="string">&quot;g&quot;</span>, label=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">        plt.plot(self.wavelengths, cie_z, linewidth=<span class="number">1.5</span>, color=<span class="string">&quot;b&quot;</span>, label=<span class="string">&quot;z&quot;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        plt.grid()</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伽马校正</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gamma_correction</span>(<span class="params">self, rgb, gamma=<span class="number">1.5</span></span>):</span><br><span class="line">        rgb = np.power(rgb, <span class="number">1</span> / gamma)</span><br><span class="line">        <span class="keyword">return</span> rgb</span><br><span class="line"><span class="comment"># 将高光谱图像合成为RGB图像</span></span><br><span class="line">    <span class="comment"># 高光谱图像 宽width,高height,通道数channels</span></span><br><span class="line">    <span class="comment"># hyper_image.shape == (height,width,channels) </span></span><br><span class="line">    <span class="comment"># adj_x,adj_y,adj_z,用来微调,u和sigma，改变xyz曲线的形状实现特殊效果</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_rgb</span>(<span class="params">self, hyper_image, adj_x: <span class="built_in">list</span> = <span class="literal">None</span>, adj_y: <span class="built_in">list</span> = <span class="literal">None</span>, adj_z: <span class="built_in">list</span> = <span class="literal">None</span>, BGR=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">                gamma_correction=<span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">        cie_x, cie_y, cie_z = self.get_CIE_XYZ_weights(adj_x=adj_x, adj_y=adj_y, adj_z=adj_z)</span><br><span class="line">        X = np.<span class="built_in">sum</span>(hyper_image * cie_x, axis=<span class="number">2</span>)</span><br><span class="line">        Y = np.<span class="built_in">sum</span>(hyper_image * cie_y, axis=<span class="number">2</span>)</span><br><span class="line">        Z = np.<span class="built_in">sum</span>(hyper_image * cie_z, axis=<span class="number">2</span>)</span><br><span class="line">        R = X * self.transform_matrix[<span class="number">0</span>][<span class="number">0</span>] + Y * self.transform_matrix[<span class="number">0</span>][<span class="number">1</span>] + Z * self.transform_matrix[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">        G = X * self.transform_matrix[<span class="number">1</span>][<span class="number">0</span>] + Y * self.transform_matrix[<span class="number">1</span>][<span class="number">1</span>] + Z * self.transform_matrix[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">        B = X * self.transform_matrix[<span class="number">2</span>][<span class="number">0</span>] + Y * self.transform_matrix[<span class="number">2</span>][<span class="number">1</span>] + Z * self.transform_matrix[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> BGR:</span><br><span class="line">            rgb_img = np.stack((B, G, R), axis=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rgb_img = np.stack((R, G, B), axis=-<span class="number">1</span>)</span><br><span class="line">        rgb_img = (rgb_img - np.<span class="built_in">min</span>(rgb_img)) / (np.<span class="built_in">max</span>(rgb_img) - np.<span class="built_in">min</span>(rgb_img))</span><br><span class="line">        <span class="keyword">if</span> gamma_correction:</span><br><span class="line">            rgb_img = self.gamma_correction(rgb_img)</span><br><span class="line">        <span class="keyword">return</span> rgb_img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据txt波长信息生成对应的npy波长文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">envitxt2npy</span>(<span class="params">txt_path, npy_savepath</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(txt_path) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()[<span class="number">3</span>:]</span><br><span class="line">        wavelengths = [<span class="built_in">float</span>(re.findall(<span class="string">r&quot;\d+\.?\d*&quot;</span>, line)[<span class="number">0</span>]) <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">    wavelengths = np.array(wavelengths)</span><br><span class="line">    np.save(os.path.join(npy_savepath, <span class="string">&quot;wavelengths_&quot;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(wavelengths)) + <span class="string">&quot;.npy&quot;</span>), wavelengths)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    envitxt2npy(<span class="string">&quot;envi_plot.txt&quot;</span>, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    wavelengths = np.load(<span class="string">&quot;wavelengths_128.npy&quot;</span>)</span><br><span class="line">    <span class="comment"># wavelengths_96 = wavelengths[31:223:2]</span></span><br><span class="line">    rgb_generator = GeneratorRGB(wavelengths)</span><br><span class="line"></span><br><span class="line">    rgb_generator.show_weights_curve()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-附录"><a href="#7-附录" class="headerlink" title="7. 附录"></a>7. 附录</h2><p>波段信息txt文件，一共128个波段:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">ENVI ASCII Plot File [*** *** 24 11:45:14 1919]</span><br><span class="line">Column 1: Wavelength</span><br><span class="line">Column 2: n_D Class #1~~2##255,0,0</span><br><span class="line">  371.700012   778.943339</span><br><span class="line">  376.100006   770.241712</span><br><span class="line">  380.500000   748.032550</span><br><span class="line">  385.000000   711.031947</span><br><span class="line">  389.399994   706.342978</span><br><span class="line">  393.899994   694.409283</span><br><span class="line">  398.299988   698.135021</span><br><span class="line">  402.799988   710.817360</span><br><span class="line">  407.299988   727.958409</span><br><span class="line">  411.799988   737.475588</span><br><span class="line">  416.299988   739.506932</span><br><span class="line">  420.700012   754.845690</span><br><span class="line">  425.200012   753.913201</span><br><span class="line">  429.799988   766.892706</span><br><span class="line">  434.299988   799.750452</span><br><span class="line">  438.799988   835.210970</span><br><span class="line">  443.299988   893.353225</span><br><span class="line">  447.899994   924.624473</span><br><span class="line">  452.399994   948.472574</span><br><span class="line">  457.000000   921.470766</span><br><span class="line">  461.500000   918.262809</span><br><span class="line">  466.100006   917.420735</span><br><span class="line">  470.700012   922.870404</span><br><span class="line">  475.299988   952.725136</span><br><span class="line">  479.899994   976.078360</span><br><span class="line">  484.399994  1012.474985</span><br><span class="line">  489.100006  1050.302592</span><br><span class="line">  493.700012  1181.345992</span><br><span class="line">  498.299988  1346.992164</span><br><span class="line">  502.899994  1583.062086</span><br><span class="line">  507.500000  1964.079566</span><br><span class="line">  512.200012  2337.871609</span><br><span class="line">  516.799988  2608.419530</span><br><span class="line">  521.500000  2934.751055</span><br><span class="line">  526.200012  3094.039783</span><br><span class="line">  530.799988  3225.940928</span><br><span class="line">  535.500000  3279.060880</span><br><span class="line">  540.200012  3196.213382</span><br><span class="line">  544.900024  3166.150090</span><br><span class="line">  549.599976  3102.237492</span><br><span class="line">  554.299988  3030.236890</span><br><span class="line">  559.000000  2949.843882</span><br><span class="line">  563.700012  2992.290536</span><br><span class="line">  568.500000  2944.970464</span><br><span class="line">  573.200012  2879.842676</span><br><span class="line">  577.900024  2709.165160</span><br><span class="line">  582.700012  2544.176612</span><br><span class="line">  587.400024  2243.330319</span><br><span class="line">  592.200012  2080.393008</span><br><span class="line">  597.000000  1939.819168</span><br><span class="line">  601.799988  1797.521398</span><br><span class="line">  606.500000  1670.897529</span><br><span class="line">  611.299988  1568.100663</span><br><span class="line">  616.099976  1483.772152</span><br><span class="line">  621.000000  1448.660639</span><br><span class="line">  625.799988  1376.030741</span><br><span class="line">  630.599976  1329.355636</span><br><span class="line">  635.400024  1293.602170</span><br><span class="line">  640.299988  1251.915009</span><br><span class="line">  645.099976  1221.805907</span><br><span class="line">  650.000000  1174.126582</span><br><span class="line">  654.799988  1124.404461</span><br><span class="line">  659.700012  1131.710066</span><br><span class="line">  664.599976  1119.727547</span><br><span class="line">  669.400024  1103.228451</span><br><span class="line">  674.299988  1090.617842</span><br><span class="line">  679.200012  1080.449066</span><br><span class="line">  684.099976  1026.330922</span><br><span class="line">  689.099976   993.049427</span><br><span class="line">  694.000000  1033.698614</span><br><span class="line">  698.900024  1022.889090</span><br><span class="line">  703.799988  1008.230862</span><br><span class="line">  708.799988   998.568415</span><br><span class="line">  713.700012   962.066305</span><br><span class="line">  718.700012   888.371308</span><br><span class="line">  723.599976   878.981314</span><br><span class="line">  728.599976   866.410488</span><br><span class="line">  733.599976   888.247137</span><br><span class="line">  738.599976   897.895118</span><br><span class="line">  743.599976   917.882459</span><br><span class="line">  748.599976   911.596745</span><br><span class="line">  753.599976   914.708258</span><br><span class="line">  758.599976   771.996986</span><br><span class="line">  763.599976   730.689572</span><br><span class="line">  768.599976   847.165160</span><br><span class="line">  773.700012   855.122363</span><br><span class="line">  778.700012   836.664858</span><br><span class="line">  783.799988   827.171790</span><br><span class="line">  788.799988   806.916817</span><br><span class="line">  793.900024   790.221820</span><br><span class="line">  798.900024   789.949367</span><br><span class="line">  804.000000   809.836649</span><br><span class="line">  809.099976   807.355033</span><br><span class="line">  814.200012   784.625075</span><br><span class="line">  819.299988   769.038577</span><br><span class="line">  824.400024   786.312839</span><br><span class="line">  829.500000   788.345389</span><br><span class="line">  834.700012   806.656420</span><br><span class="line">  839.799988   826.106088</span><br><span class="line">  844.900024   827.244123</span><br><span class="line">  850.099976   827.270645</span><br><span class="line">  855.200012   816.968053</span><br><span class="line">  860.400024   824.337553</span><br><span class="line">  865.500000   814.603978</span><br><span class="line">  870.700012   798.827004</span><br><span class="line">  875.900024   796.328511</span><br><span class="line">  881.099976   787.040386</span><br><span class="line">  886.299988   772.019289</span><br><span class="line">  891.500000   761.085594</span><br><span class="line">  896.700012   742.569620</span><br><span class="line">  901.900024   697.479204</span><br><span class="line">  907.099976   697.937312</span><br><span class="line">  912.400024   680.795660</span><br><span class="line">  917.599976   674.689572</span><br><span class="line">  922.900024   671.657625</span><br><span class="line">  928.099976   671.411694</span><br><span class="line">  933.400024   649.347197</span><br><span class="line">  938.700012   619.044605</span><br><span class="line">  943.900024   624.757083</span><br><span class="line">  949.200012   619.104882</span><br><span class="line">  954.500000   621.953586</span><br><span class="line">  959.799988   610.510549</span><br><span class="line">  965.099976   612.142857</span><br><span class="line">  970.400024   613.606992</span><br><span class="line">  975.700012   621.637734</span><br><span class="line">  981.099976   613.901145</span><br><span class="line">  986.400024   615.367691</span><br><span class="line">  991.700012   616.359253</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 高光谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】Topk问题</title>
      <link href="/2023/05/11/TopK%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/11/TopK%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="TopK问题"><a href="#TopK问题" class="headerlink" title="TopK问题"></a>TopK问题</h1><p>参考文章：</p><p><a href="https://blog.csdn.net/u013074465/article/details/42083607">快速排序的几种常见实现及其性能对比_Sunshine_top的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/justidle/article/details/104203963">排序——快速排序（Quick sort）_努力的老周的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/76734219">面试官最喜爱的TopK问题算法详解 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278">拜托，面试别再问我TopK了！！！<em>架构师之路</em>的博客-CSDN博客</a></p><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/19607/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">215. 数组中的第K个最大元素 - 力扣（Leetcode）</a></p><p><strong>问题描述：</strong></p><p>从arr[1, n]这n个数中，找出最大的k个数，这就是经典的TopK问题。</p><p>栗子：</p><p>从arr[1, 12]={5,3,7,1,8,2,9,4,7,2,6,6} 这n=12个数中，找出最大的k=5个。</p><h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h2><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/v2-059b7c46fd33e605cbbbfce8a2a1c3a0_720w.webp" alt="img"></p><p>排序是最容易想到的方法，将n个数排序之后，取出最大的k个，即为所得。</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(arr, 1, n);</span><br><span class="line">return arr[1, k];</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n*lg(n))</p><p>分析：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？这就引出了第二个优化方法。</p><h2 id="2-局部排序"><a href="#2-局部排序" class="headerlink" title="2. 局部排序"></a>2. 局部排序</h2><p>不再全局排序，只对最大的k个排序。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/1_sort.webp" alt="img"></p><p>冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(i=1 to k)&#123;</span><br><span class="line">bubble_find_max(arr,i);</span><br><span class="line">&#125;</span><br><span class="line">return arr[1, k];</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n*k)</p><p>分析：冒泡，将全局排序优化为了局部排序，非TopK的元素是不需要排序的，节省了计算资源。不少朋友会想到，需求是TopK，是不是这最大的k个元素也不需要排序呢？这就引出了第三个优化方法。</p><h2 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h2><p>思路：只找到TopK，不排序TopK。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/0_heapSort.webp" alt="img"></p><p>先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/1_heapSort.webp" alt="img"></p><p>接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/2_heapSort.webp" alt="img"></p><p>直到，扫描完所有n-k个元素，最终堆中的k个元素，就是猥琐求的TopK。</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = make_heap(arr[1, k]);</span><br><span class="line"></span><br><span class="line">for(i=k+1 to n)&#123;</span><br><span class="line">adjust_heap(heep[k],arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">return heap[k];</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n*lg(k))</p><p>画外音：n个元素扫一遍，假设运气很差，每次都入堆调整，调整时间复杂度为堆的高度，即lg(k)，故整体时间复杂度是n*lg(k)。</p><p>分析：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？</p><h2 id="4-随机选择算法"><a href="#4-随机选择算法" class="headerlink" title="4. 随机选择算法"></a>4. 随机选择算法</h2><p>随机选择算在是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。</p><p>这个方法并不是所有同学都知道，为了将算法讲透，先聊一些前序知识，一个所有程序员都应该烂熟于胸的经典算法：快速排序。</p><h3 id="4-1-快速排序回顾"><a href="#4-1-快速排序回顾" class="headerlink" title="4.1 快速排序回顾"></a>4.1 快速排序回顾</h3><p><strong>算法思路</strong><br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>快速排序算法通过多次比较和交换来实现排序，其排序流程如下：</p><ul><li><p>1、首先设定一个分界值，通过该分界值将数组分成左右两部分。</p></li><li><p>2、将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。</p></li><li><p>3、然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p></li><li><p>4、重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p></li></ul><p>概括来说为 挖坑填数 + 分治法。</p><p><strong>图解算法</strong><br>快速排序主要有三个参数，left 为区间的开始地址，right 为区间的结束地址，Key 为当前的开始的值。</p><p>我们从待排序的记录序列中选取一个记录（通常第一个）作为基准元素（称为key）key=arr[left]，然后设置两个变量，left指向数列的最左部，right 指向数据的最右部。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/0_quickSort.webp" alt=""></p><p><strong>第一步</strong><br>key 首先与 arr[right] 进行比较，如果 arr[right]<key，则arr[left]=arr[right]将这个比key小的数放到左边去，如果arr[right]>key则我们只需要将right—，right—之后，再拿arr[right]与key进行比较，直到arr[right]&lt;key交换元素为止。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/1_quickSort.webp" alt=""></p><p><strong>第二步</strong><br>如果右边存在arr[right]<key的情况，将arr[left]=arr[right]，接下来，将转向left端，拿arr[left ]与key进行比较，如果arr[left]>key,则将arr[right]=arr[left]，如果arr[left]&lt;key，则只需要将left++,然后再进行arr[left]与key的比较。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/2_quickSort.webp" style="zoom: 150%;" /></p><p><strong>第三步</strong><br>然后再移动right重复上述步骤。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/2_quickSort.webp" style="zoom:150%;" /></p><p><strong>第四步</strong><br>最后得到 {23 58 13 10 57 62} 65 {106 78 95 85}，再对左子数列与右子数列进行同样的操作。最终得到一个有序的数列。<br>快排伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span>[]arr, <span class="type">int</span> low, inthigh)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low== high) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line"><span class="built_in">quick_sort</span>(arr, low, i<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">quick_sort</span>(arr, i+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java代码模板1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快排</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            quickSort(nums, left, pos - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, pos + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[index];</span><br><span class="line">        nums[index] = nums[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) right--;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) left++;</span><br><span class="line">            nums[right] = nums[left]; </span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java代码模板2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a[l];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">do</span>&#123;i++;&#125;<span class="keyword">while</span>(a[i]&lt;x);</span><br><span class="line">            <span class="keyword">do</span>&#123;j--;&#125;<span class="keyword">while</span>(a[j]&gt;x);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[i];</span><br><span class="line">                a[i] = t; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(a,l,j);</span><br><span class="line">        quickSort(a,j+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-随机选择算法与快排"><a href="#4-2-随机选择算法与快排" class="headerlink" title="4.2 随机选择算法与快排"></a>4.2 随机选择算法与快排</h3><p>快速排序核心算法思想是，分治法。</p><p>分治法（Divide&amp;Conquer），把一个大的问题，转化为若干个子问题（Divide），每个子问题“都”解决，大的问题便随之解决（Conquer）。这里的关键词是“都”。从伪代码里可以看到，快速排序递归时，先通过partition把数组分隔为两个部分，两个部分“都”要再次递归。</p><p>分治法有一个特例，叫减治法。</p><p>减治法（Reduce&amp;Conquer），把一个大的问题，转化为若干个子问题（Reduce），这些子问题中“只”解决一个，大的问题便随之解决（Conquer）。这里的关键词是“只”。</p><p>快速排序的核心是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = partition(arr, low, high);</span><br></pre></td></tr></table></figure><p>这个partition是干嘛的呢？</p><p>顾名思义，partition会把整体分为两个部分。</p><p>更具体的，会用数组arr中的一个元素（默认是第一个元素t=arr[low]）为划分依据，将数据arr[low, high]划分成左右两个子数组：</p><ul><li><p>左半部分，都比t大</p></li><li><p>右半部分，都比t小</p></li><li><p>中间位置i是划分元素</p></li></ul><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/0_partition.webp" alt=""></p><p>以上述TopK的数组为例，先用第一个元素t=arr[low]为划分依据，扫描一遍数组，把数组分成了两个半区：</p><ul><li><p>左半区比t大</p></li><li><p>右半区比t小</p></li><li><p>中间是t</p></li></ul><p>partition返回的是t最终的位置i。</p><p>很容易知道，partition的时间复杂度是O(n)。(把整个数组扫一遍，比t大的放左边，比t小的放右边，最后t放在中间N[i]。)</p><p>partition和TopK问题有什么关系呢？</p><p>TopK是希望求出arr[1,n]中最大的k个数，那如果找到了第k大的数，做一次partition，不就一次性找到最大的k个数了么？(即partition后左半区的k个数。)</p><p>问题变成了arr[1, n]中找到第k大的数。</p><p>再回过头来看看第一次partition，划分之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = partition(arr, 1, n);</span><br></pre></td></tr></table></figure><p><strong>如果i大于k，则说明arr[i]左边的元素都大于k，于是只递归arr[1, i-1]里第k大的元素即可；</strong></p><p><strong>如果i小于k，则说明说明第k大的元素在arr[i]的右边，于是只递归arr[i+1, n]里第k-i大的元素即可；</strong></p><p>这就是随机选择算法randomized_select，RS，其伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RS</span><span class="params">(arr, low, high, k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low== high) <span class="keyword">return</span> arr[low];</span><br><span class="line">i= <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line">temp= i-low; <span class="comment">//数组前半部分元素个数</span></span><br><span class="line"><span class="keyword">if</span>(temp&gt;=k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RS</span>(arr, low, i<span class="number">-1</span>, k); <span class="comment">//求前半部分第k大</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RS</span>(arr, i+<span class="number">1</span>, high, k-i); <span class="comment">//求后半部分第k-i大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/1_partition.webp" alt=""></p><p>时间复杂度:O(n);这里 N 是数组的长度,假设每次pivot都在中间O(以n为首项，1/2为等比数列q的等比数列的和) = O(n)</p><p>空间复杂度:O(n);</p><p>最后通过随机选择（randomized_select），找到arr[1, n]中第k大的数，再进行一次partition，就能得到TopK的结果。</p><p><strong>例题：215. 数组中的第K个最大元素</strong></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len - k;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (pivotIndex == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[pivotIndex]; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; target) &#123;</span><br><span class="line">                left = pivotIndex + <span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// pivotIndex &gt; target</span></span><br><span class="line">                right = pivotIndex - <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[index];</span><br><span class="line">        nums[index] = nums[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) right--;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) left++;</span><br><span class="line">            nums[right] = nums[left]; </span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)，<strong>没有使用递归</strong>，在逐渐缩小搜索区间的过程中只使用到常数个变量。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】动态规划</title>
      <link href="/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-0-1背包问题"><a href="#1-0-1背包问题" class="headerlink" title="1. 0-1背包问题"></a>1. 0-1背包问题</h2><p>通用解题步骤</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>背包最大重量为4。</p><p>物品为：</p><div class="table-container"><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table></div><p>问背包能背的物品最大价值是多少？</p><p>依然动规五部曲分析一波。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>对于背包问题，可以使用二维数组，即<code>dp[i][j]</code>表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><ol><li>确定递推公式</li></ol><p>再回顾一下<code>dp[i][j]</code>的含义：从下标为<code>[0-i]</code>的物品里任意取，放进容量为<code>j</code>的背包，价值总和最大是多少。</p><p>那么可以有两个方向推出来<code>dp[i][j]</code>，</p><ul><li><strong>不放物品i</strong>：由<code>dp[i - 1][j]</code>推出，即背包容量为j，里面不放物品i的最大价值，此时<code>dp[i][j]</code>就是<code>dp[i - 1][j]</code>。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由<code>dp[i - 1][j - weight[i]]</code>推出，<code>dp[i - 1][j - weight[i]]</code>为背包容量为j - weight[i]的时候不放物品i的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i]</code> （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>所以递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><ol><li>dp数组如何初始化</li></ol><p>首先从<code>dp[i][j]</code>的定义出发，如果背包容量j为0的话，即<code>dp[i][0]</code>，无论是选取哪些物品，背包价值总和一定为0。</p><p>状态转移方程<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code>可以看出<code>i</code>是由<code>i-1</code> 推导出来，那么i为0的时候就一定要初始化。</p><p><code>dp[0][j]</code>，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，<code>dp[0][j]</code>应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，<code>dp[0][j]</code>应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时dp数组初始化情况如图所示：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20230405191659628.webp" alt="动态规划-背包问题7"></p><ol><li>确定遍历顺序</li></ol><p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p><p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p><p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p><p>例如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动数组优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BagProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] weight = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] value = &#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bagSize</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        testWeightBagProblem(weight,value,bagSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划获得结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight  物品的重量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   物品的价值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bagSize 背包的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagSize)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建dp数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">goods</span> <span class="operator">=</span> weight.length;  <span class="comment">// 获取物品的数量</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[goods][bagSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化dp数组</span></span><br><span class="line">        <span class="comment">// 创建数组后，其中默认的值就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[<span class="number">0</span>]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; weight[i]) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的</span></span><br><span class="line"><span class="comment">                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 当前背包的容量可以放下物品i</span></span><br><span class="line"><span class="comment">                     * 那么此时分两种情况：</span></span><br><span class="line"><span class="comment">                     *    1、不放物品i</span></span><br><span class="line"><span class="comment">                     *    2、放物品i</span></span><br><span class="line"><span class="comment">                     * 比较这两种情况下，哪种背包中物品的最大价值最大</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j] , dp[i-<span class="number">1</span>][j-weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; goods; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-例题-0-1背包问题"><a href="#2-例题-0-1背包问题" class="headerlink" title="2. 例题 0-1背包问题"></a>2. 例题 0-1背包问题</h2><h3 id="2-1-分割等和子集-416"><a href="#2-1-分割等和子集-416" class="headerlink" title="2.1 分割等和子集 (416)"></a>2.1 分割等和子集 (416)</h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><p>根据题意，可以转化为是否能够从集合中选出元素使得元素的和是集合所有元素和的一半</p><p>定义<code>dp[i][j]</code>为从前i个元素中选取几个，是否能够使得和为j</p><p>因此采用boolean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>)<span class="keyword">return</span> nums[<span class="number">0</span>]==nums[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length][sum+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][sum])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] || (j&gt;nums[i]?dp[i-<span class="number">1</span>][j-nums[i]]:<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动数组优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>)<span class="keyword">return</span> nums[<span class="number">0</span>]==nums[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        dp[nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                dp[j] = dp[j] || (j&gt;nums[i]?dp[j-nums[i]]:<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-最后一块石头的重量-II-1049"><a href="#2-2-最后一块石头的重量-II-1049" class="headerlink" title="2.2 最后一块石头的重量 II (1049)"></a>2.2 最后一块石头的重量 II (1049)</h3><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [31,26,33,21,40]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>相当于给背包设个限制最多装sum/2的重量，看在这个限制下最多能装多少，假设最多能装a,那么剩下的就是sum-a,正反物质相遇湮灭剩下sum-a-a</p><p>因为sum/2 &lt;= sum -sum/2,所以不必担心最终结果是负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            sum += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[stones.length][target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=stones[<span class="number">0</span>])&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = stones[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;stones[i])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-stones[i]]+stones[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span>*dp[stones.length-<span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-完全背包问题"><a href="#3-完全背包问题" class="headerlink" title="3.  完全背包问题"></a>3.  完全背包问题</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p>对于0-1背包而言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//滚动数组优化版本</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于完全背包而言：</p><p><strong>如果你不把这第 <code>i</code> 个物品装入背包</strong>，也就是说你不加入第<code>i</code>个 这个价值的物品，那么凑出总价值<code>j</code> 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果。</p><p><strong>如果你把这第 <code>i</code> 个物品装入了背包</strong>，也就是说你加入第<code>i</code>个 这个价值的物品，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-weight[i]]</code>。若只使用前 <code>i</code> 个物品（可以重复使用），当背包容量为 <code>j-weight[i]</code> 时，有 <code>dp[i][j-weight[i]]</code> 种方法可以装满背包。看到了吗，<code>dp[i][j-weight[i]]</code> 也是允许你使用第 <code>i</code> 个硬币的，所以说已经包含了重复使用硬币的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维形式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;= weight.size();i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=bagWeight;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=weight[i])&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-weight[i]];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</span></span><br><span class="line"><span class="comment">//而完全背包的物品是可以添加多次的，所以要从小到大去遍历</span></span><br><span class="line"><span class="comment">// 先遍历物品，再遍历背包,滚动数组优化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-例题-完全背包问题"><a href="#4-例题-完全背包问题" class="headerlink" title="4. 例题 完全背包问题"></a>4. 例题 完全背包问题</h2><h3 id="4-1-零钱兑换-II-518"><a href="#4-1-零钱兑换-II-518" class="headerlink" title="4.1 零钱兑换 II (518)"></a>4.1 零钱兑换 II (518)</h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 10, coins = [10] </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//dp[j]：凑成总金额j的货币组合数为dp[j]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[coins.length+<span class="number">1</span>][amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=coins.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-coins[i-<span class="number">1</span>]];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[coins.length][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动数组优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i-<span class="number">1</span>];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-coins[i-<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-零钱兑换-322"><a href="#4-2-零钱兑换-322" class="headerlink" title="4.2 零钱兑换 (322)"></a>4.2 零钱兑换 (322)</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[coins.length + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= coins.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - coins[i - <span class="number">1</span>] &gt;= <span class="number">0</span>&amp;&amp;dp[i][j-coins[i-<span class="number">1</span>]]!=Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[coins.length][amount] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>  dp[coins.length][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//注意输入[2]， 3的情况</p><p>滚动数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            dp[j] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i-<span class="number">1</span>];j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-coins[i-<span class="number">1</span>]]!=Integer.MAX_VALUE)&#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j],dp[j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount]==Integer.MAX_VALUE)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】Java多线程</title>
      <link href="/2023/03/29/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/03/29/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h2><h3 id="1-1-创建线程类"><a href="#1-1-创建线程类" class="headerlink" title="1.1 创建线程类"></a>1.1 创建线程类</h3><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。</p><p>创建新执行线程有两种方法。一种方法是将类声明为 <code>Thread</code> 的子类。该子类应重写 <code>Thread</code> 类的  <code>run</code> 方法。接下来可以分配并启动该子类的实例。创建线程的另一种方法是声明实现 <code>Runnable</code> 接口的类。该类然后实现 <code>run</code>  方法。然后可以分配该类的实例，在创建 <code>Thread</code> 时作为一个参数来传递并启动。</p><p>Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码如下：</p><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建自定义线程对象</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line"><span class="comment">//开启新线程</span></span><br><span class="line">mt.start();</span><br><span class="line"><span class="comment">//在主方法中执行for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line"><span class="built_in">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice：</p><ul><li>start()使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 结果是两个线程并发地运行；当前线程（从调用返回给 start 方法）和另一个线程（执行其 run 方法）。 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</li><li>Java程序属于抢占式调度，哪个线程优先级高就优先执行哪个线程，优先级一样随机选择</li></ul><h3 id="1-2-多线程内存图解"><a href="#1-2-多线程内存图解" class="headerlink" title="1.2  多线程内存图解"></a>1.2  多线程内存图解</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202303292248208.webp" alt=""></p><h3 id="1-3-声明实现Runnable接口的实现类"><a href="#1-3-声明实现Runnable接口的实现类" class="headerlink" title="1.3 声明实现Runnable接口的实现类"></a>1.3 声明实现Runnable接口的实现类</h3><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableImpl</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread和Runnable的区别</strong></p><p>实现Runnable接口创建多线程程序的好处:</p><ul><li>避免了单继承的局限性，一个类只能继承一个类，类如果继承了Thread类就不能继承其他类，实现了Runnable接口还可以继承其他的类。</li><li>增强了程序的扩展性，降低程序的耦合性，实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离。实现类中，重写了run方法，用来设置线程任务。创建Thread类对象，调用start方法，用来开启新线程。给Thread传递不同的实现类可以实现不同的任务。</li></ul><h3 id="1-4-匿名内部类方式实现线程的创建"><a href="#1-4-匿名内部类方式实现线程的创建" class="headerlink" title="1.4 匿名内部类方式实现线程的创建"></a>1.4 匿名内部类方式实现线程的创建</h3><p>使用匿名内部类可以简化代码，将子类继承父类，重写父类的方法，创建子类对象合成为一步完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式: <span class="keyword">new</span> 父类/接口()&#123;</span><br><span class="line">    重写父类/接口中的方法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>样例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInnerClassThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//线程的接口Runnable</span></span><br><span class="line">        <span class="comment">//Runnable r = new Runnable();//多态</span></span><br><span class="line">        <span class="comment">//使用接口接受一个实现类</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h2><h3 id="2-1-线程安全问题"><a href="#2-1-线程安全问题" class="headerlink" title="2.1 线程安全问题"></a>2.1 线程安全问题</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202303292248521.webp" alt=""></p><p>存在线程安全问题的代码样例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现卖票案例</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个多线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先判断票还有没有</span></span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//票存在,卖票</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口的实现类对象</span></span><br><span class="line">        <span class="type">RunnableImpl</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到出现了重复<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0-&gt;正在卖第100张票</span><br><span class="line">Thread-2-&gt;正在卖第100张票</span><br><span class="line">Thread-1-&gt;正在卖第100张票</span><br><span class="line">Thread-2-&gt;正在卖第97张票</span><br><span class="line">Thread-0-&gt;正在卖第97张票</span><br><span class="line">Thread-1-&gt;正在卖第97张票</span><br><span class="line">Thread-1-&gt;正在卖第94张票</span><br><span class="line">Thread-2-&gt;正在卖第94张票</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202303292248298.webp" alt=""></p><h3 id="2-2-线程同步问题"><a href="#2-2-线程同步问题" class="headerlink" title="2.2 线程同步问题"></a>2.2 线程同步问题</h3><p>Java提供了线程同步机制(synchronized)来解决线程安全问题</p><p>有3种方式完成同步操作:</p><ul><li>同步代码块</li><li>同步方法</li><li>锁机制</li></ul><h4 id="2-2-1-同步代码块"><a href="#2-2-1-同步代码块" class="headerlink" title="2.2.1 同步代码块"></a>2.2.1 同步代码块</h4><p><strong>同步代码块</strong>: <code>synchronized</code>关键字可以用于方法中的某个区块中，表示只对这个区块的资源进行互斥访问.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    需要同步操作的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步锁</strong>:</p><p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁</p><ol><li><p>锁对象可以是任意类型。</p></li><li><p>多个线程对象只能使用同一把锁。</p></li><li>作用: 把同步代码块锁住，只让一个线程在同步代码块中执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个多线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">//先判断票还有没有</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//票存在,卖票</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202303292248264.webp" alt=""></p><h4 id="2-2-2-同步方法"><a href="#2-2-2-同步方法" class="headerlink" title="2.2.2 同步方法"></a>2.2.2 同步方法</h4><p><strong>同步方法</strong>:使用synchronized修饰的方法，就叫做同步方法，保证A线程执行该方法的时候，其他线程只能在外面等着。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步锁是谁：</p><ul><li><p>对于非static方法，同步锁就是this</p></li><li><p>对于static方法，同步锁就是当前方法所在类的字节码对象(类名.class)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现卖票案例,使用同步方法解决线程同步问题</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个多线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            payTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">payTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断票还有没有</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//票存在,卖票</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-Lock锁"><a href="#2-2-3-Lock锁" class="headerlink" title="2.2.3 Lock锁"></a>2.2.3 Lock锁</h4><p>java.util.concurrent.locks </p><p><code>Lock</code> 实现提供了比使用 <code>synchronized</code>  方法和语句可获得的更广泛的锁定操作。同步代码块和同步方法具有的功能Lock锁都具备，除此之外更加强大，更加体现面向对象。</p><p>Lock锁也称同步锁，加锁和释放锁方法化了，如下:</p><ul><li><code>public void lock()</code>:加同步锁</li><li><code>public void unlock()</code>:释放同步锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.concurrent.locks.lock//接口</span></span><br><span class="line"><span class="comment">//java.util.concurrent.locks.ReentrantLock//实现类</span></span><br><span class="line">使用步骤:</span><br><span class="line"><span class="number">1.</span> 在成员位置创建一个ReentrantLock对象</span><br><span class="line"><span class="number">2.</span> 在可能出现线程安全问题的代码前调用Lock接口中的Lock方法获取锁</span><br><span class="line"><span class="number">2.</span> 在可能出现线程安全的代码后调用Lock接口中的unlock方法释放锁</span><br></pre></td></tr></table></figure><p>使用如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现卖票案例,使用Lock锁解决线程同步问题</span></span><br><span class="line"><span class="comment"> * java.util.concurrent.locks.lock接口</span></span><br><span class="line"><span class="comment"> * java.util.concurrent.locks.ReentrantLock实现类</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个多线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//先判断票还有没有</span></span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//票存在,卖票</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-线程状态"><a href="#3-线程状态" class="headerlink" title="3. 线程状态"></a>3. 线程状态</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中， 有几种状态呢？在API中<code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态： 这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析:</p><div class="table-container"><table><thead><tr><th>线程状态</th><th>导致状态发生的条件</th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。还未调用start方法</td></tr><tr><td>Runnable(可运行)</td><td>线程可以在jvm中运行的状态，可能正在运行自己的代码，也可能没有，看OS和CPU</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他线程持有，则该线程进入Blocked状态，当该线程持有锁时，将变成Runnable状态</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行(唤醒)操作时，该线程进入waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td></tr><tr><td>Timed Waiting(计时等待)</td><td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep、Obejct.wait。</td></tr><tr><td>Terminated(被终止)</td><td>因为run方法正常退出而死亡,或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table></div><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE.webp" alt=""></p><h3 id="3-1-Timed-Waiting-计时等待状态"><a href="#3-1-Timed-Waiting-计时等待状态" class="headerlink" title="3.1 Timed Waiting(计时等待状态)"></a>3.1 Timed Waiting(计时等待状态)</h3><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就 强制当前正在执行的线程休眠（暂停执行）以“减慢线程”。其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85.webp"  /></p><h3 id="3-2-BLOCKED-锁阻塞"><a href="#3-2-BLOCKED-锁阻塞" class="headerlink" title="3.2 BLOCKED(锁阻塞)"></a>3.2 BLOCKED(锁阻塞)</h3><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。<br>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/%E9%94%81%E9%98%BB%E5%A1%9E.webp" alt=""></p><h2 id="4-等待与唤醒机制"><a href="#4-等待与唤醒机制" class="headerlink" title="4. 等待与唤醒机制"></a>4. 等待与唤醒机制</h2><h3 id="4-1-线程间通信"><a href="#4-1-线程间通信" class="headerlink" title="4.1 线程间通信"></a>4.1 线程间通信</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.webp" alt=""></p><p><strong>为什么要处理线程间通信:</strong></p><p>多个线程并行执行时，在默认情况下CPU是随即切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行，那么多线程之间需要一些协调通信，以此来帮助我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h3 id="4-2-等待与唤醒机制"><a href="#4-2-等待与唤醒机制" class="headerlink" title="4.2  等待与唤醒机制"></a>4.2  等待与唤醒机制</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/01_%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90_1.webp" alt=""></p><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（<strong>wait()</strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（<strong>notify()</strong>）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h3 id="4-3-生产者与消费者问题"><a href="#4-3-生产者与消费者问题" class="headerlink" title="4.3 生产者与消费者问题"></a>4.3 生产者与消费者问题</h3><p>等待唤醒机制其实就是经典的生产者消费者问题。</p><p>以生产包子消费包子为例来说明等待唤醒机制如何有效利用资源：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/01_%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90_2.webp" alt=""><br>包子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoZi</span> &#123;</span><br><span class="line">    <span class="comment">//皮</span></span><br><span class="line">    String skin;</span><br><span class="line">    <span class="comment">//馅</span></span><br><span class="line">    String stuff;</span><br><span class="line">    <span class="comment">//包子的状态:true 有 false无</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包子铺类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意: 包子铺线程和包子线程的关系---(互斥)</span></span><br><span class="line"><span class="comment"> * 必须同时同步，保证两个线程只有一个在执行</span></span><br><span class="line"><span class="comment"> * 锁对象必须保持唯一，可以使用包子对象作为锁对象</span></span><br><span class="line"><span class="comment"> * 包子铺类和吃货类需要把包子对象作为参数传进来</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoZiStore</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaoZiStore</span><span class="params">(BaoZi bz)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个变量用来记录包子的种类</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="comment">//对包子的状态进行判断</span></span><br><span class="line">                <span class="keyword">if</span> (bz.flag) &#123;</span><br><span class="line">                    <span class="comment">//包子铺调用wait方法进入等待状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//被唤醒后执行</span></span><br><span class="line">                <span class="comment">//交替生产两种包子</span></span><br><span class="line">                <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//生产薄皮三鲜馅包子</span></span><br><span class="line">                    bz.skin = <span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    bz.stuff = <span class="string">&quot;三鲜&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bz.skin = <span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    bz.stuff = <span class="string">&quot;牛肉&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺正在生产:&quot;</span> + bz.skin + bz.stuff);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//包子铺生产好了包子</span></span><br><span class="line">                <span class="comment">//修改包子的状态为true</span></span><br><span class="line">                bz.flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//唤醒等待的吃货线程</span></span><br><span class="line">                bz.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺已经生产好了:&quot;</span> + bz.skin + bz.stuff + <span class="string">&quot;吃货可以开始吃了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BaoZi bz)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="comment">//对包子状态进行判断</span></span><br><span class="line">                <span class="keyword">if</span> (!bz.flag) &#123;</span><br><span class="line">                    <span class="comment">//吃货调用wait方法进入等待状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//被唤醒后执行的代码</span></span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃:&quot;</span> + bz.skin + bz.stuff);</span><br><span class="line">                bz.flag = <span class="literal">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货已经把:&quot;</span> + bz.skin + bz.stuff + <span class="string">&quot;吃完了，包子铺开始生产包子了&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;__________________________________________________&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BaoZi</span> <span class="variable">bz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaoZi</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BaoZiStore</span>(bz).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(bz).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5. 线程池"></a>5. 线程池</h2><h3 id="5-1-线程池概念"><a href="#5-1-线程池概念" class="headerlink" title="5.1 线程池概念"></a>5.1 线程池概念</h3><p><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/02_%E7%BA%BF%E7%A8%8B%E6%B1%A0.webp" alt=""></p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h3 id="5-2-线程池的使用"><a href="#5-2-线程池的使用" class="headerlink" title="5.2 线程池的使用"></a>5.2 线程池的使用</h3><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池jdk1.5之后提供</span></span><br><span class="line"><span class="comment"> * java.util.concurrent.Executors:线程池的工厂类，用来生成线程池</span></span><br><span class="line"><span class="comment"> * Executor类中的静态方法</span></span><br><span class="line"><span class="comment"> *      static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用固定线程数的线程池</span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> *      int nThreads:创建线程池中的线程数量</span></span><br><span class="line"><span class="comment"> * 返回值:</span></span><br><span class="line"><span class="comment"> *      ExecutorService接口，返回的是ExecutorService接口的实现对象，我们可以使用ExecutorService接口接收(面向接口编程)</span></span><br><span class="line"><span class="comment"> * java.util.concurrent.ExecutorService:线程池接口</span></span><br><span class="line"><span class="comment"> *      用来从线程池中获取线程，调用start方法，执行线程任务</span></span><br><span class="line"><span class="comment"> *          submit(Runnable task)提交一个Runnable任务用于执行</span></span><br><span class="line"><span class="comment"> *      关闭/销毁线程池的方法</span></span><br><span class="line"><span class="comment"> *          void shutdown()按顺序完成当前任务,不在接收新任务</span></span><br><span class="line"><span class="comment"> * 线程池的使用步骤:</span></span><br><span class="line"><span class="comment"> *     1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</span></span><br><span class="line"><span class="comment"> *     2.创建一个类，实现Runnable接口，重写run方法</span></span><br><span class="line"><span class="comment"> *     3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程，执行run方法</span></span><br><span class="line"><span class="comment"> *     4.(可选)调用ExecutorService中的方法shutdown销毁线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><p>Runnable实现类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要一个教练&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PID控制算法】 python模拟PID控制算法</title>
      <link href="/2023/03/17/PID/"/>
      <url>/2023/03/17/PID/</url>
      
        <content type="html"><![CDATA[<h1 id="PID控制Python模拟"><a href="#PID控制Python模拟" class="headerlink" title="PID控制Python模拟"></a>PID控制Python模拟</h1><h2 id="1-PID控制器"><a href="#1-PID控制器" class="headerlink" title="1. PID控制器"></a>1. PID控制器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PID</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;PID Controller</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, P=<span class="number">0.2</span>, I=<span class="number">0.0</span>, D=<span class="number">0.0</span>, current_time=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">        self.Kp = P</span><br><span class="line">        self.Ki = I</span><br><span class="line">        self.Kd = D</span><br><span class="line"></span><br><span class="line">        self.sample_interval = <span class="number">0</span></span><br><span class="line">        self.current_time = current_time <span class="keyword">if</span> current_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> time.time()</span><br><span class="line">        self.last_time = self.current_time</span><br><span class="line"></span><br><span class="line">        self.PTerm_list = []</span><br><span class="line">        self.ITerm_list = []</span><br><span class="line">        self.DTerm_list = []</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Clears PID computations and coefficients&quot;&quot;&quot;</span></span><br><span class="line">        self.targetPoint = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.PTerm = <span class="number">0</span></span><br><span class="line">        self.ITerm = <span class="number">0</span></span><br><span class="line">        self.DTerm = <span class="number">0</span></span><br><span class="line">        self.last_error = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Windup Guard</span></span><br><span class="line">        <span class="comment"># 积分误差上限</span></span><br><span class="line">        self.windup_guard = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">        self.output = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, feedback_value, current_time=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculates PID value for given reference feedback</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. math::</span></span><br><span class="line"><span class="string">            u(t) = K_p e(t) + K_i \int_&#123;0&#125;^&#123;t&#125; e(t)dt + K_d &#123;de&#125;/&#123;dt&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. figure:: images/pid_1.png</span></span><br><span class="line"><span class="string">           :align:   center</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           Test PID with Kp=1.2, Ki=1, Kd=0.001 (test_pid.py)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        error = self.targetPoint - feedback_value</span><br><span class="line"></span><br><span class="line">        self.current_time = current_time <span class="keyword">if</span> current_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> time.time()</span><br><span class="line">        delta_time = self.current_time - self.last_time</span><br><span class="line">        delta_error = error - self.last_error</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> delta_time &gt;= self.sample_interval:</span><br><span class="line">            self.PTerm = self.Kp * error</span><br><span class="line">            self.ITerm += error * delta_time</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.ITerm &lt; -self.windup_guard:</span><br><span class="line">                self.ITerm = -self.windup_guard</span><br><span class="line">            <span class="keyword">elif</span> self.ITerm &gt; self.windup_guard:</span><br><span class="line">                self.ITerm = self.windup_guard</span><br><span class="line"></span><br><span class="line">            self.DTerm = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> delta_time &gt; <span class="number">0</span>:</span><br><span class="line">                self.DTerm = delta_error / delta_time</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Remember last time and last error for next calculation</span></span><br><span class="line">            self.last_time = self.current_time</span><br><span class="line">            self.last_error = error</span><br><span class="line"></span><br><span class="line">            self.output = self.PTerm + self.Ki * self.ITerm + self.Kd * self.DTerm</span><br><span class="line">        self.PTerm_list.append(self.PTerm)</span><br><span class="line">        self.ITerm_list.append(self.Ki * self.ITerm)</span><br><span class="line">        self.DTerm_list.append(self.Kd * self.DTerm)</span><br><span class="line">        <span class="keyword">return</span> self.output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_values</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.PTerm_list, self.ITerm_list, self.DTerm_list</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_target</span>(<span class="params">self, target_value</span>):</span><br><span class="line">        self.targetPoint = target_value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_kp</span>(<span class="params">self, proportional_gain</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Determines how aggressively the PID reacts to the current error with setting Proportional Gain&quot;&quot;&quot;</span></span><br><span class="line">        self.Kp = proportional_gain</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_ki</span>(<span class="params">self, integral_gain</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Determines how aggressively the PID reacts to the current error with setting Integral Gain&quot;&quot;&quot;</span></span><br><span class="line">        self.Ki = integral_gain</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_kd</span>(<span class="params">self, derivative_gain</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Determines how aggressively the PID reacts to the current error with setting Derivative Gain&quot;&quot;&quot;</span></span><br><span class="line">        self.Kd = derivative_gain</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_windup</span>(<span class="params">self, windup</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Integral windup, also known as integrator windup or reset windup,</span></span><br><span class="line"><span class="string">        refers to the situation in a PID feedback controller where</span></span><br><span class="line"><span class="string">        a large change in setpoint occurs (say a positive change)</span></span><br><span class="line"><span class="string">        and the integral terms accumulates a significant error</span></span><br><span class="line"><span class="string">        during the rise (windup), thus overshooting and continuing</span></span><br><span class="line"><span class="string">        to increase as this accumulated error is unwound</span></span><br><span class="line"><span class="string">        (offset by errors in the other direction).</span></span><br><span class="line"><span class="string">        The specific problem is the excess overshooting.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.windup_guard = windup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_sample_interval</span>(<span class="params">self, sample_interval</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;PID that should be updated at a regular interval.</span></span><br><span class="line"><span class="string">        Based on a pre-determined sampe time, the PID decides if it should compute or return immediately.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.sample_interval = sample_interval</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-测试脚本"><a href="#2-测试脚本" class="headerlink" title="2. 测试脚本"></a>2. 测试脚本</h2><p>模拟通过单环PID输出角速度来控制电机角度，因为是模拟，故假定角速度可以突变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pid <span class="keyword">import</span> PID</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># from scipy.interpolate import spline</span></span><br><span class="line"><span class="keyword">from</span> scipy.interpolate <span class="keyword">import</span> BSpline, make_interp_spline  <span class="comment"># Switched to BSpline</span></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">114514</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟电机，可以设置角速度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Motor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, angle=<span class="number">0</span>, angular_velocity=<span class="number">0</span></span>):</span><br><span class="line">        <span class="comment"># 角速度控制在[-pi,pi]</span></span><br><span class="line">        <span class="comment"># 角度范围[-pi,pi]</span></span><br><span class="line">        self.angle = angle</span><br><span class="line">        self.angular_velocity = angular_velocity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, step=<span class="number">1</span></span>):</span><br><span class="line">        <span class="keyword">if</span> self.angular_velocity &gt;= np.pi:</span><br><span class="line">            self.angular_velocity = np.pi</span><br><span class="line">        <span class="keyword">elif</span> self.angular_velocity &lt;= -np.pi:</span><br><span class="line">            self.angular_velocity = -np.pi</span><br><span class="line">        <span class="comment"># 添加了点随机扰动</span></span><br><span class="line">        self.angle += self.angular_velocity * step + np.random.uniform(-np.pi / <span class="number">100</span>, np.pi / <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span> self.angle &gt;= <span class="number">0</span>:</span><br><span class="line">            self.angle = self.angle % np.pi</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.angle = -(np.<span class="built_in">abs</span>(self.angle) % np.pi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_pid</span>(<span class="params">P=<span class="number">0.2</span>, I=<span class="number">0.0</span>, D=<span class="number">0.0</span>, L=<span class="number">100</span></span>):</span><br><span class="line"></span><br><span class="line">    pid_controller = PID(P, I, D, current_time=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 设置目标值</span></span><br><span class="line">    pid_controller.set_target(np.pi / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 设置采样间隔</span></span><br><span class="line">    pid_controller.set_sample_interval(<span class="number">1</span>)</span><br><span class="line">    motor = Motor()</span><br><span class="line">    END = L</span><br><span class="line">    <span class="comment"># 电机当前角度</span></span><br><span class="line">    feedback = motor.angle</span><br><span class="line"></span><br><span class="line">    feedback_list = []</span><br><span class="line">    time_list = []</span><br><span class="line">    target_point_list = []</span><br><span class="line">    output_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, END):</span><br><span class="line">        <span class="comment"># pid_controller.set_target(np.pi * np.sin(i / 10))</span></span><br><span class="line">        <span class="comment"># 获取PID控制器输出的角速度</span></span><br><span class="line">        output = pid_controller.update(feedback, current_time=i)</span><br><span class="line">        <span class="comment"># 将角速度作用于电机</span></span><br><span class="line">        motor.angular_velocity = output</span><br><span class="line">        <span class="comment"># 按照当前设置的角速度更新电机角度</span></span><br><span class="line">        motor.update()</span><br><span class="line">        <span class="comment"># 获取更新后电机的新角度</span></span><br><span class="line">        feedback = motor.angle</span><br><span class="line">        <span class="comment"># time.sleep(0.02)</span></span><br><span class="line">        feedback_list.append(feedback)</span><br><span class="line">        output_list.append(output)</span><br><span class="line">        target_point_list.append(pid_controller.targetPoint)</span><br><span class="line">        time_list.append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 存储一些中间变量方便查看    </span></span><br><span class="line">    PTerm_list, ITerm_list, DTerm_list = pid_controller.get_values()</span><br><span class="line">    time_sm = np.array(time_list)</span><br><span class="line">    <span class="comment"># 插值到300个点，方便绘图展示</span></span><br><span class="line">    time_smooth = np.linspace(np.<span class="built_in">min</span>(time_sm), np.<span class="built_in">max</span>(time_sm), <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据time_smooth 给中间变量也进行插值</span></span><br><span class="line">    feedback_smooth = make_interp_spline(time_list, feedback_list)(time_smooth)</span><br><span class="line">    PTerm_smooth = make_interp_spline(time_list, PTerm_list)(time_smooth)</span><br><span class="line">    ITerm_smooth = make_interp_spline(time_list, ITerm_list)(time_smooth)</span><br><span class="line">    DTerm_smooth = make_interp_spline(time_list, DTerm_list)(time_smooth)</span><br><span class="line">    output_smooth = make_interp_spline(time_list, output_list)(time_smooth)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择角度变量进行绘图</span></span><br><span class="line">    plt.plot(time_smooth, feedback_smooth)</span><br><span class="line">    plt.plot(time_list, target_point_list)</span><br><span class="line">    plt.xlim((<span class="number">0</span>, L))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;time (s)&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;PID (PV)&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;TEST PID&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test_pid(<span class="number">0.3</span>, <span class="number">0.001</span>, <span class="number">0.001</span>, L=<span class="number">500</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1-模拟结果"><a href="#2-1-模拟结果" class="headerlink" title="2.1 模拟结果"></a>2.1 模拟结果</h3><p>将目标值设为$\pi/2$ </p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202303171431787.png" alt=""></p><p>目标值设置成随时间变化<code>pid_controller.set_target(np.pi * np.sin(i / 10))</code></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202303171440340.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【注意力机制】 通道注意力机制以及3D卷积</title>
      <link href="/2023/03/02/%E9%80%9A%E9%81%93%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/03/02/%E9%80%9A%E9%81%93%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="通道注意力机制以及3D卷积"><a href="#通道注意力机制以及3D卷积" class="headerlink" title="通道注意力机制以及3D卷积"></a>通道注意力机制以及3D卷积</h1><h2 id="1-SEnet"><a href="#1-SEnet" class="headerlink" title="1. SEnet"></a>1. SEnet</h2><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132106745.webp" alt=""></p><p>SENet的Block单元，图中的Ftr是传统的卷积结构，X和U是Ftr的输入（C’xH’xW’）和输出（CxHxW）。</p><p>SENet增加的部分是U后的结构：对U先做一个Global Average Pooling（图中的Fsq(.)，作者称为Squeeze过程），输出的1x1xC数据再经过两级全连接（图中的Fex(.)，作者称为Excitation过程），最后用sigmoid（论文中的self-gating mechanism）限制到[0，1]的范围，把这个值作为scale乘到U的C个通道上， 作为下一级的输入数据。这种结构的原理是想通过控制scale的大小，把重要的特征增强，不重要的特征减弱，从而让提取的特征指向性更强。</p><p>Excitation部分是用2个全连接来实现 ，第一个全连接把C个通道压缩成了C/r个通道来降低计算量（后面跟了RELU），第二个全连接再恢复回C个通道（后面跟了Sigmoid），r是指压缩的比例。作者尝试了r在各种取值下的性能 ，最后得出结论r=16时整体性能和计算量最平衡。<br>为什么要加全连接层呢？这是为了利用通道间的相关性来训练出真正的scale。一次mini-batch个样本的squeeze输出并不代表通道真实要调整的scale值，真实的scale要基于全部数据集来训练得出，而不是基于单个batch，所以后面要加个全连接层来进行训练。</p><h2 id="2-CBAM"><a href="#2-CBAM" class="headerlink" title="2. CBAM"></a>2. CBAM</h2><h3 id="2-1-CAM"><a href="#2-1-CAM" class="headerlink" title="2.1 CAM"></a>2.1 CAM</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132106528.png" alt=""></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/CAM.svg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChannelAttention</span>(nn.Module):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_planes, ratio=<span class="number">16</span></span>):</span><br><span class="line"><span class="built_in">super</span>(ChannelAttention, self).__init__()</span><br><span class="line">self.avg_pool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">self.max_pool = nn.AdaptiveMaxPool2d(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">self.fc1 = nn.Conv2d(in_planes, in_planes // ratio, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.relu1 = nn.ReLU()</span><br><span class="line">self.fc2 = nn.Conv2d(in_planes // ratio, in_planes, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.sigmoid = nn.Sigmoid()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">avg_out = self.fc2(self.relu1(self.fc1(self.avg_pool(x))))</span><br><span class="line">max_out = self.fc2(self.relu1(self.fc1(self.max_pool(x))))</span><br><span class="line">out = avg_out + max_out</span><br><span class="line"><span class="keyword">return</span> self.sigmoid(out)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    CA = ChannelAttention(<span class="number">32</span>)</span><br><span class="line">    data_in = torch.randn(<span class="number">8</span>,<span class="number">32</span>,<span class="number">300</span>,<span class="number">300</span>)</span><br><span class="line">    data_out = CA(data_in)</span><br><span class="line">    <span class="built_in">print</span>(data_in.shape)  <span class="comment"># torch.Size([8, 32, 300, 300])</span></span><br><span class="line">    <span class="built_in">print</span>(data_out.shape)  <span class="comment"># torch.Size([8, 32, 1, 1])</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="2-2-SAM"><a href="#2-2-SAM" class="headerlink" title="2.2 SAM"></a>2.2 SAM</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132106729.png" alt=""></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/SAM.svg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpatialAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size=<span class="number">7</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(SpatialAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> kernel_size <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">7</span>), <span class="string">&#x27;kernel size must be 3 or 7&#x27;</span></span><br><span class="line">        padding = <span class="number">3</span> <span class="keyword">if</span> kernel_size == <span class="number">7</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">2</span>, <span class="number">1</span>, kernel_size, padding=padding, bias=<span class="literal">False</span>)  <span class="comment"># 7,3     3,1</span></span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        avg_out = torch.mean(x, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        max_out, _ = torch.<span class="built_in">max</span>(x, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        x = torch.cat([avg_out, max_out], dim=<span class="number">1</span>)</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> self.sigmoid(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    SA = SpatialAttention(<span class="number">7</span>)</span><br><span class="line">    data_in = torch.randn(<span class="number">8</span>,<span class="number">32</span>,<span class="number">300</span>,<span class="number">300</span>)</span><br><span class="line">    data_out = SA(data_in)</span><br><span class="line">    <span class="built_in">print</span>(data_in.shape)  <span class="comment"># torch.Size([8, 32, 300, 300])</span></span><br><span class="line">    <span class="built_in">print</span>(data_out.shape)  <span class="comment"># torch.Size([8, 1, 300, 300])</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-CBAM"><a href="#2-3-CBAM" class="headerlink" title="2.3 CBAM"></a>2.3 CBAM</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132106724.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChannelAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_planes, ratio=<span class="number">16</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(ChannelAttention, self).__init__()</span><br><span class="line">        self.avg_pool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        self.max_pool = nn.AdaptiveMaxPool2d(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Conv2d(in_planes, in_planes // ratio, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.fc2 = nn.Conv2d(in_planes // ratio, in_planes, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        avg_out = self.fc2(self.relu1(self.fc1(self.avg_pool(x))))</span><br><span class="line">        max_out = self.fc2(self.relu1(self.fc1(self.max_pool(x))))</span><br><span class="line">        out = avg_out + max_out</span><br><span class="line">        <span class="keyword">return</span> self.sigmoid(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpatialAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size=<span class="number">7</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(SpatialAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> kernel_size <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">7</span>), <span class="string">&#x27;kernel size must be 3 or 7&#x27;</span></span><br><span class="line">        padding = <span class="number">3</span> <span class="keyword">if</span> kernel_size == <span class="number">7</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">2</span>, <span class="number">1</span>, kernel_size, padding=padding, bias=<span class="literal">False</span>)  <span class="comment"># 7,3     3,1</span></span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        avg_out = torch.mean(x, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        max_out, _ = torch.<span class="built_in">max</span>(x, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        x = torch.cat([avg_out, max_out], dim=<span class="number">1</span>)</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> self.sigmoid(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBAM</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_planes, ratio=<span class="number">16</span>, kernel_size=<span class="number">7</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(CBAM, self).__init__()</span><br><span class="line">        self.ca = ChannelAttention(in_planes, ratio)</span><br><span class="line">        self.sa = SpatialAttention(kernel_size)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = x * self.ca(x)</span><br><span class="line">        result = out * self.sa(out)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;testing CBAM&#x27;</span>.center(<span class="number">100</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">    torch.manual_seed(seed=<span class="number">20200910</span>)</span><br><span class="line">    cbam = CBAM(<span class="number">32</span>, <span class="number">16</span>, <span class="number">7</span>)</span><br><span class="line">    data_in = torch.randn(<span class="number">8</span>,<span class="number">32</span>,<span class="number">300</span>,<span class="number">300</span>)</span><br><span class="line">    data_out = cbam(data_in)</span><br><span class="line">    <span class="built_in">print</span>(data_in.shape)  <span class="comment"># torch.Size([8, 32, 300, 300])</span></span><br><span class="line">    <span class="built_in">print</span>(data_out.shape)  <span class="comment"># torch.Size([8, 1, 300, 300])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-3D卷积"><a href="#3-3D卷积" class="headerlink" title="3. 3D卷积"></a>3. 3D卷积</h2><h3 id="3-1-2D卷积"><a href="#3-1-2D卷积" class="headerlink" title="3.1 2D卷积"></a>3.1 2D卷积</h3><p>常见的2D卷积。nn.Conv2d()。</p><p>下图展示了<strong>CxHxW</strong>的输入特征，通过2D卷积层，得到<strong>1xHxW</strong>的输出特征的过程</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132106590.png" style="zoom: 50%;" /></p><p>以上图为例，Conv2d卷积核的的尺寸是<strong>3x3xC</strong></p><p>如果输出通道为K，则如下图所示，一共用了K个<strong>3x3xc</strong>的卷积核，卷积层参数量为：Cx3x3xK</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132107178.png" alt=""></p><h3 id="3-2-3D卷积"><a href="#3-2-3D卷积" class="headerlink" title="3.2 3D卷积"></a>3.2 3D卷积</h3><p>假设有一个视频序列，该视频的每一帧都是一张灰度图，只有一个通道，该视频一共有T帧，那么这一个视频可以用如下蓝色数据立方体表示。</p><p>以该灰度视频序列3D特征为例，做<strong>TxHxW</strong>方向上的滑动3D卷积。该<strong>3x3x3</strong>的3D卷积核，在三个方向上滑动得到的一个THW都更小的3D输出特征。</p><p>这种3D卷积我将按如下方式描述：</p><p>只有1组卷积核组，每组卷积核组中只有1个(灰度图通道数为1)<strong>3x3x3</strong>的3D卷积核,卷积计算完得到1个绿色的feature map。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132107112.png" style="zoom: 50%;" /></p><p>更复杂的情况，视频序列含有T帧图像，其中的每一帧不是灰度图，而是通道数为C的彩图，比如RGB图像C=3。</p><p>那么则可以将下图3D卷积按如下方式描述：</p><p>有K组卷积核组，每个卷积核组中有C个<strong>3x3x3</strong>的3D卷积核。第i个卷积核组卷积得到1个绿色feature map,其中1&lt;=i&lt;=k。一共有K组，故生成K个绿色feature map。</p><p>对于任意1组卷积核组内，按照如下方式进行卷积计算，将1个通道的每一帧拼接构成一个蓝色立方体，一共有C个通道故有C个蓝色立方体，每个通道配备一个<strong>3x3x3</strong>的卷积核进行卷积，则一共有C个<strong>3x3x3</strong>的卷积核。组内C个卷积核与其对应的蓝色立方体进行卷积，得到C个小一号的绿色立方体，将这C个绿色立方体相加得到该组卷积核的输出。</p><p>因为一共有K组，所以将任意1组卷积核组的操作进行K次，得到K个绿色立方体feature map。综上，参数不相同的<strong>3x3x3</strong>卷积核一共有<strong>CxK</strong>个。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132107713.png" alt=""></p><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h2><p><a href="https://blog.csdn.net/m0_46653437/article/details/114829275?ops_request_misc=%7B%22request%5Fid%22%3A%22164922777516780357263083%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=164922777516780357263083&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114829275.142^v5^pc_search_result_control_group,157^v4^new_style&amp;utm_term=通道注意力机制&amp;spm=1018.2226.3001.4187">注意力机制（通道注意机制、空间注意力机制、CBAM、SELayer）<em>敲代码的小风的博客-CSDN博客</em>通道注意力机制</a></p><p><a href="https://blog.csdn.net/abbcdc/article/details/123332063?spm=1001.2014.3001.5506">一文教你搞懂2D卷积和3D卷积_littlepeni的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/njuptalex/article/details/110124538"> 一文搞定3D卷积_三维卷积过程_Alex丶Chen的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习，注意力机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【标签分配】OTA阅读笔记</title>
      <link href="/2023/02/15/OTA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/OTA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="OTA阅读笔记"><a href="#OTA阅读笔记" class="headerlink" title="OTA阅读笔记"></a>OTA阅读笔记</h1><p>OTA: Optimal Transport Assignment for Object Detection</p><h2 id="1-什么是标签分配"><a href="#1-什么是标签分配" class="headerlink" title="1. 什么是标签分配"></a>1. 什么是标签分配</h2><p>为了训练目标检测器，需要为每个<code>anchor</code> 分配 <code>cls</code> 和 <code>reg</code> 目标，这个过程称为标签分配或者正采样。</p><p>cls指分类置信度，reg指检测框的偏移量。</p><p>通常基于Anchor的目标检测器会生成大量的预先定义好的Anchor,这些Anchor的数量是要远多于ground truth box的数量的。</p><p>以YOLOv3为例，每一个gt box最终都会有一个对应的Anchor，找到自己对应的gt box的Anchor算作正样本，没有找到的，比如Anchor坐标处在背景当中的算作负样本，另外有一部分会被直接忽略。</p><p>标签分配：三个特征图一共 8 × 8 × 3 + 16 × 16 × 3 + 32 × 32 × 3 = 4032 个anchor。</p><p>正例：任取一个ground truth，与4032个anchor全部计算IOU，IOU最大的anchor，即为正例。并且一个anchor，只能分配给一个ground truth。例如第一个ground truth已经匹配了一个正例anchor，那么下一个ground truth，就在余下的4031个anchor中，寻找IOU最大的anchor作为正例。ground truth的先后顺序可忽略。正例产生置信度loss、检测框loss、类别loss。标签为对应的ground truth标签（需要反向编码，使用真实的(x, y, w, h)计算出(tx, ty, tw, th) ）；类别标签对应类别为1，其余为0；置信度标签为1。</p><p>负例：正例除外（特殊情况：与ground truth计算后IOU最大的anchor，但是IOU小于阈值，仍为正例），与全部ground truth的IOU都小于阈值（0.5）的anchor，则为负例。负例只有置信度产生loss，置信度标签为0。<br>忽略样例：正例除外，与任意一个ground truth的IOU大于阈值（论文中使用0.5）的anchor，则为忽略样例。忽略样例不产生任何loss。<br>这样产生的问题是：一个GT只分配一个anchor来进行预测，存在正样本太少的问题，在后面的工作中例如FCOS已经证明了，增加高质量的正样本数量，有利于检测模型的学习。</p><h2 id="2-为什么提出OTA"><a href="#2-为什么提出OTA" class="headerlink" title="2. 为什么提出OTA?"></a>2. 为什么提出OTA?</h2><p>使用人工规则的分配方法，无法考虑尺寸、形状或边界遮挡的差异性。</p><p>当处理模糊标签时 (一个anchor可能对应多个目标)，对其分配任何一个标签都可能对网络学习产生负面影响。</p><p>OTA就是解决上述问题，以获得全局最优的分配策略。</p><h2 id="3-OTA方法"><a href="#3-OTA方法" class="headerlink" title="3. OTA方法"></a>3. OTA方法</h2><h3 id="3-1-最优传输问题-OT问题-回顾"><a href="#3-1-最优传输问题-OT问题-回顾" class="headerlink" title="3.1 最优传输问题(OT问题)回顾"></a>3.1 最优传输问题(OT问题)回顾</h3><p>松弛的蒙日问题</p><p> <img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164703284-644792148.png" alt="img"></p><p>Kantorovich Relaxation的最优运输求解公式定义如下：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164713992-32805890.png" alt="img"></p><p>其中P表示符合所有行求和为向量a，所有列求和为向量b的一个映射。Pi,j表示从第i行映射到第j行的元素值，Ci,j表示完成Pi,j元素映射（或者说是运输）的运输代价。</p><h3 id="3-2-Optimal-Transport"><a href="#3-2-Optimal-Transport" class="headerlink" title="3.2 Optimal Transport"></a>3.2 Optimal Transport</h3><p>假设第$i$个<strong>supplier</strong>拥有$s_i$个货物，第$j$个<strong>demander</strong>需要$d_j$个货物。</p><p>货物从<strong>supplier</strong> $i$运到<strong>demander</strong> $j$的成本为$c_{i,j}$。</p><p>目标是找到最佳运输方案$\pi^* = \pi_{i,j}|i = 1,2,…,m,j = 1,2,…,n$，可以让总的运输cost最低。</p><script type="math/tex; mode=display">\begin{gathered}\min _\pi \sum_{\mathrm{i}=1}^{\mathrm{m}} \sum_{\mathrm{j}=1}^{\mathrm{n}} \mathrm{c}_{\mathrm{ij}} \pi_{\mathrm{ij}} \\\text { s.t. } \sum_{\mathrm{i}=1}^{\mathrm{m}} \pi_{\mathrm{ij}}=\mathrm{d}_{\mathrm{j}}, \sum_{\mathrm{j}=1}^{\mathrm{n}} \pi_{\mathrm{ij}}=\mathrm{s}_{\mathrm{i}}, \sum_{\mathrm{i}=1}^{\mathrm{m}} \mathrm{s}_{\mathrm{i}}=\sum_{\mathrm{j}=1}^{\mathrm{n}} \mathrm{d}_{\mathrm{j}} \\\pi_{\mathrm{ij}} \geq 0, \mathrm{i}=1,2, \ldots, \mathrm{m}, \mathrm{j}=1,2, \ldots, \mathrm{n}\end{gathered}</script><p>上述问题可以使用 <code>Sinkhorn-Knopp</code>算法来求解。</p><h3 id="3-3-OTA思路"><a href="#3-3-OTA思路" class="headerlink" title="3.3 OTA思路"></a>3.3 OTA思路</h3><p>为了得到全局最优的分配策略，OTA方法提出将标签分配问题当作 Optimal Transport (OT) 问题。<br>具体来讲：</p><p>将每个gt当作可以提供一定数量<code>labels</code>的<code>supplier</code>，而每个<code>anchor</code>可以看作是需要唯一<code>label</code>的 <code>demander</code>，如果某个<code>anchor</code>从 <code>gt</code> 那儿获得足够的 <code>label</code>，那么这个 <code>anchor</code>就是此 <code>gt</code> 的一个正样本。</p><p>因为有很多<code>anchor</code>是负样本，所以还需引入另一个<code>background</code>供应商，专门为<code>anchor</code>提供 <code>negative</code> 标签，<br>问题目标是 <code>supplier</code>如何分配 <code>label</code> 给<code>demander</code>，可以让 <code>cost</code> 最低。其中 cost 的定义为：</p><ul><li>对于每个anchor-gt pair，cost 为 pair-wise cls loss 和 pair-wise reg loss的加权和。</li><li>对于每个anchor-background pair，cost 为 pair-wise cls loss这一项。</li></ul><p><img src="https://img-blog.csdnimg.cn/bffa2e65decd4446b5f338c8cabe4176.png?x-oss-process=image" alt=""></p><p>如上图所示，一张两个人骑马的图片，这张图片包含有四个gt box，其中彩色的点代表一些以该点为中心点的Anchor。我们要为这些彩色的点作标签分配，或者说正负样本匹配。</p><p>OTA算法的目的就是要通过对Cost Matrix矩阵使用Sinkhorn-Knopp最优传输迭代算法，找到一个使得”运输代价”Cost最小的一个传输矩阵$\pi$。传输矩阵$\pi$的形式，还是以上图为例，GT1给绿色点分配的label数量为0.9，给其他点分配的label数量则较少。</p><h3 id="3-4-OT-for-Label-Assignment"><a href="#3-4-OT-for-Label-Assignment" class="headerlink" title="3.4 OT for Label Assignment"></a>3.4 OT for Label Assignment</h3><p>回到标签分配问题，对于一张图片，假设有 $m$ 个 gt 目标和  $n$ 个 anchors:</p><ul><li>每个gt拥有$k$个positive lables,即$S_i = k;i = 1,2,…,m$</li><li>每个anchor需要一个lablel，即$d_j = 1;j = 1,2,…,n$</li></ul><p>将一个<code>positive label</code> 从 $gt<em>i$运到<code>anchor</code>$a_j$的成本为$c^{fg}</em>{ij}$,其可以表示为:</p><script type="math/tex; mode=display">c^{fg}_{ij} = L_{cls}(P^{cls}_j(\theta),G^{cls}_i) + \alpha L^{reg}(P^{box}_j(\theta),G^{box}_i)</script><p>式中：</p><p>$P^{cls}_j$和$P_j^{cls}$分别表示对anchor $a_j$预测的<code>cls score</code>和<code>bbox</code>;</p><p>$G_i^{cls}$和$G_i^{box}$分别表示对$gt_i$的<code>cls</code>和<code>bbox</code>;</p><p>$L<em>{cls}和L</em>{box}$分别表示<code>cross entropy loss</code>和<code>IoU Loss</code>;</p><p>$\alpha$是2个Loss的平衡系数</p><p>此外很多anchor是负样本，所以还有一个background supplier，将一个negative label 从background supplier 运到 anchor $a_j$的成本为$c_j^{bg}$，其可以表示为:</p><script type="math/tex; mode=display">c_j^{bg} = L_{cls}(P_j^{cls}(\theta),\phi)</script><p>可以计算出negative lables的总数为：$ n-m\times k$所以$s_i$更新为：</p><script type="math/tex; mode=display">s_i=\left\{\begin{aligned}k &  & i\leq m \\n - m\times k &  & otherwise\end{aligned}\right.</script><h2 id="4-OTA实施细节"><a href="#4-OTA实施细节" class="headerlink" title="4. OTA实施细节"></a>4. OTA实施细节</h2><p>为了便于理解，我们假设：</p><ul><li>一张图片上有 3个目标框，即 3个ground truth</li><li>项目有 2个检测类别，比如 cat/dog</li><li>网络输出1000个预测框，其中只有少部分是正样本，绝大多数是负样本<br><code>bboxes_preds_per_image</code> 是候选检测框的信息，维度是<code>[1000，4]</code>。预测框的四个坐标。</li></ul><p><code>obj_preds</code> 是目标分数(object score)，维度是 <code>[1000，1]</code>。预测框是前景还是背景。</p><p><code>cls_preds</code> 是类别分数，维度是 <code>[1000，2]</code>。预测框的2个检测类别的one-hot。</p><p>训练网络需要知道这 1000个预测框的标签，而如何分配标签呢？</p><p>先附一张原论文描述的整体流程图</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dc09f6578e82b4cdd7ae212e47a7b60b.png" alt=""></p><p>使用OTA方法，可以分为4步，具体做法如下：</p><h4 id="step1-生成cost矩阵"><a href="#step1-生成cost矩阵" class="headerlink" title="step1: 生成cost矩阵"></a>step1: 生成cost矩阵</h4><hr><p>OTA方法分配标签是基于cost的，因为有3个目标框和1000个预测框，所以需要生成 3 × 1000 3\times 10003×1000 的 cost matrix，对于目标检测任务，cost 组成为位置损失和类别损失，计算方法如下：</p><ol><li>定位损失</li></ol><p>计算 <code>3个目标框，和 1000个候选框</code>，得到<code>每个目标框和 1000 个预测框之间的 iou</code>（pair_wise_ious)。</p><p>再通过 <code>-torch.log</code> 计算得到定位损失，即 pair_wise_iou_loss，向量维度为<code>[3, 1000]</code>。3 是 3个真实框，每个都计算1000个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair_wise_ious=bboxes_iou(gt_bboxes_per_image,bboxes_perds_per_image,<span class="literal">False</span>)</span><br><span class="line">pair_wise_ious_loss=-torch.log(pair_wise_ious+<span class="number">1e-8</span>)</span><br></pre></td></tr></table></figure><ol><li>分类损失</li></ol><p>通过第一行代码，将类别的条件概率（cls_preds：表示分类的概率）和目标的先验概率（obj_preds：是前景的概率）做乘积，得到<code>目标的类别分数</code>(两个乘积得到的)。再通过第二行代码，F.binary_cross_entroy 的处理，得到 3个目标框和1000个预测框 的综合loss值，得到类别损失，即 pair_wise_cls_loss，向量维度为 [3，1000]。3也是 3个真实框。其实这里就是算一个2分类交叉熵，cls_preds 和 真实框的 1 算下。每个真实框算1000次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cls_preds=(cls_preds_.<span class="built_in">float</span>().unsqueeze(<span class="number">0</span>).repeat(num_gt,<span class="number">1</span>,<span class="number">1</span>).sigmoid_()*obj_preds_.unsqueeze(<span class="number">0</span>).repeat(num_gt,<span class="number">1</span>,<span class="number">1</span>).sigmoid_())</span><br><span class="line"></span><br><span class="line">pair_wise_cls_losss=F.binary_cross_entropy(cls_pres_.sqrt_(),gt_cls_per_image,reduction=<span class="string">&#x27;none&#x27;</span>).<span class="built_in">sum</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有了reg_loss和 cls_loss，将<code>两个损失函数加权相加</code>，就可以得到<code>cost成本函数</code>了。</p><p>cost 计算公式如下：</p><script type="math/tex; mode=display">C_{ij} = L_{ij}^{cls} + \lambda L_{ij}^{reg}</script><p>加权系数$\lambda=3$，计算代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cost=pair_wise_cls_loss</span><br><span class="line">  +<span class="number">3.0</span>*pair_wise_ious_loss</span><br><span class="line">  +<span class="number">100000.0</span>*(~is_in_boxes_and_center)</span><br></pre></td></tr></table></figure><h4 id="step2-dynamic-k-estimation"><a href="#step2-dynamic-k-estimation" class="headerlink" title="step2: dynamic_k_estimation"></a>step2: dynamic_k_estimation</h4><hr><p>每个 gt 提供多少正样本，可以理解为“<strong>这个 gt 需要多少个正样本才能让网络更好的训练收敛</strong>”。</p><p>直觉上，每个gt 的大小、尺度和遮挡条件不同，所以其提供的positive albel数量也应该是不同的，如何确定每个gt的正样本数 $k$值呢，论文提供了一个简单的方案，该方法称之为：<code>Dynamic k Estimation</code>，具体做法如下：</p><p><strong>从前面的 pair_wise_ious 中，给每个真实框，挑选 10个iou 最大的预测框。因为前面假定有3个目标，因此这里topk_ious的维度为[3，10]。</strong> 其实这里就是对于每个真实框选出来的 1000 个 IOU 值中选出来十个。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0fbd30b18fa6edb69be4834b7278762a.png" alt=""></p><p>topk_ious 计算代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ious_in_boxes_matrix = pair_wise_ious</span><br><span class="line">n_candidate_k = <span class="built_in">min</span>(<span class="number">10</span>, ious_in_boxes_matrix.size(<span class="number">1</span>))</span><br><span class="line">topk_ious, _ = torch.topk(ious_in_boxes_matrix, n_candidate_k, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>下面通过topk_ious的信息，动态选择候选框。dynamic_k_matching 代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic_ks = torch.clamp(topk_ious.<span class="built_in">sum</span>(<span class="number">1</span>).<span class="built_in">int</span>(), <span class="built_in">min</span>=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>针对每个目标框，计算所有anchor的 iou 值之和，再经过torch.clamp函数，得到最终右面的dynamic_ks值，给目标框1和3各分配3个候选框，给目标框2分配4个候选框。</p><p><img src="https://img-blog.csdnimg.cn/5d201e39c3c64f0990988b74f0eb18e7.png?x-oss-process=image#pic_center" alt=""></p><h4 id="step3-Sinkhorn-Knopp-Iteration-求解-cost-矩阵获得-标签分配方案"><a href="#step3-Sinkhorn-Knopp-Iteration-求解-cost-矩阵获得-标签分配方案" class="headerlink" title="step3: Sinkhorn-Knopp Iteration 求解 cost 矩阵获得 标签分配方案"></a>step3: Sinkhorn-Knopp Iteration 求解 cost 矩阵获得 标签分配方案</h4><hr><p>有了cost矩阵,$c$,supplying vector $s \in R^{m+1}$,demanding vector $d \in R^n$,因此可以通过现有的最有传输迭代算法Sinkhorn-Knopp Iteration，对该OT问题进行求解,从而得到最优运输方案$\pi ^<em> \in R^{(m+1) \times n}$。在得到$\pi ^ </em>$之后，将每个anchor分配给运送labels 量最大的supplier(真实框)，从而解码出相应的标签分配方案。</p><h4 id="step3-得到matching-matrix（SimOTA中采用的简化版本）"><a href="#step3-得到matching-matrix（SimOTA中采用的简化版本）" class="headerlink" title="step3: 得到matching_matrix（SimOTA中采用的简化版本）"></a>step3: 得到matching_matrix（SimOTA中采用的简化版本）</h4><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> gt_idx <span class="keyword">in</span> <span class="built_in">range</span>(num_gt):</span><br><span class="line">    _, pos_idx = torch.topk(cost[gt_idx], k=dynamic_ks[gt_idx], largest=<span class="literal">False</span>)</span><br><span class="line">    matching_matrix[gt_idx][pos_idx] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>针对每个目标框挑选相应的 <strong>cost值最低的一些候选框</strong>。比如右面的<code>matching_matrix</code>中，<code>cost</code>值最低的一些位置，数值为1，其余位置都为0。</p><p>因为目标框1和3，<code>dynamic_ks</code>值都为3，因此<code>matching_matrix</code>的第一行和第三行，有3个1。而目标框2，<code>dynamic_ks</code>值为4，因此<code>matching_matrix</code>的第二行，有4个1。</p><p><img src="https://img-blog.csdnimg.cn/830952fa5c7c44c0b4d8081e0cfab8b9.png?x-oss-process=image#pic_center" alt=""></p><h4 id="step4-过滤不同gt-box共用的anchor候选框"><a href="#step4-过滤不同gt-box共用的anchor候选框" class="headerlink" title="step4: 过滤不同gt box共用的anchor候选框"></a>step4: 过滤不同gt box共用的anchor候选框</h4><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">anchor_matching_gt = matching_matrix.<span class="built_in">sum</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (anchor_matching_gt &gt; <span class="number">1</span>).<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">    _, cost_argmin = torch.<span class="built_in">min</span>(cost[:, anchor_matching_gt &gt; <span class="number">1</span>], dim=<span class="number">0</span>)</span><br><span class="line">    matching_matrix[:, anchor_matching_gt &gt; <span class="number">1</span>] *= <span class="number">0</span></span><br><span class="line">    matching_matrix[cost_argmin, anchor_matching_gt &gt; <span class="number">1</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>matching_matrix</code>种第5列有两个1，这说明第5列所对应的候选框，被目标检测框1和2都进行关联。</p><p><img src="https://img-blog.csdnimg.cn/90b418bc35094d49bea23d5be1bc54ac.png?x-oss-process=image#pic_center" alt=""></p><p>因此对这两个位置，还要使用<code>cost</code>值进行对比，<strong>选择较小的值</strong>，再进一步筛选。假设第5列两个位置的值分别为0.4和0.3。</p><p><img src="https://img-blog.csdnimg.cn/97deedee4d0644aa877263d5ca16dba3.png?x-oss-process=image" alt=""></p><p>经过第三行代码，可以找到最小的值是0.3，即<code>cost_min</code>为0.3，所对应的行数，<code>cost_argmin</code>为2。</p><p>经过第四行代码，将<code>matching_matrix</code>第5列都置0。</p><p>再利用第五行代码，将<code>matching_matrix</code>第2行，第5列的位置变为1。</p><p>最终我们可以得到3个目标框，最合适的一些候选框，即<code>matching_matrix</code>中，<strong>所有1所对应的位置</strong></p><p><img src="https://img-blog.csdnimg.cn/a87ebeba25924887954b5dd6cbca73fa.png?x-oss-process=image" alt=""></p><h2 id="5-OTA和SimOTA的区别"><a href="#5-OTA和SimOTA的区别" class="headerlink" title="5. OTA和SimOTA的区别"></a>5. OTA和SimOTA的区别</h2><p>从上面描述可知，OTA 和 SimOTA 都是在经过 step2：dynamic_k_estimation 后，OTA 使用的是 Sinkhorn-Knopp Iteration 求解 cost 矩阵来获得最优的标签分配结果。SimOTA 是采用定义的规则使用 torch.topk 根据 dynamic_k_estimation 得到的 k ，选择 k 个 cost 最小的值，作为分配给真实框的 候选框。</p><p>因此，SimOTA 有两个 topk ：1. step2：dynamic_k_estimation 中的选择比如 10 个 topk_ious。 2. 根据动态获得的 k 选择 k 个候选框。</p><p>OTA 只有 step2：dynamic_k_estimation 中的选择比如 10 个 topk_ious。</p><h2 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6. 参考链接"></a>6. 参考链接</h2><p><a href="https://blog.csdn.net/hymn1993/article/details/127278641">目标检测标签分配之 OTA 和 SimOTA 细节学习<em>wise iou</em>理心炼丹的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/zhicai_liu/article/details/113631706">【目标检测】YOLO系列Anchor标签分配、边框回归（坐标预测）方式、LOSS计算方式_zhicai_liu的博客-CSDN博客_yolo回归坐标</a></p><p><a href="https://blog.csdn.net/weixin_46142822/article/details/124074168">目标检测: 一文读懂 OTA 标签分配<em>标签分配策略</em>大林兄的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/397993315">深入浅出Yolo系列之Yolox核心基础完整讲解 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/odesey/p/16740854.html">【目标检测】OTA: Optimal Transport Assignment for Object Detection 论文翻译和阅读 - cold_moon - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习，目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【最优传输】Optimal Transport最优传输笔记</title>
      <link href="/2023/01/05/Optimal%20Transport%E6%9C%80%E4%BC%98%E4%BC%A0%E8%BE%93/"/>
      <url>/2023/01/05/Optimal%20Transport%E6%9C%80%E4%BC%98%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是最优传输"><a href="#1-什么是最优传输" class="headerlink" title="1. 什么是最优传输"></a>1. 什么是最优传输</h2><p><img src="https://pic3.zhimg.com/80/v2-ce431cdd64777caf348b23bf9342d70a_720w.webp" alt="img" style="zoom:150%;" /></p><p><img src="https://pic3.zhimg.com/80/v2-ec5c9d7a79e102ba85073d2c49b7cbda_720w.webp" alt="img" style="zoom:150%;" /></p><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><h3 id="3-1-离散测度-Discrete-measures"><a href="#3-1-离散测度-Discrete-measures" class="headerlink" title="3.1 离散测度 (Discrete measures)"></a>3.1 离散测度 (Discrete measures)</h3><p>首先，说一下概率向量（或者称为直方图，英文：Histograms， probability vector）的定义：</p><p> <img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164410898-507060181.png" alt="img"></p><p>上述公式的含义：一个长度为n的数组，每个元素的值在[0, 1]之间，并且该数组的和为1，即表示的是一个概率分布向量。</p><p>比如[0.1，0.2，0.3，0.4]就是一个概率向量。</p><p>离散测度：所谓测度就是一个函数，把一个集合中的一些子集（符合上述概率分布向量）对应给一个数[4]。具体公式定义如下：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164427933-960804036.png" alt="img"></p><p>上述公式含义：以$a_i$为概率和对应位置$x_i$的狄拉克δ函数值乘积的累加和。下图很好地阐述了一组不同元素点的概率向量分布：</p><p> <img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164445217-1263610359.png" alt="img"></p><p>上图中红色点是均匀的概率分布，蓝色点是任意的概率分布。点状分布对应是一维数据的概率向量分布，而点云状分布对应的是二维数据的概率向量分布。</p><h3 id="3-2-蒙日-Monge-问题"><a href="#3-2-蒙日-Monge-问题" class="headerlink" title="3.2 蒙日(Monge)问题"></a>3.2 蒙日(Monge)问题</h3><p>蒙日(Monge)问题的定义：找出从一个 measure(测度)到另一个measure的映射，使得所有$c ( x_i , y_j )$的和最小，其中$c$表示映射路线的运输代价，需要根据具体应用定义。蒙日问题具体的定义公式如下：</p><p> <img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164508270-1219532574.png" alt="img"></p><p>对于上述公式的解释可以采用离散测度来解释，对于两个离散测度：</p><p> <img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164519132-1669442012.png" alt="img"></p><p>找到一个n维映射到m维的一个映射<img src="https://img2020.cnblogs.com/blog/927750/202103/927750-20210312164530094-298942662.png" alt="img">，使得</p><p> <img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164541088-1112379002.png" alt="img"></p><p>上述映射的示意图如下：</p><p> <img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164552388-995624370.png" alt="img"></p><p>对于上述的映射公式，结合蒙日问题的定义公式，可以归纳如下：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164603385-1199671036.png" alt="img"></p><p>上述公式的含义：通过这个映射$T(x_i)$的转移，使得转移到$b_j$的所有$a_i$的值的和刚好等于$b_j$（其中要求，所有$a_i$必须转走，而所有$b_j$必须收到预期的货物），即我需要多少就给运输转移多少，不能多也不能少。其中$c()$表示运输代价，$T(x_i)$表示映射的运输方案。</p><h3 id="3-3-Kantorovich-Relaxation-松弛的蒙日问题"><a href="#3-3-Kantorovich-Relaxation-松弛的蒙日问题" class="headerlink" title="3.3 Kantorovich Relaxation (松弛的蒙日问题)"></a>3.3 Kantorovich Relaxation (松弛的蒙日问题)</h3><p>蒙日问题是最优运输的起初最重要的思想，然而其有一个很大的缺点: 从a的所有货物运输到b时，只能采用原始的货物大小进行运算，即不能对原始的货物进行拆开发送到不同目的地。而Kantorovich Relaxation则对蒙日问题进行了松弛处理，即原始的货物可以分开发送到不同目的地，也可以把蒙日问题理解为Kantorovich Relaxation的一个映射运输特例。具体区别可以参考下图[2]。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164631292-910603132.png" alt="img"></p><p>符合Kantorovich Relaxation的映射运输定义公式如下：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164648582-1519254757.png" alt="img"></p><p>区别于蒙日问题要求映射运输的所有$a_i$一对一转走到$b_j$。Kantorovich Relaxation只要求，所有每个$a_i$中获取能够完全转走，可以是只转给一个$b_j$，也可以是多个$b_j$，但是要确保每个$b_j$只需要收取预期要求的货物即可。简单地描述：<strong>行求和对应向量a</strong>, <strong>列向量求和对应向量 b</strong>.具体的传输示例如下：</p><p> <img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164703284-644792148.png" alt="img"></p><p>最后，Kantorovich Relaxation的最优运输求解公式定义如下：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/927750-20210312164713992-32805890.png" alt="img"></p><p>其中P表示符合所有行求和为向量a，所有列求和为向量b的一个映射。Pi,j表示从第i行映射到第j行的元素值，Ci,j表示完成Pi,j元素映射（或者说是运输）的运输代价。</p><h3 id="3-5-最优运输问题求解"><a href="#3-5-最优运输问题求解" class="headerlink" title="3.5 最优运输问题求解"></a>3.5 最优运输问题求解</h3><p><img src="https://pic3.zhimg.com/80/v2-9b0e33a63e25d6ffe9c09c1752c0194e_720w.webp" alt="img"></p><h4 id="3-5-1-熵-Entropic-正则化"><a href="#3-5-1-熵-Entropic-正则化" class="headerlink" title="3.5.1 熵(Entropic)正则化"></a>3.5.1 熵(Entropic)正则化</h4><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20230104193601750.png" alt="image-20230104193601750"></p><p><strong>H</strong>(<strong>P</strong>)即为正则化的代价函数，是整个概念的核心。</p><p>那么加上正则化的最优传输问题则变为</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20230104193652371.png" alt="image-20230104193652371"></p><p>这里的$ε$是个正则化系数，它的大小决定正则化作用的强度，道理和神经网络里的正则化系数是完全一样的。</p><p>那么我们来分析正则化的作用。</p><p>$\sum<em>{i, j} \mathbf{P}</em>{i, j}=1$ 所以 $\log \left(\mathbf{P}_{i, j}\right)&lt;0$ 绝对成立</p><p>同样一个单位的质量转移，如果是分布在少数的$\mathbf{P}<em>{i,j}$上，每个$\mathbf{P}</em>{i,j}$取值较大的情况代价会大于将质量分布在多个$ \mathbf{P}<em>{i,j}$上，每个$\mathbf{P}</em>{i,j}$取值很小的情况。</p><p><strong>换句话说，正则化鼓励利用多数小流量路径的传输，而惩罚稀疏的，利用少数大流量路径的传输，由此达到减少计算复杂度的目的。</strong></p><p><img src="https://img-blog.csdnimg.cn/20190426143557768.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1V0dGVybHlfQm9ua2Vycw==,size_16,color_FFFFFF,t_70" alt="正则化的作用"></p><p>可以看到，在$ε$取值较小时，传输集中使用少数路径，然而当$ε$取值变大，正则化传输的最优解变得更加“扁平”，使用更多的路径进行传输。</p><h4 id="3-5-2-Sinkhorn算法-NIPS-2013"><a href="#3-5-2-Sinkhorn算法-NIPS-2013" class="headerlink" title="3.5.2  Sinkhorn算法 (NIPS, 2013)"></a>3.5.2  Sinkhorn算法 (NIPS, 2013)</h4><p>熵正则化仍然是一个概念，需要一个有效的算法，才能够释放它的潜力。</p><p>得到Sinkhorn算法的第一步在于换一种方式表达正则化后的问题</p><p>正则化后的Kantorovich问题的解可以写为以下形式：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20230104195916512.png" alt="image-20230104195916512"></p><p>其中：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20230104200125174.png" alt="image-20230104200125174"></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20230104200441847.png" alt="image-20230104200441847"></p><p>因为 $P=diag(u)Kdiag(v)$，而且根据之前的 “<strong>行求和对应向量a</strong>, <strong>列向量求和对应向量 b</strong>”的条件，</p><p>所以有:</p><script type="math/tex; mode=display">diag(u) K diag(v)1m=a,diag(v) K^T diag(u)1m=b</script><p>即</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20230104201232084.png" alt="image-20230104201232084"></p><p>综上：P满足$P<em>{i,j} = u_iK</em>{i,j}v_j$，其中 u和v 要满足：$u\odot (Kv) = a$且$v\odot(K^Tu)=b$<br>。</p><p>这里$\odot$是元素对应的乘积。</p><p>这一对等式属于一类叫做matrix scaling的数学问题(matrix scaling problem)，于是可以通过迭代方式求解，这两条等式作为之后迭代的收敛条件。</p><p>初始化：</p><script type="math/tex; mode=display">v^{(0)}=1m</script><p>也就是将v中每个元素都设为1</p><p><strong>每一步先更新u满足左侧等式，再更新v满足右侧等式，最终迭代收敛</strong>，两侧等式同时满足，我们就得到了最优解</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20230104202302693.png" alt="image-20230104202302693"></p><p>收敛后，再计算 P即可。</p><h1 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3. 参考链接"></a>3. 参考链接</h1><p><a href="https://www.cnblogs.com/liuzhen1995/p/14524932.html">最优运输（Optimal Transfort）：从理论到填补的应用 - 舞动的心 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/Hungryof/article/details/110549879">最优传输之浅谈<em>Hungryof的博客-CSDN博客</em>最优传输</a></p><p><a href="https://blog.csdn.net/Utterly_Bonkers/article/details/90746259"> 最优传输-Sinkhorn算法（第九篇）_Utterly Bonkers的博客-CSDN博客_sinkhorn</a></p><p><a href="https://zhuanlan.zhihu.com/p/462458966">最优传输理论 Optimal Transport - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/551134022">Optimal Transport (OT) 最优传输-简介 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/94978686">计算最优传输（Computational Optimal Transport） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网穿透】使用Frp + VNC配置远程桌面杂记</title>
      <link href="/2023/01/04/%E4%BD%BF%E7%94%A8Frp%20+%20VNC%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%9D%82%E8%AE%B0/"/>
      <url>/2023/01/04/%E4%BD%BF%E7%94%A8Frp%20+%20VNC%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一-VNC部分"><a href="#一-VNC部分" class="headerlink" title="一. VNC部分"></a>一. VNC部分</h1><p>参考链接<a href="https://blog.csdn.net/PiQiuNi/article/details/123798298">Jetson nano(Ubuntu18.04) 网线连接电脑，实现VNC远程桌面_PiQiuNi的博客-CSDN博客_jetson nano连接电脑</a></p><p>本文通过网线连接jetson nano(Ubuntu18.04) 与windows电脑，实现了网络共享及VNC远程桌面访问<br>配置Jetson nano (此过程需要连接屏幕及外设)<br>以下内容来自系统自带文档 “README-vnc.txt”</p><p>安装VNC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install vino</span><br></pre></td></tr></table></figure><p>开启VNC服务<br>实现开机自动启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/autostart</span><br><span class="line">cp /usr/share/applications/vino-server.desktop ~/.config/autostart</span><br></pre></td></tr></table></figure><p>配置VNC服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.Vino prompt-enabled false</span><br><span class="line">gsettings set org.gnome.Vino require-encryption false</span><br></pre></td></tr></table></figure><p>设置连接密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.Vino authentication-methods &quot;[&#x27;vnc&#x27;]&quot;</span><br><span class="line">gsettings set org.gnome.Vino vnc-password $(echo -n &#x27;你的密码&#x27;|base64)</span><br></pre></td></tr></table></figure><p>设置无屏幕启动分辨率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/X11/xorg.conf </span><br></pre></td></tr></table></figure><p>在文件末尾插入以下内容（可自行设置分辨率）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Section &quot;Screen&quot;</span><br><span class="line">   Identifier    &quot;Default Screen&quot;</span><br><span class="line">   Monitor       &quot;Configured Monitor&quot;</span><br><span class="line">   Device        &quot;Tegra0&quot;</span><br><span class="line">   SubSection &quot;Display&quot;</span><br><span class="line">       Depth    24</span><br><span class="line">       Virtual 1280 800 # Modify the resolution by editing these values</span><br><span class="line">   EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure><p>重启jetsonnano</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h1 id="二-frp部分"><a href="#二-frp部分" class="headerlink" title="二. frp部分"></a>二. frp部分</h1><p>参考链接<a href="https://blog.csdn.net/y459541195/article/details/102522290">VNC+frp实现远程访问Ubuntu和树莓派_圆滚熊的博客-CSDN博客</a></p><h3 id="搭建方式一：有公网服务器情况下"><a href="#搭建方式一：有公网服务器情况下" class="headerlink" title="搭建方式一：有公网服务器情况下"></a>搭建方式一：有公网服务器情况下</h3><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h3><ol><li><strong>公网服务器一台</strong>（腾讯云，阿里云，华为云等服务器均可）</li><li><strong>内网穿透工具 frp</strong> （免费开源）</li><li><strong>远程控制软件 RealVNC</strong></li></ol><h3 id="2-服务器上部署（服务端）"><a href="#2-服务器上部署（服务端）" class="headerlink" title="2.服务器上部署（服务端）"></a>2.服务器上部署（服务端）</h3><p>首先了解一下frp是什么？<br>frp是一个可用于内部网穿透的高级反向代理应用程序，支持tcp，udp协议，为http和https应用协议提供了额外的能力，并且尝试性支持了点对点穿透。<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132102454.png" alt="在这里插入图片描述"></p><ul><li><strong>第一步</strong>：<strong>下载frp到公网服务器</strong></li></ul><p>登录公网服务器下载frp，frp下载地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a><br>找到对应版本下载<br>（注:可以输入arch，查看cpu架构，云服务和Ubuntu16.0.4都是x86_64处理器架构，所以下载amd64的包）<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103897.png" alt="在这里插入图片描述"><br>这里下载的是当前更新的最新版frp_0.29.0_linux_amd64.tar.gz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103364.png" alt="在这里插入图片描述"><br>可能下载有点慢，等待一会儿</p><ul><li><strong>第二步</strong>：<strong>配置frp</strong></li></ul><p>下载完之后进行解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf frp_0.29.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103706.png" alt="在这里插入图片描述"><br>解压之后，找到frps.ini这个文件，并打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.29.0_linux_amd64</span><br><span class="line">sudo nano frps.ini</span><br></pre></td></tr></table></figure><p>参考frps_full.ini，添加一下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000  </span><br><span class="line"></span><br><span class="line">token = 12345678  </span><br><span class="line"></span><br><span class="line">dashboard_port = 7500 </span><br><span class="line">dashboard_user = admin </span><br><span class="line">dashboard_pwd = admin</span><br><span class="line"></span><br><span class="line">max_pool_count = 5</span><br><span class="line">log_file = ./frps.log  </span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103217.png" alt="在这里插入图片描述"><br>保存，退出。<br>把云服务器的7000,7500等相应的端口放行。我这里的后台管理端口是7600，不是上面的 7500。<br>在当前目录下运行frps:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c ./frps.ini &amp;</span><br></pre></td></tr></table></figure><p>查看7600端口是否在监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ap | grep 7600</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103611.png" alt="在这里插入图片描述"><br>测试后台能否打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#云服务器公网ip + 7600</span><br><span class="line">http://x.x.x.x:7600</span><br></pre></td></tr></table></figure><p>记得x.x.x.x替换为自己公网ip地址，提示输入账户密码，默认admin<br>界面是这样的：<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103341.png" alt="在这里插入图片描述"><br>至此，服务端frp部署成功了</p><h3 id="3-Ubuntu上部署（客户端）"><a href="#3-Ubuntu上部署（客户端）" class="headerlink" title="3. Ubuntu上部署（客户端）"></a>3. Ubuntu上部署（客户端）</h3><ul><li><strong>第一步：Ubuntu打开桌面共享</strong></li></ul><p>这里操作的Ubuntu系统版本是16.0.4<br>搜索出桌面共享，输入sharing<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103980.png" alt="在这里插入图片描述"><br>点击打开“Desktop Sharing”，勾选如下配置：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103789.png" alt="在这里插入图片描述"><br>第3那里要设置访问密码，并记住。</p><ul><li><strong>第二步：配置frpc</strong></li></ul><p>下载frp_0.29.0_linux_amd64.tar.gz，解压后打开frpc.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf frp_0.29.0_linux_amd64.tar.gz</span><br><span class="line">cd frp_0.29.0_linux_amd64</span><br><span class="line">sudo nano frpc.ini</span><br></pre></td></tr></table></figure><p>添加一下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x  </span><br><span class="line">server_port = 7000   </span><br><span class="line">token = 12345678  </span><br><span class="line"></span><br><span class="line">[ubuntu-ssh]         </span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 8085  </span><br><span class="line"></span><br><span class="line">[ubuntu-vnc]        </span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 5900 </span><br><span class="line">remote_port = 5910   </span><br></pre></td></tr></table></figure><p>x.x.x.x要替换为自己的公网ip<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103176.png" alt="在这里插入图片描述"><br>在当前目录下运行frpc.ini文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc -c ./frpc.ini &amp;</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103248.png" alt="在这里插入图片描述"><br>查看一下后台，看看是否在线<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103172.png" alt="在这里插入图片描述"><br>说明部署成功了。</p><ul><li><strong>第三步：加入开机启动</strong></li></ul><p>打开Ubuntu的/etc/rc.local开机启动文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/rc.local</span><br></pre></td></tr></table></figure><p>添加自己的文件启动路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup  x/x/frpc -c x/x/frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>x/x/需要替换掉，如果不知道frpc路径，可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103259.png" alt="在这里插入图片描述"><br>这里的路径如下：<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103527.png" alt="在这里插入图片描述"><br>添加完之后，保存退出。</p><h3 id="4-树莓派上部署（客户端）"><a href="#4-树莓派上部署（客户端）" class="headerlink" title="4.树莓派上部署（客户端）"></a>4.树莓派上部署（客户端）</h3><p>这里用的是树莓派3b+<br>下载的是arm文件：<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103896.png" alt="在这里插入图片描述"><br>下载后解压，同样是打开frpc.ini文件：<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103389.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano frpc.ini</span><br></pre></td></tr></table></figure><p>和上面Ubuntu配置frpc一样，只是改了端口和名称，箭头所示：<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103014.png" alt="在这里插入图片描述"><br>记得云服务器上开放相应端口段，如：5900-6000，22, 80等。</p><p><strong>加入开机启动：</strong><br>刚开始尝试了直接在 rc.local里启动frpc失败。<br>参考这篇博文：<a href="https://blog.csdn.net/zmy12007/article/details/84642081，树莓派开机后让frpc.ini延迟启动即可">https://blog.csdn.net/zmy12007/article/details/84642081，树莓派开机后让frpc.ini延迟启动即可</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano startfrpc.sh</span><br></pre></td></tr></table></figure><p>添加一下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">cd /home/pi/frp_0.29.0_linux_arm</span><br><span class="line">echo &quot;start frpc from shell&quot; &gt;&gt; ./log.txt</span><br><span class="line">sleep 15s</span><br><span class="line">nohup ./frpc -c ./frpc.ini &amp;</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103903.png" alt="在这里插入图片描述"><br>保存退出<br>添加文件权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x startfrpc.sh</span><br></pre></td></tr></table></figure><p>接着打开rc.local文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/rc.local</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;start rc.local&quot; &gt; /home/pi/rc.log</span><br><span class="line"></span><br><span class="line">nohup /bin/bash /home/pi/startfrpc.sh &amp;</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132103909.png" alt="在这里插入图片描述"><br>保存， 退出<br>重启树莓派：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>查看一下后台，看看是否在线：<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104961.png" alt="在这里插入图片描述"><br>至此，树莓派部署成功了。</p><h3 id="5-远程连接"><a href="#5-远程连接" class="headerlink" title="5.远程连接"></a>5.远程连接</h3><p>这里用win10系统连接Ubuntu和树莓派</p><p><strong>5.1 远程连接Ubuntu</strong></p><p><strong>vnc连接：</strong><br>到官网下载vnc:<a href="https://www.realvnc.com/en/connect/download/viewer/相对应版本的vnc">https://www.realvnc.com/en/connect/download/viewer/相对应版本的vnc</a> viewer<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104754.png" alt="在这里插入图片描述"><br>下载后安装，打开VNC Viewer软件<br>输入 <strong>公网ip + 端口号</strong></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104038.png" alt="在这里插入图片描述"><br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104148.png" alt="在这里插入图片描述"><br>这个密码是Ubuntu桌面共享时配置的密码，输入密码后确定，这样就完成了远程了连接<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104328.png" alt="在这里插入图片描述"><br><strong>ssh连接：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort=8085 ubuntu@x.x.x.x</span><br></pre></td></tr></table></figure><p>端口8085，ubuntu 为用户名 ，x.x.x.x为公网ip<br>此时，出现了错误：<br>ssh_exchange_identification: Connection closed by remote host<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104356.png" alt="在这里插入图片描述"><br>查看ssh是否安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ps -e |grep ssh</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104994.png" alt="在这里插入图片描述"><br>结果没有安装，需要安装一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>再次查看sudo ps -e |grep ssh是否安装<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104603.png" alt="在这里插入图片描述"><br>出现了sshd，说明安装成功了。<br>再次尝试ssh:<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104339.png" alt="在这里插入图片描述"><br>出现了错误“ <code>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</code>”，打开<code>C:\Users\Administrator\.ssh</code>下文件，用记事本打开known_hosts，删除选中的部分<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104131.png" alt="在这里插入图片描述"><br>再试一下，输入ubuntu登录密码成功：<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104103.png" alt="在这里插入图片描述"></p><p><strong>5.2 远程连接树莓派</strong></p><p><strong>vnc连接：</strong><br>打开树莓派的vnc和ssh:<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104832.png" alt="在这里插入图片描述"><br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104322.png" alt="在这里插入图片描述"><br>重启树莓派</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启后右上角会出现vnc图标，单击图标打开，选择Option选项<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104032.png" alt="在这里插入图片描述"><br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104157.png" alt="在这里插入图片描述"><br>安全项，进行访问密码配置，记住密码</p><p>在win10上，打来VNC Viewer软件，输入<code>公网ip+端口</code>，再输入访问密码<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104783.png" alt="在这里插入图片描述"><br>远程访问成功<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104556.png" alt="在这里插入图片描述"><br><strong>ssh连接：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort=8086 pi@x.x.x.x</span><br></pre></td></tr></table></figure><p>端口8086，pi为用户名 ，x.x.x.x为公网ip<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132104815.png" alt="在这里插入图片描述"><br>ssh连接成功！</p><h3 id="搭建方式二：无公网服务器情况下"><a href="#搭建方式二：无公网服务器情况下" class="headerlink" title="搭建方式二：无公网服务器情况下"></a>搭建方式二：无公网服务器情况下</h3><p>推荐这种搭建，方便快捷。注意：这里通过win10远程访问Ubuntu和树莓派，win10安装VNC Viewer ，而Ubuntu和树莓派安装的是VNC Server。当然Ubuntu和树莓派也可以安装VNC Viewer来远程访问其它设备，根据自己需求来。</p><h3 id="1-Ubuntu上部署"><a href="#1-Ubuntu上部署" class="headerlink" title="1.Ubuntu上部署"></a>1.Ubuntu上部署</h3><h4 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><p>首先在ubuntu 上安装VNC Server。<br>可以到官网下载：<a href="https://www.realvnc.com/en/connect/download/vnc/linux/">https://www.realvnc.com/en/connect/download/vnc/linux/</a><br>找到相对应的版本。<br>或者通过命令下载安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.realvnc.com/download/file/vnc.files/VNC-Server-<span class="number">6.4</span><span class="number">.1</span>-Linux-x64.deb</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i VNC-Server-<span class="number">6.4</span><span class="number">.1</span>-Linux-x64.deb</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105866.png" alt="在这里插入图片描述"><br>查看运行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep vnc</span><br></pre></td></tr></table></figure><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105900.png" alt="在这里插入图片描述"><br>想要卸载的话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge realvnc-vnc-server</span><br></pre></td></tr></table></figure><p>卸载vnc viewer：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge realvnc-vnc-viewer</span><br></pre></td></tr></table></figure><h4 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h4><p>在图形界面搜索VNC Server，输入Ubuntu管理员密码并打开<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105627.png" alt="在这里插入图片描述"><br>右上角会有个图标，右击选择<code>Licensing...</code>打开<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105453.png" alt="在这里插入图片描述"><br>弹出一个注册界面，没有VNC账号先注册一个</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105059.png" alt="在这里插入图片描述"><br>输入账号密码，点击<code>sign in</code>，出现如下界面：<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105124.png" alt="在这里插入图片描述"><br>上图中填写的密码是你远程连接时候用到的密码，即<code>远程连接密码</code>，不能和vnc账户密码相同，填写一下，点击下一步，选择家庭订阅非商业用途（<code>Home subscription</code>）,接着点击next，起个名字，我这里是<code>ubuntu</code>，接着点击完成即可。<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105981.png" alt="在这里插入图片描述"></p><h4 id="1-3-连接"><a href="#1-3-连接" class="headerlink" title="1.3 连接"></a>1.3 连接</h4><p>接下来我们用win10远程连接乌班图，打开win10上的VNC Viewer<br>登录VNC账号，在地址栏中直接输入<code>ubuntu</code> ，输入<code>远程连接的密码</code><br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105928.png" alt="在这里插入图片描述"><br>这样就连接上了，随时随地的访问远程电脑了。<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105845.png" alt="在这里插入图片描述"></p><h3 id="2-树莓派上部署"><a href="#2-树莓派上部署" class="headerlink" title="2.树莓派上部署"></a>2.树莓派上部署</h3><p>和ubuntu基本类似步骤，树莓派好的一点是已经预装的有vnc server了。<br>可以参考上面搭建方式一中的步骤打开树莓派的VNC<br>选择第一项，下一步<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105194.png" alt="在这里插入图片描述"><br>设置访问名字，可以看到已经有一个存在了。<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105431.png" alt="在这里插入图片描述"><br>点击Apply。完成退出</p><p>在win10中的VNC Viewer 中登录账号就看到了要访问的树莓派。<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202306132105688.png" alt="在这里插入图片描述"><br>如果不想那么费事，或者没有云服务器的，还是推荐第二种搭建方式，整体体验上比第一种要流畅一些。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【目标检测】FCOS学习笔记</title>
      <link href="/2022/12/17/FCOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/17/FCOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="FCOS-学习笔记"><a href="#FCOS-学习笔记" class="headerlink" title="FCOS 学习笔记"></a>FCOS 学习笔记</h1><p>FCOS: Fully Convolutional One-Stage Object Detection</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>目前大多数先进的目标检测模型，例如RetinaNet、SSD、YOLOv3、Faster R-CNN都依赖于预先定义的锚框。相比之下，本文提出的FCOS是anchor box free，而且也是proposal free，就是不依赖预先定义的锚框或者提议区域。通过去除预先定义的锚框，FCOS完全的避免了关于锚框的复杂运算，例如训练过程中计算重叠度，而且节省了训练过程中的内存占用。更重要的是，本文避免了和锚框有关且对最终检测结果非常敏感的所有超参数。由于后处理只采用非极大值抑制(NMS)，所以本文提出的FCOS比以往基于锚框的一阶检测器具有更加简单的优点。</p><h3 id="1-1-锚框的缺点"><a href="#1-1-锚框的缺点" class="headerlink" title="1.1  锚框的缺点"></a>1.1  锚框的缺点</h3><ul><li>检测表现效果对于锚框的尺寸、长宽比、数目非常敏感，因此锚框相关的超参数需要仔细的调节。</li><li>锚框的尺寸和长宽比是固定的，因此，检测器在处理形变较大的候选对象时比较困难，尤其是对于小目标。预先定义的锚框还限制了检测器的泛化能力，因为，它们需要针对不同对象大小或长宽比进行设计。</li><li>为了提高召回率，需要在图像上放置密集的锚框。而这些锚框大多数属于负样本，这样造成了正负样本之间的不均衡。</li><li>大量的锚框增加了在计算交并比时计算量和内存占用。</li></ul><h2 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h2><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641772.png" alt=""></p><p>其中classification对应的是分类损失，regression输出特征维度是<strong>4</strong>对应的是中心点相对于上下左右边界的距离，其中这个距离是在特征图尺度上表示的。</p><p>此外，中心点到四个边界的距离到原图上中心点到四个边界的实际距离存在如下的映射关系。<strong>l,r,t,b</strong>分别各自对应了上下左右的距离，<strong>s</strong>代表了原图到特征图的缩放尺度，还原到原图需要乘上相应的系数<strong>s</strong>。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641766.jpg" alt=""></p><h2 id="3-正负样本的匹配"><a href="#3-正负样本的匹配" class="headerlink" title="3. 正负样本的匹配"></a>3. 正负样本的匹配</h2><h3 id="3-1-正负样本分配"><a href="#3-1-正负样本分配" class="headerlink" title="3.1 正负样本分配"></a>3.1 正负样本分配</h3><p>在传统基于Anchor-Based的检测算法中，通常是将设计的Anchor模板与Gt Box计算IOU，在一定范围内的才算作正样本，但是在FCOS算法舍弃了Anchor之后必须采用新的正负样本分配策略。</p><p>在特征图上的每个点，只要在某个GT Box内就可以算作正样本。2019年早期版本论文当中是采用的右边的策略，但是往往会产生很多低质量的正样本，因此在2020年版本的论文当中，选择使用GT Box内部的一个Sub Box即靠近中心的一个Box，落入Sub Box的点才算正样本，具体计算SubBox按如下公式计算得出，其中系数r需要手动设置。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641889.jpg" alt=""></p><h2 id="4-损失计算"><a href="#4-损失计算" class="headerlink" title="4. 损失计算"></a>4. 损失计算</h2><h3 id="4-1-中心度Centerness"><a href="#4-1-中心度Centerness" class="headerlink" title="4.1 中心度Centerness"></a>4.1 中心度Centerness</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641180.jpg" style="zoom:67%;" /></p><p>通过多级预测之后发现FCOS和基于锚框的检测器之间仍然存在着一定的距离，主要原因是距离目标中心较远的位置产生很多低质量的预测边框。</p><p>在FCOS中提出了一种简单而有效的策略来抑制这些低质量的预测边界框，而且不引入任何超参数。具体来说，FCOS添加单层分支，与分类分支并行，以预测”Center-ness”位置。</p><p>Centerness计算公式：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641936.jpg" alt=""></p><p>该策略之所以能够有效，主要是在训练的过程中我们会约束上述公式中的值，使得其接近于0，这就导致如下图中的蓝色框中的短边能够向黄边靠近，使得分布在目标位置边缘的低质量框能够尽可能的靠近中心。这样的话，在最终使用该网络的过程中，非极大值抑制(NMS)就可以滤除这些低质量的边界框，提高检测性能。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641945.jpg" style="zoom: 67%;" /></p><h3 id="4-2-损失函数"><a href="#4-2-损失函数" class="headerlink" title="4.2 损失函数"></a>4.2 损失函数</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641348.jpg" alt=""></p><h2 id="5-Ambiguity问题"><a href="#5-Ambiguity问题" class="headerlink" title="5. Ambiguity问题"></a>5. Ambiguity问题</h2><p>一个点可能同时被多个GT Box所包含，此时默认分配给面积最小的GT Box</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641691.jpg" style="zoom:67%;" /></p><p>使用FPN结构可以有效降低模糊Ambiguity的样本数。因为大部分发生重叠的样本往往尺度相差都比较大，通过FPN结构在不同尺度的特征图上进行预测的话，可以有效将不同尺度的GT Box分离，比如小面积的GT Box在高深层次的特征图上缩小没了，只留下了大尺度的GT Box.</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641983.jpg" alt=""></p><p>在推理时，center-ness还有另一作用：类别权重. 在NMS时，其排序所用的置信度 sx,y 由center-ness ox,y 和类别概率 px,y 得到：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171641653.webp" alt="img"></p><p>因此，距离GT中心越远的点，其center-ness ox,y越小，所得到的置信度sx,y就越小，因此NMS时会倾向于抑制该点. 此外，如下图所示，在对分类概率应用了center-ness后，具有低IoU但高置信度的检测框也有效的减少了</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171642491.jpg" alt=""></p><h2 id="6-不同尺度的目标与FPN的分配"><a href="#6-不同尺度的目标与FPN的分配" class="headerlink" title="6. 不同尺度的目标与FPN的分配"></a>6. 不同尺度的目标与FPN的分配</h2><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171642465.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【目标检测】Retinanet学习笔记</title>
      <link href="/2022/12/16/Retinanet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/16/Retinanet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Retinanet阅读笔记"><a href="#1-Retinanet阅读笔记" class="headerlink" title="1.Retinanet阅读笔记"></a>1.Retinanet阅读笔记</h2><h3 id="1-1-网络结构"><a href="#1-1-网络结构" class="headerlink" title="1.1 网络结构"></a>1.1 网络结构</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171827792.webp" alt=""></p><p>用Resnet作为特征提取层，之后经过FPN网络进行多尺度的特征融合。<img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171826632.webp" alt=""></p><p>每一个尺度分配9个对应大小的anchor，每个尺度下有3x3个anchor(即3种scale的anchor和3种ratio构成9种anchor)。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171826527.webp" alt=""></p><p>其中A=9，4A代表每个锚点对应的九个不同锚框对应的x,y,w,h，KA代表每个锚框对应的K个种类</p><p>主干特征提取网络如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch.utils.model_zoo <span class="keyword">as</span> model_zoo</span><br><span class="line"><span class="keyword">from</span> torchvision.ops <span class="keyword">import</span> nms</span><br><span class="line"><span class="keyword">from</span> retinanet.utils <span class="keyword">import</span> BasicBlock, Bottleneck, BBoxTransform, ClipBoxes</span><br><span class="line"><span class="keyword">from</span> retinanet.anchors <span class="keyword">import</span> Anchors</span><br><span class="line"><span class="keyword">from</span> retinanet <span class="keyword">import</span> losses</span><br><span class="line"></span><br><span class="line"><span class="comment"># FPN特征图尺度融合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyramidFeatures</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, C3_size, C4_size, C5_size, feature_size=<span class="number">256</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PyramidFeatures, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># upsample C5 to get P5 from the FPN paper</span></span><br><span class="line">        self.P5_1 = nn.Conv2d(C5_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P5_upsampled = nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">        self.P5_2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add P5 elementwise to C4</span></span><br><span class="line">        self.P4_1 = nn.Conv2d(C4_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P4_upsampled = nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">        self.P4_2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add P4 elementwise to C3</span></span><br><span class="line">        self.P3_1 = nn.Conv2d(C3_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P3_2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># &quot;P6 is obtained via a 3x3 stride-2 conv on C5&quot;</span></span><br><span class="line">        self.P6 = nn.Conv2d(C5_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># &quot;P7 is computed by applying ReLU followed by a 3x3 stride-2 conv on P6&quot;</span></span><br><span class="line">        self.P7_1 = nn.ReLU()</span><br><span class="line">        self.P7_2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        C3, C4, C5 = inputs</span><br><span class="line"></span><br><span class="line">        P5_x = self.P5_1(C5)</span><br><span class="line">        P5_upsampled_x = self.P5_upsampled(P5_x)</span><br><span class="line">        P5_x = self.P5_2(P5_x)</span><br><span class="line"></span><br><span class="line">        P4_x = self.P4_1(C4)</span><br><span class="line">        P4_x = P5_upsampled_x + P4_x</span><br><span class="line">        P4_upsampled_x = self.P4_upsampled(P4_x)</span><br><span class="line">        P4_x = self.P4_2(P4_x)</span><br><span class="line"></span><br><span class="line">        P3_x = self.P3_1(C3)</span><br><span class="line">        P3_x = P3_x + P4_upsampled_x</span><br><span class="line">        P3_x = self.P3_2(P3_x)</span><br><span class="line"></span><br><span class="line">        P6_x = self.P6(C5)</span><br><span class="line"></span><br><span class="line">        P7_x = self.P7_1(P6_x)</span><br><span class="line">        P7_x = self.P7_2(P7_x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [P3_x, P4_x, P5_x, P6_x, P7_x]</span><br></pre></td></tr></table></figure><h3 id="1-2-正负样本的匹配"><a href="#1-2-正负样本的匹配" class="headerlink" title="1.2 正负样本的匹配"></a>1.2 正负样本的匹配</h3><p>针对每一个 anchor 与事先标注好的 GT box 进行比对，如果 iou 大于 0.5 则是正样本，如果某个 anchor 与所有的 GT box 的 iou 值都小于 0.4，则是负样本。其余的进行舍弃。</p><h3 id="1-3-损失计算"><a href="#1-3-损失计算" class="headerlink" title="1.3 损失计算"></a>1.3 损失计算</h3><h3 id="4-6-Focal-Loss"><a href="#4-6-Focal-Loss" class="headerlink" title="4.6 Focal Loss"></a>4.6 Focal Loss</h3><p>p_t值越大说明分类情况越好，在正样本y=1的情况下，p_t=p，p值越大说明分类越好，负样本y=0的时候,p_t=1-p，此时p越小说明分类效果越好，不管哪种情况分类效果越好p_t的值就越大</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171827137.webp" alt="image-20221102210517249"></p><p>alpha-balanced focal-loss</p><p>提供了一个超参数alpha，最终形式：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171827618.webp" alt="image-20221102211123507"></p><p>或者：</p><script type="math/tex; mode=display">FL(pt)=−α_t(1−p_t)^γlog(p_t).</script><p>对于 Focal loss，总结如下：</p><ul><li>无论是前景类还是背景类，$p_t$越大，权重$ (1-p_t)^{\gamma}$就越小，即简单样本的损失可以通过权重进行抑制；</li><li>$\alpha_t$用于调节正负样本损失之间的比例，前景类别使用$ \alpha_t$时，对应的背景类别使用$1-\alpha_t$</li></ul><h2 id="2-其他"><a href="#2-其他" class="headerlink" title="2. 其他"></a>2. 其他</h2><p>高斯模糊+拉普拉斯算子求二阶梯度+二值化+闭操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【目标检测】YOLOv1-v3学习笔记</title>
      <link href="/2022/11/18/YOLOv1-v3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/18/YOLOv1-v3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="YOLOv1-v3学习笔记"><a href="#YOLOv1-v3学习笔记" class="headerlink" title="YOLOv1-v3学习笔记"></a>YOLOv1-v3学习笔记</h1><h2 id="1-YOLOv1"><a href="#1-YOLOv1" class="headerlink" title="1.YOLOv1"></a>1.YOLOv1</h2><h3 id="1-1-论文思想"><a href="#1-1-论文思想" class="headerlink" title="1.1 论文思想"></a>1.1 论文思想</h3><p>将一幅图像分成SxS个网格(grid cell)， 如果某个object的中心 落在这个网格 中，则这个网格就负责预测这个object</p><p>每个网格要预测B个bounding box，每个bounding box 除了要预测位置之外，还要附带预测一个confidence值。每个网格还要预测C个类别的分数。</p><p>这个 confidence scores反映了模型对于这个栅格的预测：该栅格是否含有物体，以及这个box的坐标预测的有多准。公式定义如下：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711405.png" alt="znDHAA.png"></p><p>如果这个栅格中不存在一个object，则confidence score应该为0。否则的话，confidence score则为predicted bounding box与 ground truth box之间的 IOU。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711882.png" style="zoom:67%;" /></p><p>YOLO对每个bounding box有5个predictions：x, y, w, h和 confidence。坐标x,y代表了预测的bounding box的中心与栅格边界的相对值。坐标w,h代表了预测的bounding box的width、height相对于整幅图像width,height的比例。confidence就是预测的bounding box和ground truth box的IOU值。</p><p>每一个栅格还要预测C个conditional class probability（条件类别概率）：Pr(Classi|Object)。即在一个栅格包含一个Object的前提下，它属于某个类的概率。我们只为每个栅格预测一组（C个）类概率，而不考虑框B的数量。</p><p>在测试时，我们将条件类概率和单个框的置信预测相乘<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711807.png" alt="image-20221102162243718"></p><h3 id="1-2-网络结构"><a href="#1-2-网络结构" class="headerlink" title="1.2 网络结构"></a>1.2 网络结构</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711559.png" alt="image-20221102162448336"  /></p><p>假设我们的cell数量设置成7x7，那么最后一定输出是一个7x7x30的立方体。</p><p>yolov1每个cell预测两个box，输出形状如下</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711324.png" alt="image-20221102162720040"  /></p><h3 id="1-3-损失函数"><a href="#1-3-损失函数" class="headerlink" title="1.3 损失函数"></a>1.3 损失函数</h3><p>损失函数包含三大块，confidence损失，classes分类损失，bounding box损失</p><p>三个损失是环环相扣的，confidence损失判断是否存在目标物体，如果存在目标那么分类是否准确则依靠classes分类损失，最后检测框定位是否准确则依靠bounding box定位损失。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711235.png" alt="image-20221102162832208"></p><p>相同偏移不同尺度的bounding box理应有不同的损失量，因此对bounding box 的长宽开了根号，这样同样的偏移量在大尺度的检测框下损失会更小一些。  </p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711421.png" alt="image-20221102163759921"></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711022.png" alt=""></p><h3 id="1-4-存在的不足"><a href="#1-4-存在的不足" class="headerlink" title="1.4 存在的不足"></a>1.4 存在的不足</h3><ul><li>YOLO的物体检测精度低于其他state-of-the-art的物体检测系统。</li><li>YOLO容易产生物体的定位错误。</li><li>YOLO对小物体的检测效果不好（尤其是密集的小物体，因为一个栅格只能预测2个物体）。</li></ul><h2 id="2-YOLOv2"><a href="#2-YOLOv2" class="headerlink" title="2. YOLOv2"></a>2. YOLOv2</h2><p>YOLOv2相较于YOLOv1的主要改进有如下几点。</p><h3 id="2-1-锚框卷积"><a href="#2-1-锚框卷积" class="headerlink" title="2.1 锚框卷积"></a>2.1 锚框卷积</h3><p>相较于YOLOv1直接预测bbox的坐标，YOLOv2借鉴FastRCNN引入了anchor机制，不再直接预测anchor的坐标，转而对偏移量offset进行预测。对偏移量进行预测使得网络更加容易学习。</p><p>记得YOLOv1在最后有一个全连接层，这限制了YOLOv1输入图像的尺寸大小，于是在YOLOv2将全连接层去除，这使得YOLOv2的主干网络变成了一个全卷积网络，因此输入图像的大小不受限制。</p><h3 id="2-2-维度聚类"><a href="#2-2-维度聚类" class="headerlink" title="2.2 维度聚类"></a>2.2 维度聚类</h3><p>在FastRCNN中 ，会生成大量的anchor，而anchor的形状 都是通过手工设计的，在YOLOv2中，通过对标注的数据集所有目标的边界框进行k-means聚类来生成主要的anchor形状，根据聚类结果设置anchor。在YOLOv2中根据CoCo数据集聚类，绘制了平均IoU和聚类中心数量K之间的关系，该论文选择的是k=5。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711492.png" style="zoom:67%;" /></p><h3 id="2-3-直接定位预测"><a href="#2-3-直接定位预测" class="headerlink" title="2.3 直接定位预测"></a>2.3 直接定位预测</h3><p>YOLOv2借鉴RPN网络使用Anchor boxes来预测边界框相对于先验框的offsets。边界框的实际中心位置(x,y)需要利用预测的坐标偏移值(t_x,t_y)，先验框的尺度(w_a,h_a)以及中心坐标(x_a,y_a)来计算，这里的x_a和y_a也即是特征图每个位置的中心点：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711320.png" alt="image-20221102171422244"></p><p>上面的公式也是Faster-RCNN中预测边界框的方式。但上面的预测方式是没有约束的，预测的边界框容易向任何方向偏移，因为t_x和t_y不受限制，导致每个位置预测的边界框可以落在图片的任意位置，这就导致模型训练的不稳定性，在训练的时候要花很长时间才可以得到正确的offsets。</p><p>YOLOv2弃用了这种预测方式，而是沿用YOLOv1的方法，就是预测边界框中心点相对于对应cell左上角位置的相对偏移值，为了将边界框中心点约束在当前cell中，使用sigmoid函数处理偏移值，这样预测的偏移值在(0,1)范围内（每个cell的尺度看做1）。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711570.png" alt="image-20221102171210141"></p><p><img src="https://s1.ax1x.com/2022/11/18/znrcDg.png" alt="image-20221102171939437"></p><p>其中 (cx,xy)(cx,xy) 为cell的左上角坐标，如图所示，在计算时每个cell的尺度为1，所以当前cell的左上角坐标为 (1,1)(1,1) 。由于sigmoid函数的处理，边界框的中心位置会约束在当前cell内部，防止偏移过多。而 p_w 和 p_h是先验框的模板宽度与长度，前面说过它们的值也是相对于特征图大小的，在特征图中每个cell的长和宽均为1。这里记特征图的大小为 (W,H)(W,H) （在文中是 (13,13)(13,13) )，这样我们可以将边界框相对于整张图片的位置和大小计算出来（4个值均在0和1之间）</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711943.png" alt="image-20221102172153635"></p><p>需要注意的是，上述四条公式计算的是相对整张图的位置，值仍然是0到1之间。</p><h3 id="2-4-网络结构与细粒度特征"><a href="#2-4-网络结构与细粒度特征" class="headerlink" title="2.4 网络结构与细粒度特征"></a>2.4 网络结构与细粒度特征</h3><p>由于YOLOv1在检测小目标的任务上表现不理想。因为浅层特征图的感受野通常较小，因此浅层特征图往往保留了更多的细节信息，而深层特征图感受野比较大，因此深层特征往往代表了比较高层的抽象的特征，对应到原图上就是一些大范围偏向宏观的特征，而细节信息在传递到深层网络的时候容易产生损失，因此在原有基础上加入PathThrough Layer层，目的在于将浅层特征图保留的细节信息能够传递到深层特征图上，以此来提高YOLOv2的小目标检测能力。</p><p>PassThroughLayer操作示意图</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711778.png" style="zoom:67%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711663.png" alt="image-20221102173024304"></p><h3 id="2-5-多尺度训练"><a href="#2-5-多尺度训练" class="headerlink" title="2.5 多尺度训练"></a>2.5 多尺度训练</h3><p>得益于YOLOv2的全卷积结构，图像输入可以不用固定死尺寸，这使得YOLOv2能够利用多种尺度的图像数据进行训练，提高鲁棒性。</p><h3 id="2-6-WordTree"><a href="#2-6-WordTree" class="headerlink" title="2.6 WordTree"></a>2.6 WordTree</h3><p>用来混合数据集进行训练。</p><h2 id="3-YOLOv3"><a href="#3-YOLOv3" class="headerlink" title="3. YOLOv3"></a>3. YOLOv3</h2><h3 id="3-1-网络结构"><a href="#3-1-网络结构" class="headerlink" title="3.1 网络结构"></a>3.1 网络结构</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711155.png" alt="image-20221102174803985"></p><p>YOLOv3通过k-means聚类k=9，将anchor分为了9种模板，9个不同尺度的anchor模板按照大小被分配给3个不同尺度的特征图，每个特征图对应3种尺度的anchor。单个预测框就包含5个参数[t_x,t_y,t_w,t_h,obj]，CoCo数据集包含有80个类别，以最小的13x13特征层为例，输出tensor的形状就是13x13x[3*(4+1+80)]。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171711258.jpeg" style="zoom:67%;" /></p><p>对于一个输入图像，YOLO3将其映射到3个尺度的输出张量，代表图像各个位置存在各种对象的概率。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712762.jpeg" alt=""></p><p>主干网络darknet53 去掉了maxpooling层，加入了残差块。</p><p>YOLOv3在通过主干网络darknet53之后，通过两次上采样来获得三个不同尺度的特征图，分别是13x13，26x26,52x52大小的特征图，13x13大小的特征图感受野大因此分配大尺度的anchor模板，具体模板尺寸和分配如下表所示。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712971.png" alt=""></p><h3 id="3-3-正负样本的选择"><a href="#3-3-正负样本的选择" class="headerlink" title="3.3 正负样本的选择"></a>3.3 正负样本的选择</h3><p>有别于原文，<a href="https://github.com/ultralytics/yolov5">https://github.com/ultralytics/yolov5</a> 版本的实现。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712525.png" alt="image-20221102190216052"></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712266.png" style="zoom:50%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712937.png" style="zoom:50%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712237.png" style="zoom:50%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712362.png" style="zoom:50%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712539.png" style="zoom:50%;" /></p><h2 id="4-YOLOv3-spp"><a href="#4-YOLOv3-spp" class="headerlink" title="4. YOLOv3 spp"></a>4. YOLOv3 spp</h2><h3 id="4-1-网络结构以及SPP模块"><a href="#4-1-网络结构以及SPP模块" class="headerlink" title="4.1 网络结构以及SPP模块"></a>4.1 网络结构以及SPP模块</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712142.png" alt="image-20221102193656450" style="zoom:50%;" /></p><p>在maxpooling之前进行padding填充以保证池化之后特征图的长宽都不变，最后进行特征维度上的叠加，将不同尺度的特征图进行特征融合。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712941.png" alt=""></p><h3 id="4-2-IoU-Loss"><a href="#4-2-IoU-Loss" class="headerlink" title="4.2 IoU Loss"></a>4.2 IoU Loss</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712271.png" alt="image-20221102203856392"></p><h3 id="4-3-GIoU-Loss"><a href="#4-3-GIoU-Loss" class="headerlink" title="4.3 GIoU Loss"></a>4.3 GIoU Loss</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712864.png" alt="image-20221102203924326"  /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712291.png" alt="image-20221102203950070"></p><h3 id="4-4-DIoU-Loss"><a href="#4-4-DIoU-Loss" class="headerlink" title="4.4 DIoU Loss"></a>4.4 DIoU Loss</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712554.png" alt="image-20221102204345191"></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712806.png" alt="image-20221102205224865"></p><h3 id="4-5-CIoU-Loss"><a href="#4-5-CIoU-Loss" class="headerlink" title="4.5 CIoU Loss"></a>4.5 CIoU Loss</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712445.png" alt="image-20221102204416127"></p><h3 id="4-6-Focal-Loss"><a href="#4-6-Focal-Loss" class="headerlink" title="4.6 Focal Loss"></a>4.6 Focal Loss</h3><p>p_t值越大说明分类情况越好，在正样本y=1的情况下，p_t=p，p值越大说明分类越好，负样本y=0的时候,p_t=1-p，此时p越小说明分类效果越好，不管哪种情况分类效果越好p_t的值就越大</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712942.png" alt="image-20221102210517249"></p><p>alpha-balanced focal-loss</p><p>提供了一个超参数alpha，</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712120.png" alt="image-20221102211123507"></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171712948.png" alt="image-20221102211252319"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> 论文 </tag>
            
            <tag> YOLO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【爬虫】使用baiduspider实现一个异步爬虫</title>
      <link href="/2022/05/14/baiduspideer%E7%88%AC%E8%99%AB/"/>
      <url>/2022/05/14/baiduspideer%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<p>代码仓库：<a href="https://github.com/Kakaluoto/asnyc_spider">https://github.com/Kakaluoto/asnyc_spider</a></p><h1 id="爬虫数据收集"><a href="#爬虫数据收集" class="headerlink" title="爬虫数据收集"></a>爬虫数据收集</h1><h2 id="1-各文件说明"><a href="#1-各文件说明" class="headerlink" title="1. 各文件说明"></a>1. 各文件说明</h2><ul><li>img:存放爬取的图片</li><li>async_spider:异步爬虫类</li><li>data_collector:爬虫执行脚本，从这里启动</li><li>ip_pool:代理IP池,管理可用的代理IP</li><li>image_selector:图片筛选器，将爬取的不符合要求的图片删除</li></ul><h2 id="2-涉及到的一些工具和项目"><a href="#2-涉及到的一些工具和项目" class="headerlink" title="2. 涉及到的一些工具和项目"></a>2. 涉及到的一些工具和项目</h2><ul><li>爬虫工具:  BaiduSpider: <a href="https://github.com/BaiduSpider/BaiduSpider">https://github.com/BaiduSpider/BaiduSpider</a></li><li>代理IP池:  ProxyPool 代理IP池: <a href="https://github.com/jhao104/proxy_pool">https://github.com/jhao104/proxy_pool</a></li><li>随机生成useragent:  pip install fake-useragent</li><li>异步http请求,异步文件读写:  aiohttp, aiofiles, asyncio</li></ul><h2 id="3-相关环境依赖"><a href="#3-相关环境依赖" class="headerlink" title="3. 相关环境依赖"></a>3. 相关环境依赖</h2><h3 id="3-1-安装baiduspider"><a href="#3-1-安装baiduspider" class="headerlink" title="3.1 安装baiduspider"></a>3.1 安装baiduspider</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install baiduspider</span><br></pre></td></tr></table></figure><p>在路径site-packages/baiduspider下找到_<em>init__.py文件源代码第506行的</em></p><p>content = self._get_response(url, proxies)  # original version</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    url = <span class="string">&quot;http://image.baidu.com/search/flip?tn=baiduimage&amp;word=%s&amp;pn=%d&quot;</span> % (</span><br><span class="line">        quote(query),</span><br><span class="line">        (pn - <span class="number">1</span>) * <span class="number">20</span>,</span><br><span class="line">    )</span><br><span class="line">    content = self._get_response(url, proxies)  <span class="comment"># original version</span></span><br><span class="line">    result = self.parser.parse_pic(content)</span><br><span class="line">    result = result <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> self.EMPTY</span><br></pre></td></tr></table></figure><p>添加输入参数verify: bool = True，修改为content = self._get_response(url, proxies,verify: bool = True)</p><p>修改结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    url = <span class="string">&quot;http://image.baidu.com/search/flip?tn=baiduimage&amp;word=%s&amp;pn=%d&quot;</span> % (</span><br><span class="line">        quote(query),</span><br><span class="line">        (pn - <span class="number">1</span>) * <span class="number">20</span>,</span><br><span class="line">    )</span><br><span class="line">    content = self._get_response_by_hy(url, proxies,verify=verify)  <span class="comment"># original version</span></span><br><span class="line">    result = self.parser.parse_pic(content)</span><br><span class="line">    result = result <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> self.EMPTY</span><br></pre></td></tr></table></figure><p>在路径site-packages/baiduspider下找到_spider.py文代码的第63，77，79行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_response</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self, url: <span class="built_in">str</span>, proxies: <span class="built_in">dict</span> = <span class="literal">None</span>, encoding: <span class="built_in">str</span> = <span class="literal">None</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取网站响应，并返回源码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            url (str): 要获取响应的链接</span></span><br><span class="line"><span class="string">            proxies (dict): 代理相关设置</span></span><br><span class="line"><span class="string">            encoding (Union[str, None]): 目标网页编码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            str: 获取到的网站HTML代码</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> proxies <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response = requests.get(url, headers=self.headers, proxies=proxies)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = requests.get(url, headers=self.headers)</span><br></pre></td></tr></table></figure><p>在对应位置添加verify参数,修改为如下结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_response</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self, url: <span class="built_in">str</span>, proxies: <span class="built_in">dict</span> = <span class="literal">None</span>, encoding: <span class="built_in">str</span> = <span class="literal">None</span>, verify=<span class="literal">True</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取网站响应，并返回源码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            url (str): 要获取响应的链接</span></span><br><span class="line"><span class="string">            proxies (dict): 代理相关设置</span></span><br><span class="line"><span class="string">            encoding (Union[str, None]): 目标网页编码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            str: 获取到的网站HTML代码</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> proxies <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response = requests.get(url, headers=self.headers, proxies=proxies, verify=verify)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = requests.get(url, headers=self.headers)</span><br></pre></td></tr></table></figure><p>附自定义header：<br>spider.headers[“Connection”] = “close”<br>此时可以正常使用search_pic</p><h3 id="3-2-windows安装ProxyPool"><a href="#3-2-windows安装ProxyPool" class="headerlink" title="3.2 windows安装ProxyPool"></a>3.2 windows安装ProxyPool</h3><p>主要参考<a href="https://zhuanlan.zhihu.com/p/333433627">python爬虫添加代理ip池ProxyPool (Windows) - 知乎 (zhihu.com)</a></p><h4 id="3-2-1-将代码仓库下载至本地"><a href="#3-2-1-将代码仓库下载至本地" class="headerlink" title="3.2.1 将代码仓库下载至本地"></a>3.2.1 将代码仓库下载至本地</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:jhao104/proxy_pool.git</span><br></pre></td></tr></table></figure><h4 id="3-2-2-安装代理IP池所需依赖"><a href="#3-2-2-安装代理IP池所需依赖" class="headerlink" title="3.2.2 安装代理IP池所需依赖"></a>3.2.2 安装代理IP池所需依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h4 id="3-2-3-安装代理ip存储数据库Redis"><a href="#3-2-3-安装代理ip存储数据库Redis" class="headerlink" title="3.2.3 安装代理ip存储数据库Redis"></a>3.2.3 安装代理ip存储数据库Redis</h4><ul><li><p>下载<a href="https://github.com/microsoftarchive/redis/releases/download/win-3.0.504/Redis-x64-3.0.504.zip">Redis-x64-3.0.504.zip</a>，<a href="https://github.com/microsoftarchive/redis/releases">Releases · microsoftarchive/redis (github.com)</a></p></li><li><p>启动服务：cmd进入文件位置(文件夹地址栏输入cmd)，启动服务</p><p>执行redis-server.exe redis.windows.conf</p></li><li><p>安装服务：另外打开一个cmd窗口，输入命令安装Redis到windows服务</p><p>redis-server —service-install redis.windows.conf</p></li><li><p>启动服务：关闭第一个“启动服务”cmd窗口，另开一个cmd窗口，启动服务</p><p>redis-server —service-start (启动之后这个窗口就可以关闭了)</p></li><li><p>测试是否可以使用：在文件夹下另开一个cmd窗口，输入命令进行测试</p><p>redis-cli.exe -h 127.0.0.1 -p 6379</p><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\Redis\Redis-x64-3.2.100&gt;redis-cli.exe -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></li></ul><p>​        测试成功，Redis安装完成，ProxyPool相关依赖全部完成，接下来修改ProxyPool配置，启动ProxyPool。</p><h4 id="3-2-4-修改Proxypool配置文件setting-py：主要需要修改两处"><a href="#3-2-4-修改Proxypool配置文件setting-py：主要需要修改两处" class="headerlink" title="3.2.4 修改Proxypool配置文件setting.py：主要需要修改两处"></a>3.2.4 修改Proxypool配置文件setting.py：主要需要修改两处</h4><ul><li><p>DB_CONN：Redis数据库位置，注意ip和端口，127.0.0.1:6379</p></li><li><p>FROXY_FEYCHER：可用的代理ip地址，参考github上实时代理源有效信息          </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># ############### server config ###############</span></span><br><span class="line">HOST = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"></span><br><span class="line">PORT = <span class="number">5010</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ############### database config ###################</span></span><br><span class="line"><span class="comment"># db connection uri</span></span><br><span class="line"><span class="comment"># example:</span></span><br><span class="line"><span class="comment">#      Redis: redis://:password@ip:port/db</span></span><br><span class="line"><span class="comment">#      Ssdb:  ssdb://:password@ip:port</span></span><br><span class="line">DB_CONN = <span class="string">&#x27;redis://@127.0.0.1:6379&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># proxy table name</span></span><br><span class="line">TABLE_NAME = <span class="string">&#x27;use_proxy&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ###### config the proxy fetch function ######</span></span><br><span class="line">PROXY_FETCHER = [</span><br><span class="line">    <span class="string">&quot;freeProxy01&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy02&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy03&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy04&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy05&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy06&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy07&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy08&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy09&quot;</span>,</span><br><span class="line">    <span class="string">&quot;freeProxy10&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-4-启动代理池服务：在proxypool文件夹下，分别打开两个cmd窗口运行命令"><a href="#3-2-4-启动代理池服务：在proxypool文件夹下，分别打开两个cmd窗口运行命令" class="headerlink" title="3.2.4 启动代理池服务：在proxypool文件夹下，分别打开两个cmd窗口运行命令"></a>3.2.4 启动代理池服务：在proxypool文件夹下，分别打开两个cmd窗口运行命令</h4><p>启动调度程序：python proxyPool.py schedule</p><p>启动webApi服务：python proxyPool.py server</p><h2 id="4-可以愉快地开始啦"><a href="#4-可以愉快地开始啦" class="headerlink" title="4. 可以愉快地开始啦"></a>4. 可以愉快地开始啦</h2><p>执行python data_collect.py可以爬取图片</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数值分析】Romberg数值积分</title>
      <link href="/2022/04/08/Romberg%E9%BE%99%E8%B4%9D%E6%A0%BC%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/08/Romberg%E9%BE%99%E8%B4%9D%E6%A0%BC%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-原理与公式"><a href="#1-原理与公式" class="headerlink" title="1. 原理与公式"></a>1. 原理与公式</h2><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171707594.png" style="zoom: 80%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171708349.png" style="zoom:80%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171708569.png" style="zoom:80%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171708631.png" style="zoom:80%;" /></p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171709798.png" style="zoom:80%;" /></p><h2 id="2-Python代码实现"><a href="#2-Python代码实现" class="headerlink" title="2. Python代码实现"></a>2. Python代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分法梯形公式</span></span><br><span class="line"><span class="comment"># func:需要积分的函数</span></span><br><span class="line"><span class="comment"># x_min: 积分下限</span></span><br><span class="line"><span class="comment"># x_max: 积分上限</span></span><br><span class="line"><span class="comment"># epoch: 二分次数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_Tn</span>(<span class="params">func, x_min=<span class="number">0</span>, x_max=<span class="number">1</span>, epoch=<span class="number">10</span></span>):</span><br><span class="line">    Tn_list = []</span><br><span class="line">    Tn = <span class="number">0</span></span><br><span class="line">    h0 = x_max - x_min  <span class="comment"># 积分区间的长度,即初始步长</span></span><br><span class="line">    h = h0  <span class="comment"># 每次迭代计算更新h步长</span></span><br><span class="line">    x_half_list = np.array([<span class="number">0</span>])  <span class="comment"># 二分点列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(epoch + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:  <span class="comment"># 初始步长h=h0,取两个端点</span></span><br><span class="line">            Tn = <span class="number">0.5</span> * h * (func(x_min) + func(x_max))  <span class="comment"># T1</span></span><br><span class="line">            Tn_list.append(&#123;<span class="string">&quot;T_%d&quot;</span> % <span class="number">2</span> ** k: Tn.item(), <span class="string">&quot;k&quot;</span>: k&#125;)</span><br><span class="line">            x_half_list = np.array([(x_min + x_max) / <span class="number">2</span>])  <span class="comment"># 计算二分点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Tn = <span class="number">0.5</span> * Tn + <span class="number">0.5</span> * h * np.<span class="built_in">sum</span>(func(x_half_list))  <span class="comment"># 上一轮的T2n = 0.5*Tn + 0.5*h*二分点处的函数值之和</span></span><br><span class="line">            Tn_list.append(&#123;<span class="string">&quot;T_%d&quot;</span> % <span class="number">2</span> ** k: Tn.item(), <span class="string">&quot;k&quot;</span>: k&#125;)</span><br><span class="line">            h = <span class="number">0.5</span> * h  <span class="comment"># 更新步长h为原来的一半</span></span><br><span class="line">            x_half_list = np.linspace(<span class="number">0</span>, <span class="number">2</span> ** k, <span class="number">2</span> ** k, endpoint=<span class="literal">False</span>)  <span class="comment"># 计算下一轮所需的二分点，一共有2^k个点,0,1,2,...2^k-1</span></span><br><span class="line">            x_half_list = h0 * (<span class="number">2</span> * x_half_list + <span class="number">1</span>) / (<span class="number">2</span> ** (k + <span class="number">1</span>)) + x_min  <span class="comment"># X_(k+1/2)=a + (b-a)*(2n+1)/2^(k+1)</span></span><br><span class="line">    <span class="keyword">return</span> Tn_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由梯形公式计算辛普森公式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_Sn</span>(<span class="params">Tn_list</span>):</span><br><span class="line">    Sn_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Tn_list) - <span class="number">1</span>):</span><br><span class="line">        Sn = <span class="built_in">list</span>(Tn_list[i + <span class="number">1</span>].values())[<span class="number">0</span>] * <span class="number">4</span> / <span class="number">3</span> - <span class="built_in">list</span>(Tn_list[i].values())[<span class="number">0</span>] / <span class="number">3</span></span><br><span class="line">        k = <span class="built_in">list</span>(Tn_list[i + <span class="number">1</span>].values())[<span class="number">1</span>]</span><br><span class="line">        Sn_list.append(&#123;<span class="string">&quot;S_%d&quot;</span> % <span class="number">2</span> ** (k - <span class="number">1</span>): Sn, <span class="string">&quot;k&quot;</span>: k&#125;)</span><br><span class="line">    <span class="keyword">return</span> Sn_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由辛普森公式计算柯特斯公式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_Cn</span>(<span class="params">Tn_list=<span class="literal">None</span>, Sn_list=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> Sn_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        Sn_list = compute_Sn(Tn_list)</span><br><span class="line">    Cn_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Sn_list) - <span class="number">1</span>):</span><br><span class="line">        Cn = <span class="built_in">list</span>(Sn_list[i + <span class="number">1</span>].values())[<span class="number">0</span>] * <span class="number">16</span> / <span class="number">15</span> - <span class="built_in">list</span>(Sn_list[i].values())[<span class="number">0</span>] / <span class="number">15</span></span><br><span class="line">        k = <span class="built_in">list</span>(Sn_list[i + <span class="number">1</span>].values())[<span class="number">1</span>]</span><br><span class="line">        Cn_list.append(&#123;<span class="string">&quot;C_%d&quot;</span> % <span class="number">2</span> ** (k - <span class="number">2</span>): Cn, <span class="string">&quot;k&quot;</span>: k&#125;)</span><br><span class="line">    <span class="keyword">return</span> Cn_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由柯特斯公式计算龙贝格公式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_Rn</span>(<span class="params">Tn_list=<span class="literal">None</span>, Cn_list=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> Cn_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        Cn_list = compute_Cn(Tn_list)</span><br><span class="line">    Rn_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Cn_list) - <span class="number">1</span>):</span><br><span class="line">        Rn = <span class="built_in">list</span>(Cn_list[i + <span class="number">1</span>].values())[<span class="number">0</span>] * <span class="number">64</span> / <span class="number">63</span> - <span class="built_in">list</span>(Cn_list[i].values())[<span class="number">0</span>] / <span class="number">63</span></span><br><span class="line">        k = <span class="built_in">list</span>(Cn_list[i + <span class="number">1</span>].values())[<span class="number">1</span>]</span><br><span class="line">        Rn_list.append(&#123;<span class="string">&quot;R_%d&quot;</span> % <span class="number">2</span> ** (k - <span class="number">3</span>): Rn, <span class="string">&quot;k&quot;</span>: k&#125;)</span><br><span class="line">    <span class="keyword">return</span> Rn_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sinx_div_x</span>(<span class="params">x</span>):</span><br><span class="line">    y = np.sin(x) / x</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(y, np.ndarray):</span><br><span class="line">        y = np.array([y])</span><br><span class="line">    y[np.where(np.isnan(y))] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Tn_list = compute_Tn(sinx_div_x, x_min=<span class="number">0</span>, x_max=<span class="number">1</span>, epoch=<span class="number">24</span>)</span><br><span class="line">    <span class="built_in">print</span>(Tn_list)</span><br><span class="line">    Sn_list = compute_Sn(Tn_list)</span><br><span class="line">    <span class="built_in">print</span>(Sn_list)</span><br><span class="line">    Cn_list = compute_Cn(Sn_list=Sn_list)</span><br><span class="line">    <span class="built_in">print</span>(Cn_list)</span><br><span class="line">    Rn_list = compute_Rn(Cn_list=Cn_list)</span><br><span class="line">    <span class="built_in">print</span>(Rn_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数值分析 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】Linux实现一个简易shell</title>
      <link href="/2022/02/22/Linux%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93Shell/"/>
      <url>/2022/02/22/Linux%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93Shell/</url>
      
        <content type="html"><![CDATA[<h2 id="1-fork-函数"><a href="#1-fork-函数" class="headerlink" title="1. fork()函数"></a>1. fork()函数</h2><p>​        当程序调用fork()函数并返回成功之后，程序就将变成两个进程，调用fork()者为父进程，后来生成者为子进程。这两个进程将执行相同的程序文本，但却各自拥有不同的栈段、数据段以及堆栈拷贝。子进程的栈、数据以及栈段开始时是父进程内存相应各部分的完全拷贝，因此它们互不影响。</p><p>fork()函数在Linux中有两次返回，在父进程中返回子进程的pid，在子进程中返回0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">//调用一次，返回两次，在父进程中返回子进程的pid在子进程中返回0</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m a parent\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m a child\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m a parent</span><br><span class="line">I&#x27;m a child</span><br></pre></td></tr></table></figure><h2 id="2-进程等待之wait-amp-waitpid"><a href="#2-进程等待之wait-amp-waitpid" class="headerlink" title="2. 进程等待之wait() &amp; waitpid()"></a>2. 进程等待之wait() &amp; waitpid()</h2><ul><li>如果子进程已经退出，调用wait/waitpid会立即返回，并且释放资源，获得子进程退出信息</li><li>如果在任意时刻调用wait/waitpid，子进程存在且正常运行，则父进程可能阻塞</li><li>如果不存在该子进程，则立即出错返回</li><li>子进程的退出是个异步事件（子进程可以在父进程运行的任何时刻终止）</li></ul><h3 id="2-1-wait"><a href="#2-1-wait" class="headerlink" title="2.1 wait()"></a>2.1 wait()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">头文件：<span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/type.h&gt;</span></span></span><br><span class="line">原型</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *status)</span></span></span><br><span class="line"><span class="function">返回值：</span></span><br><span class="line"><span class="function">    成功：返回被等待进程（子进程）pid</span></span><br><span class="line"><span class="function">    失败：返回-1</span></span><br><span class="line"><span class="function">参数：输出型参数，获取子进程退出状态，不关心则可以设置为<span class="literal">NULL</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-waitpid"><a href="#2-2-waitpid" class="headerlink" title="2.2 waitpid()"></a>2.2 waitpid()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">头文件： <span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/type.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">返回值：</span><br><span class="line">   (<span class="number">1</span>)当正常返回的时候waitpid返回收集到的子进程的进程<span class="built_in">ID</span></span><br><span class="line"></span><br><span class="line">   (<span class="number">2</span>)如果设置了选项WNOHANG，而调用中waitpid发现已经没</span><br><span class="line">      有已经可以退出的子进程可收集，则返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line">   (<span class="number">3</span>)如果调用中出错，则返回<span class="number">-1</span>，这时errno会被设置成相应的</span><br><span class="line">      值以指示错误所在</span><br><span class="line">原型：</span><br><span class="line">   <span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *status,<span class="type">int</span> options)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    1.pid</span></span><br><span class="line"><span class="function">      pid</span>=<span class="number">-1</span>，等待任一个子进程，与wait等效</span><br><span class="line">      pid&gt;<span class="number">0</span>,等待其进程ID与pid相等的子进程</span><br><span class="line">    <span class="number">2.</span><span class="function">status</span></span><br><span class="line"><span class="function">       <span class="title">WIFEXITED</span><span class="params">(status)</span>:    若为正常终止子进程返回的状态，则为</span></span><br><span class="line"><span class="function">                             真（此参数是查看进程是否是正常退出）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       WEXITSTATUS(status):  若WEXITSTATUS非零，提取子进程退</span></span><br><span class="line"><span class="function">                             出码（查看进程的退出码）</span></span><br><span class="line"><span class="function">    <span class="number">3.</span>options</span></span><br><span class="line"><span class="function">         WNOHANG：若pid指定的子进程没有结束，则waitpid()函数</span></span><br><span class="line"><span class="function">                  返回<span class="number">0</span>，不予以等待，若正常结束，则返回该子进程的ID</span></span><br></pre></td></tr></table></figure><h2 id="3-进程替换：exec-函数族"><a href="#3-进程替换：exec-函数族" class="headerlink" title="3. 进程替换：exec 函数族"></a>3. 进程替换：exec 函数族</h2><p>所谓exec函数族，其实有六种以exec开头的函数，统称exec函数：execl、execlp、execle、execv、execvp、execve。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变。</p><h3 id="3-1-exec函数族一般规律："><a href="#3-1-exec函数族一般规律：" class="headerlink" title="3.1 exec函数族一般规律："></a>3.1 exec函数族一般规律：</h3><p>exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p><p>exec函数族名字很相近，使用起来也很相近，它们的一般规律如下：</p><p>l (list)                           命令行参数列表</p><p>p (path)                       搜素file时使用path变量</p><p>v (vector)                    使用命令行参数数组</p><p>e (environment)       使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p><h3 id="3-2-带p的exec函数"><a href="#3-2-带p的exec函数" class="headerlink" title="3.2 带p的exec函数"></a>3.2 带p的exec函数</h3><p>这类函数有：execlp，execvp</p><p>具体说明：表示第一个参数无需给出具体的路径，只需给出函数名即可，系统会在PATH环境变量中寻找所对应的程序，如果没找到的话返回－1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure><p>execvp()会从PATH 环境变量所指的目录中查找符合参数file 的文件名，找到后便执行该文件，然后将第二个参数argv传给该欲执行的文件。</p><h2 id="4-代码实现和结果"><a href="#4-代码实现和结果" class="headerlink" title="4. 代码实现和结果"></a>4. 代码实现和结果</h2><p>github链接：<a href="https://github.com/Kakaluoto/MyShell">GitHub - Kakaluoto/MyShell</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cd_failed 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cd_success 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; argv;<span class="comment">//存储当前命令所有参数</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">history_cmds</span><span class="params">(<span class="number">100</span>)</span></span>;<span class="comment">//存放历史命令，因为时间有限功能还未实现</span></span><br><span class="line">string cmd;<span class="comment">//当前命令字符串</span></span><br><span class="line"><span class="type">char</span>* current_path = <span class="literal">nullptr</span>;<span class="comment">//当前工作路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">argparse</span><span class="params">()</span></span>; <span class="comment">//解析参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_directory</span><span class="params">()</span></span>;<span class="comment">//cd命令</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute_cmd</span><span class="params">()</span></span>;<span class="comment">//执行命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    current_path = <span class="built_in">getcwd</span>(<span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//获取当前路径</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 前置输出提示这是一个shell</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;myshell:%s$ &quot;</span>, current_path);</span><br><span class="line">        <span class="built_in">getline</span>(cin, cmd);</span><br><span class="line">        <span class="comment">// 如果输入为exit 则结束当前进程</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd.<span class="built_in">data</span>(), <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> current_path;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">argparse</span>();</span><br><span class="line">        <span class="built_in">execute_cmd</span>();</span><br><span class="line">        argv.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 后面在do_cmd部分会解释为什么无循环结束条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">argparse</span><span class="params">()</span> </span>&#123;<span class="comment">//解析输入参数</span></span><br><span class="line">    string param;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i:cmd + <span class="string">&quot; &quot;</span>) &#123;<span class="comment">//因为要用到空格进行分割，为了防止最后一个参数分割不到加一个空格</span></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            param += i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            argv.<span class="built_in">push_back</span>(param);</span><br><span class="line">            param = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change_directory</span><span class="params">(<span class="type">int</span> argc)</span> </span>&#123;<span class="comment">//cd命令</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chdir</span>(argv[<span class="number">1</span>].<span class="built_in">data</span>()) == <span class="number">0</span>) &#123;<span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line">            current_path = <span class="built_in">getcwd</span>(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (current_path != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cd_success;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No such file or directory!\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> cd_failed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No such file or directory!\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> cd_failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;too many arguments!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> cd_failed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute_cmd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> argc = argv.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">char</span>** arguments = <span class="keyword">new</span> <span class="type">char</span>* [argc];<span class="comment">//转换参数类型，以便能够喂到exec函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        arguments[i] = (<span class="type">char</span>*) argv[i].<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">change_directory</span>(argc);<span class="comment">//执行cd命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (pid = fork()) &#123;</span><br><span class="line">            <span class="comment">//fork子进程失败</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Failed to create subprocess!\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//处理子进程</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">execvp</span>(arguments[<span class="number">0</span>], arguments);</span><br><span class="line">                <span class="comment">//子进程，没有成功执行</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;invalid input command : \&quot;&quot;</span> &lt;&lt; arguments[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="type">int</span> status;</span><br><span class="line">                <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);<span class="comment">//等待子进程返回</span></span><br><span class="line">                <span class="type">int</span> err = <span class="built_in">WEXITSTATUS</span>(status); <span class="comment">// 读取子进程的返回码</span></span><br><span class="line">                <span class="keyword">if</span> (err)cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(err) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入MyShell可执行文件所在目录执行如下命令即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./MyShell</span><br></pre></td></tr></table></figure><p>得到输出如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myshell:/home/hy/myCppProject/cmake_demo/myshell$ </span><br></pre></td></tr></table></figure><p>执行ls</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myshell:/home/hy/myCppProject/cmake_demo/myshell$ ls</span><br><span class="line">MyShell  MyShell.cpp  readme.md</span><br></pre></td></tr></table></figure><p>执行ls -l：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myshell:/home/hy/myCppProject/cmake_demo/myshell$ <span class="built_in">ls</span> -l</span><br><span class="line">total 176</span><br><span class="line">-rwxrwxr-x 1 hy hy 159632 12月 18 23:51 MyShell</span><br><span class="line">-rw-rw-r-- 1 hy hy   3020 12月 19 16:08 MyShell.cpp</span><br><span class="line">-rw-rw-r-- 1 hy hy  13420 12月  9 22:43 readme.md</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行ps</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myshell:/home/hy/myCppProject/cmake_demo/myshell$ ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line"> 135724 pts/0    00:00:00 bash</span><br><span class="line"> 135766 pts/0    00:00:00 MyShell</span><br><span class="line"> 135847 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><p>执行cd：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myshell:/home/hy/myCppProject/cmake_demo/myshell$ <span class="built_in">cd</span> /</span><br><span class="line">myshell:/$ </span><br></pre></td></tr></table></figure><p>执行pwd和ls命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myshell:/$ <span class="built_in">pwd</span></span><br><span class="line">/</span><br><span class="line">myshell:/$ <span class="built_in">ls</span></span><br><span class="line">bin   cdrom  etc   lib  lib64   media  opt   root  sbin  srv     sys  usr</span><br><span class="line">boot  dev    home  lib32  libx32  mnt proc  run   snap  swapfile  tmp  var</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】基于ptrace系统调用实现一个debugger</title>
      <link href="/2022/02/22/%E5%9F%BA%E4%BA%8Eptrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAdebugger/"/>
      <url>/2022/02/22/%E5%9F%BA%E4%BA%8Eptrace%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAdebugger/</url>
      
        <content type="html"><![CDATA[<h1 id="基于ptrace的debugger设计"><a href="#基于ptrace的debugger设计" class="headerlink" title="基于ptrace的debugger设计"></a>基于ptrace的debugger设计</h1><h2 id="1-程序的设计思路"><a href="#1-程序的设计思路" class="headerlink" title="1. 程序的设计思路"></a>1. 程序的设计思路</h2><h3 id="1-1-设计思路"><a href="#1-1-设计思路" class="headerlink" title="1.1 设计思路"></a>1.1 设计思路</h3><p>本次设计实现的debugger针对被调试进程主要实现了6项功能:</p><ul><li>可以读取被调试进程CPU所有寄存器的值</li><li>可以对被调试进程进行单步调试</li><li>可以恢复被调试进程运行</li><li>可以查看被调试进程任意内存空间</li><li>可以计算被调试进程执行完需要多少条指令</li><li>可以在指定地址插入断点</li></ul><p>为了在不同的功能之间进行切换，使用循环轮询手动输入参数的方式来决定使用哪一项功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Type <span class="string">&quot;exit&quot;</span> to exit debugger.</span><br><span class="line">Type <span class="string">&quot;reg&quot;</span> <span class="keyword">or</span> <span class="string">&quot;r&quot;</span> to show registers.</span><br><span class="line">Type <span class="string">&quot;step&quot;</span> <span class="keyword">or</span> <span class="string">&quot;s&quot;</span> to single step.</span><br><span class="line">Type <span class="string">&quot;continue&quot;</span> <span class="keyword">or</span> <span class="string">&quot;c&quot;</span> to <span class="keyword">continue</span> until tracee stop.</span><br><span class="line">Type <span class="string">&quot;memory&quot;</span> <span class="keyword">or</span> <span class="string">&quot;m&quot;</span> to show memory content.</span><br><span class="line">You can use <span class="string">&quot;-addr&quot;</span> <span class="keyword">or</span> <span class="string">&quot;-off&quot;</span> <span class="keyword">or</span> <span class="string">&quot;-nb&quot;</span> as argument.</span><br><span class="line">use <span class="string">&quot;-addr&quot;</span> to specify hexadecimal start address of the memory</span><br><span class="line"><span class="keyword">for</span> example: Type <span class="string">&quot;m -addr ff&quot;</span> to specify the start address <span class="number">0xff</span></span><br><span class="line">(<span class="keyword">default</span> start address is RIP)</span><br><span class="line">use <span class="string">&quot;-off&quot;</span> <span class="function">to specify the decimal offset from the start <span class="title">address</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="keyword">default</span> offset is <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">use &quot;-nb&quot; to specify the decimal number of bytes to be <span class="title">displayed</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="keyword">default</span> number is <span class="number">40</span>)</span></span></span><br><span class="line"><span class="function">Type &quot;ic&quot; to count total instructions.</span></span><br><span class="line"><span class="function">Type &quot;<span class="keyword">break</span>&quot; <span class="keyword">or</span> &quot;b&quot; to insert breakpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> example: Type <span class="string">&quot;b 555555555131&quot;</span> to specify the breakpoint address <span class="number">0x555555555131</span></span></span><br></pre></td></tr></table></figure><p>系统调用Ptrace的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid,<span class="type">void</span> *addr,<span class="type">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>ptrace的第一个参数可以通过指定request请求来实现不同的功能。使用PTRACE_GETREGS参数来一次性获取所有寄存器的值，使用PTRACE_SINGLESTEP来进行单步调试，PTRACE_CONT来让被暂停的进程恢复运行。</p><p>为了读取任意内存空间，需要知道内存空间的起始地址，一次性读取多少个字节，因此默认采用rip寄存器存放的指针作为默认的起始地址，也就是默认从下一条指令的地址开始读，可以指定一次性读多少个字节，这里我默认一次性读取40个字节，为了既能够读到rip指针之后的数据也能读到rip指针之前的数据，引入偏移量offset，这样可以在指定了起始地址的基础上加上偏移量，从而理论上能够读取任意内存区域。当然，如果明确知道要读的内存起始地址，也可以忽略rip指针直接指定起始地址。</p><p>计算进程执行完需要多少条指令比较简单，只需要不停单步执行直到退出，每执行一步就计数即可。</p><p>给进程打断点的实现最为困难，本次设计仅针对进程特定地址进行插入断点。可以使用Ptrace的PTRACE_PEEKDATA，PTRACE_POKEDATA两个请求，来在进程指定的地址读出指令和注入新的指令。因此可以在指定的地址插入int3(0xcc)中断指令实现断点，为了让插入断点的进程依然能够恢复运行，在插入断点之前对该地址原有指令进行备份，遇到断点之后再将备份的指令还原，并且恢复命中断点时的寄存器值，尤其是rip指针需要减1，回退一个地址。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171713946.png" alt=""></p><p>过程如上图所示，第一步rip先指向byte2对应地址处，利用PTRACE_PEEKDATA将byte2,byte3取出备份，同时保存当前寄存器值，为恢复做备份。第二步插入0xcc,0x00指令，即int3中断指令，执行一步来到第三步rip指向0x00，触发中断，子进程暂停。第四步，为了让子进程继续运行，将备份的原始指令写入rip-1处，并且利用PTRACE_SETREGS将寄存器值恢复成原来的值，此时rip跟着上移。这样子进程可以继续正常运行不会core dump。以上四步构成了在byte2对应地址处打上断点的操作。</p><p>要完成插入断点并且运行到断点停止，并且能恢复原有指令继续正常运行的非常关键的一点就是需要知道子进程是否命中断点。因为子进程完全有可能因为接收到其他信号而暂停，同时产生SIGTRAP信号发送给父进程，并不一定就是因为断点而暂停并发送SIGTRAP信号。因此在等待被调试进程的时候，当截获SIGTRAP信号需要取出rip指针，此时如果是断点触发的暂停信号，rip肯定指向0xcc指令的下一条指令，故而只需要判断当初我们输入的打断点的地址addr是否等于rip-1。如果相等那么断点命中，命中之后就可以将原有指令恢复，把寄存器值恢复。</p><h2 id="2-程序的模块划分"><a href="#2-程序的模块划分" class="headerlink" title="2. 程序的模块划分"></a>2. 程序的模块划分</h2><p>主要函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdata</span><span class="params">(<span class="type">pid_t</span> child, <span class="type">long</span> addr, <span class="type">char</span>* str, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 从子进程指定地址插入数据</span></span><br><span class="line"><span class="comment"> * child: 子进程pid号</span></span><br><span class="line"><span class="comment"> * addr: 地址</span></span><br><span class="line"><span class="comment"> * str: 用来插入的字节</span></span><br><span class="line"><span class="comment"> * len: 插入字节数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putdata</span><span class="params">(<span class="type">pid_t</span> child, <span class="type">long</span> addr, <span class="type">char</span>* str, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 按字节打印数据</span></span><br><span class="line"><span class="comment"> * tip: 可以附带 字符串输出</span></span><br><span class="line"><span class="comment"> * codes: 需要打印的字节</span></span><br><span class="line"><span class="comment"> * len: 需要打印的字节数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMemory</span><span class="params">(<span class="type">pid_t</span> pid, </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">long</span> offset = <span class="number">0</span>, <span class="type">int</span> nbytes = <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 显示任意内存内容</span></span><br><span class="line"><span class="comment"> * pid: 子进程pid</span></span><br><span class="line"><span class="comment"> * addr: 指定内存基地址</span></span><br><span class="line"><span class="comment"> * offset: 指定相对于基地址的偏移地址</span></span><br><span class="line"><span class="comment"> * nbytes: 需要显示的字节数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait_breakpoint</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> status, Breakpoint&amp; bp)</span></span>;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 注入断点</span></span><br><span class="line"><span class="comment"> * pid: 子进程pid</span></span><br><span class="line"><span class="comment"> * bp: 断点结构体</span></span><br><span class="line"><span class="comment"> struct Breakpoint &#123;</span></span><br><span class="line"><span class="comment">    unsigned long long addr;</span></span><br><span class="line"><span class="comment">    char backup[CODE_SIZE];</span></span><br><span class="line"><span class="comment">    bool breakpoint_mode;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">//断点结构体，需要插入断点的地址addr</span></span><br><span class="line"><span class="comment">//断点地址处的指令的备份backup</span></span><br><span class="line"><span class="comment">//用来标记是否有断点存在的变量breakpoint_mode</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">breakpoint_inject</span><span class="params">(<span class="type">pid_t</span> pid, Breakpoint&amp; bp)</span></span>;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 等待断点，判断是否命中</span></span><br><span class="line"><span class="comment"> * pid: 子进程pid</span></span><br><span class="line"><span class="comment"> * status: 由外部传入，获取当前tracee停止的状态码</span></span><br><span class="line"><span class="comment"> * bp: 断点结构体</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_base_address</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&amp; base_addr)</span></span>;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 获取子进程再虚拟地址空间的起始地址</span></span><br><span class="line"><span class="comment"> * pid: 子进程pid</span></span><br><span class="line"><span class="comment"> * base_addr: 用来存储起始地址</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_help</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//显示帮助信息</span></span><br></pre></td></tr></table></figure><h2 id="3-遇到的问题及解决方法"><a href="#3-遇到的问题及解决方法" class="headerlink" title="3. 遇到的问题及解决方法"></a>3. 遇到的问题及解决方法</h2><h3 id="3-1-Linux地址空间随机化产生的问题"><a href="#3-1-Linux地址空间随机化产生的问题" class="headerlink" title="3.1 Linux地址空间随机化产生的问题"></a>3.1 Linux地址空间随机化产生的问题</h3><p>运行代码fork子进程之后，循环单步执行，每执行一步输出一次rip指针，共万步有余。每次执行代码输出的rip都各不相同，从第一次输出的rip到最后一次输出的rip指针并不是固定的几个值，而是每次执行输出的都是一批不同的rip序列。这给后期断点功能的实现造成了很大的麻烦。比如我使用GDB给被调试进程main函数第一行打断点，执行到断点处执行<code>i r rip</code>命令观察此时rip值，假设此时rip的值为aaa。我以为获得了子进程源代码main函数第一行的地址即aaa，于是将其设为断点地址却发现断点命中不了。</p><p>为了确认我自己代码fork出的子进程所有指令的地址里有aaa，我单步执行，每次单步就取一次rip指针的值，与aaa进行比对，发现没有任何地址与aaa相等，这与gdb给出的结果不符。且每次运行，rip输出的序列内容都和上一次运行输出的rip序列不同。经过查找资料确定是Linux地址空间随机化的缘故。ASLR 技术将进程的某些内存空间地址进行随机化来增大入侵者预测目的地址的难度，从而降低进程被成功入侵的风险。</p><p>使用命令<code>sudo bash -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code>关闭了ASLR,之后rip输出的序列不再随机变化，而是固定的序列。由此GDB获取到的rip地址和我自己获取的rip开始保持一致。</p><h3 id="3-2-无法确定应该注入断点的地址"><a href="#3-2-无法确定应该注入断点的地址" class="headerlink" title="3.2 无法确定应该注入断点的地址"></a>3.2 无法确定应该注入断点的地址</h3><p>解决了被调试进程虚拟地址总是变化的问题之后，就可以指定断点的地址了。使用反汇编命令<code>objdump -d test</code>获得被调试子进程的汇编代码以及每条汇编代码的偏移地址。我发现gdb断点到相应的行给出来的地址和反汇编的地址不一样，这样如果想要通过反汇编找到main函数入口地址，根据这个入口地址设置断点是无法成功的，通过观察我发现反汇编出来的地址是偏移地址，这个偏移地址总是与被调试进程对应指令的实际虚拟地址相差一个常数，我这里是0x5555_5555_4000。比如反汇编被调试子进程main函数入口地址是0x1129，直接将0x1129作为断点地址会报错，如果将0x5555_5555_4000 + 0x1129作为main函数的虚拟地址就可以断点注入成功，而且这个相加的和与gdb获得的地址一致。</p><p>本来直接将这个神秘常数拿来相加就可以利用反汇编得到的地址打断点了，但是我不能保证所有的被调试进程都是相差这个常数，经过查阅资料我知道0x5555_5555_4000是子进程的虚拟地址空间的首地址，通过<code>pmap -x pid</code>命令可以获取任意进程的内存分布范围。查阅资料得知，Linux将进程的内存分布信息缓存在/proc/进程pid/maps文件中，pmap的原理也是解析这个文件，于是我通过解析这个文件便成功获取到了子进程的虚拟内存起始地址。</p><p>如此就可以很方便地通过反汇编<code>objdump -d</code>指令获取汇编的偏移地址，作为断点地址的参数进行断点注入了，而无需关心子进程的虚拟内存其实地址是多少，因为反汇编得出来的汇编指令的地址是不变的。</p><h3 id="3-3-断点命中成功，恢复源代码失败"><a href="#3-3-断点命中成功，恢复源代码失败" class="headerlink" title="3.3 断点命中成功，恢复源代码失败"></a>3.3 断点命中成功，恢复源代码失败</h3><p>恢复寄存器的时候忘记调整rip指针了，应该将rip指针减一，回退到断点的地址处。</p><h2 id="4-程序使用说明及运行结果"><a href="#4-程序使用说明及运行结果" class="headerlink" title="4. 程序使用说明及运行结果"></a>4. 程序使用说明及运行结果</h2><p>当前目录下含有5个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/ptrace_debugger$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── ASLR.sh</span><br><span class="line">├── main.cpp</span><br><span class="line">├── ptrace_debugger</span><br><span class="line">├── test</span><br><span class="line">└── test.cpp</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Linux 平台上 ASLR 分为 0，1，2 三级，用户可以通过一个内核参数 randomize_va_space 进行等级控制。它们对应的效果如下：</p><p>0：没有随机化。即关闭 ASLR。<br>1：保留的随机化。共享库、栈、mmap() 以及 VDSO 将被随机化。<br>2：完全的随机化。在 1 的基础上，通过 brk() 分配的内存空间也将被随机化。</p><p>ASLR.sh脚本用来设置随机化等级：</p><p>ptrace_debugger是main.cpp编译的可执行文件</p><p>test是被调试进程test.cpp编译的可执行文件</p><p>执行如下命令关闭随机化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/ptrace_debugger$ </span><span class="language-bash">./ASLR.sh 0</span></span><br><span class="line">change ASLR level to:</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>运行ptrace_debugger：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/ptrace_debugger$ </span><span class="language-bash">./ptrace_debugger</span> </span><br><span class="line">This is a debugger based on ptrace.</span><br><span class="line">For help type &quot;help&quot; or &quot;h&quot;</span><br><span class="line">Please input the name of program to be traced:</span><br><span class="line">test</span><br><span class="line">(PDebugger) &gt;</span><br></pre></td></tr></table></figure><p>查看寄存器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(PDebugger) &gt;r </span><br><span class="line">rax0</span><br><span class="line">rbx0</span><br><span class="line">rcx0</span><br><span class="line">rdx0</span><br><span class="line">rsi0</span><br><span class="line">rdi0</span><br><span class="line">rbp0</span><br><span class="line">rsp7fffffffdf50</span><br><span class="line">rip7ffff7fd0100</span><br><span class="line">eflags200</span><br><span class="line">cs33</span><br><span class="line">ss2b</span><br><span class="line">ds0</span><br><span class="line">es0</span><br><span class="line">(PDebugger) &gt;</span><br></pre></td></tr></table></figure><p>单步调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(PDebugger) &gt;r</span><br><span class="line">rax0</span><br><span class="line">rbx0</span><br><span class="line">rcx0</span><br><span class="line">rdx0</span><br><span class="line">rsi0</span><br><span class="line">rdi0</span><br><span class="line">rbp0</span><br><span class="line">rsp7fffffffdf50</span><br><span class="line">rip7ffff7fd0100</span><br><span class="line">eflags200</span><br><span class="line">cs33</span><br><span class="line">ss2b</span><br><span class="line">ds0</span><br><span class="line">es0</span><br><span class="line">(PDebugger) &gt;s</span><br><span class="line">(PDebugger) &gt;r</span><br><span class="line">rax0</span><br><span class="line">rbx0</span><br><span class="line">rcx0</span><br><span class="line">rdx0</span><br><span class="line">rsi0</span><br><span class="line">rdi7fffffffdf50</span><br><span class="line">rbp0</span><br><span class="line">rsp7fffffffdf50</span><br><span class="line">rip7ffff7fd0103</span><br><span class="line">eflags202</span><br><span class="line">cs33</span><br><span class="line">ss2b</span><br><span class="line">ds0</span><br><span class="line">es0</span><br><span class="line">(PDebugger) &gt;</span><br></pre></td></tr></table></figure><p>恢复运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(PDebugger) &gt;s</span><br><span class="line">(PDebugger) &gt;r</span><br><span class="line">rax0</span><br><span class="line">rbx0</span><br><span class="line">rcx0</span><br><span class="line">rdx0</span><br><span class="line">rsi0</span><br><span class="line">rdi7fffffffdf50</span><br><span class="line">rbp0</span><br><span class="line">rsp7fffffffdf48</span><br><span class="line">rip7ffff7fd0df0</span><br><span class="line">eflags202</span><br><span class="line">cs33</span><br><span class="line">ss2b</span><br><span class="line">ds0</span><br><span class="line">es0</span><br><span class="line">(PDebugger) &gt;c</span><br><span class="line">Process finished.</span><br></pre></td></tr></table></figure><p>查看任意内存空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(PDebugger) &gt;m -off -20 -nb 40</span><br><span class="line">current base address is : 0x7ffff7fd0df0</span><br><span class="line">offset is : -20</span><br><span class="line">The 40 bytes after start address: 0x7ffff7fd0ddc :</span><br><span class="line">00 00 00 00 bf 01 00 00 </span><br><span class="line">00 5b e9 95 d4 01 00 0f </span><br><span class="line">1f 44 00 00 f3 0f 1e fa </span><br><span class="line">55 48 89 e5 41 57 49 89 </span><br><span class="line">ff 41 56 41 55 41 54 53 </span><br><span class="line"></span><br><span class="line">(PDebugger) &gt;</span><br></pre></td></tr></table></figure><p>计算指令数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(PDebugger) &gt;ic</span><br><span class="line"></span><br><span class="line">total instruction count is 117802</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>断点调试：</p><p>先进行反汇编</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">hy@ubuntu:~/下载/ptrace_debugger$ ls</span><br><span class="line">ASLR.sh  main.cpp  ptrace_debugger  test  test.cpp</span><br><span class="line">hy@ubuntu:~/下载/ptrace_debugger$ objdump -d test</span><br><span class="line"></span><br><span class="line">test：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">......省略......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0000000000001129 &lt;main&gt;:</span><br><span class="line">    1129:f3 0f 1e fa          endbr64 </span><br><span class="line">    112d:55                   push   %rbp</span><br><span class="line">    112e:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    1131:c7 45 f4 04 00 00 00 movl   $0x4,-0xc(%rbp)</span><br><span class="line">    1138:c7 45 f8 08 00 00 00 movl   $0x8,-0x8(%rbp)</span><br><span class="line">    113f:8b 55 f4             mov    -0xc(%rbp),%edx</span><br><span class="line">    1142:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line">    1145:01 d0                add    %edx,%eax</span><br><span class="line">    1147:89 45 fc             mov    %eax,-0x4(%rbp)</span><br><span class="line">    114a:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">    114f:5d                   pop    %rbp</span><br><span class="line">    1150:c3                   retq   </span><br><span class="line">    1151:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">    1158:00 00 00 </span><br><span class="line">    115b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line"></span><br><span class="line">......省略......</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Disassembly of section .fini:</span><br><span class="line"></span><br><span class="line">00000000000011d8 &lt;_fini&gt;:</span><br><span class="line">    11d8:f3 0f 1e fa          endbr64 </span><br><span class="line">    11dc:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">    11e0:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">    11e4:c3                   retq  </span><br></pre></td></tr></table></figure><p>可以看到main函数入口地址是0x1129</p><p>打断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Please input the name of program to be traced:</span><br><span class="line">test</span><br><span class="line">(PDebugger) &gt;b 1129</span><br><span class="line">get base_addr:0x555555554000</span><br><span class="line">get tracee instruction: f3 0f 1e fa 55 48 89 e5 </span><br><span class="line"></span><br><span class="line">try to set breakpoint</span><br><span class="line">set breakpoint instruction: cc 00 00 00 00 00 00 00 </span><br><span class="line"></span><br><span class="line">(PDebugger) &gt;c</span><br><span class="line">Hit Breakpoint at: 0x555555555129</span><br><span class="line">(PDebugger) &gt;r</span><br><span class="line">rax555555555129</span><br><span class="line">rbx555555555160</span><br><span class="line">rcx555555555160</span><br><span class="line">rdx7fffffffdf68</span><br><span class="line">rsi7fffffffdf58</span><br><span class="line">rdi1</span><br><span class="line">rbp0</span><br><span class="line">rsp7fffffffde68</span><br><span class="line">rip555555555129</span><br><span class="line">eflags246</span><br><span class="line">cs33</span><br><span class="line">ss2b</span><br><span class="line">ds0</span><br><span class="line">es0</span><br><span class="line">(PDebugger) &gt;s</span><br><span class="line">(PDebugger) &gt;c</span><br><span class="line">Process finished.</span><br></pre></td></tr></table></figure><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h2><p>完整项目地址<a href="https://github.com/Kakaluoto/ptraceDebugger">GitHub - Kakaluoto/ptraceDebugger: 利用ptrace系统调用实现的debugger</a></p><h3 id="5-1-被调试子进程tracee"><a href="#5-1-被调试子进程tracee" class="headerlink" title="5.1 被调试子进程tracee"></a>5.1 被调试子进程tracee</h3><p>test.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> k = i + j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-关闭ASLR脚本"><a href="#5-2-关闭ASLR脚本" class="headerlink" title="5.2 关闭ASLR脚本"></a>5.2 关闭ASLR脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $# == 0 ]# $# means the number of parameters</span><br><span class="line">then</span><br><span class="line">    echo &#x27;current ASLR level:&#x27;</span><br><span class="line">    cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">    echo &#x27;use option &quot;-h&quot; for help.&#x27;</span><br><span class="line">elif [ $# == 1 ]</span><br><span class="line">then</span><br><span class="line">    if [ $1 == 0 ]</span><br><span class="line">    then </span><br><span class="line">        sudo bash -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br><span class="line">        echo &quot;change ASLR level to:&quot;</span><br><span class="line">        cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">    elif [ $1 == 1 ]</span><br><span class="line">    then</span><br><span class="line">        sudo bash -c &quot;echo 1 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br><span class="line">        echo &quot;change ASLR level to:&quot;</span><br><span class="line">        cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">    elif [ $1 == 2 ]</span><br><span class="line">    then</span><br><span class="line">        sudo bash -c &quot;echo 2 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br><span class="line">        echo &quot;change ASLR level to:&quot;</span><br><span class="line">        cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">    elif [ $1 == &quot;-h&quot; ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        echo &quot;### bash ./ASLR&quot;</span><br><span class="line">        echo &quot;--&gt;   show current ASLR level.&quot;</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        echo &quot;### bash ./ASLR -h&quot;</span><br><span class="line">        echo &quot;--&gt;   show help info.&quot;</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        echo &quot;### bash ./ASLR 0&quot;</span><br><span class="line">        echo &quot;--&gt;   change ASLR level to 0.&quot;</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        echo &quot;### bash ./ASLR 1&quot;</span><br><span class="line">        echo &quot;--&gt;   change ASLR level to 1.&quot;</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">        echo &quot;### bash ./ASLR 2&quot;</span><br><span class="line">        echo &quot;--&gt;   change ASLR level to 2.&quot;</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;syntax error!&quot;</span><br><span class="line">        echo &#x27;use option &quot;-h&quot; for help.&#x27;</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    echo &quot;syntax error!&quot;</span><br><span class="line">    echo &#x27;use option &quot;-h&quot; for help.&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="5-3-Debugger代码"><a href="#5-3-Debugger代码" class="headerlink" title="5.3 Debugger代码"></a>5.3 Debugger代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG_SIZE 8 <span class="comment">//LONG型数据的长度8个字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_SIZE 8<span class="comment">//注入断点中断指令的长度，也是8个字节</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;string&gt; argv;<span class="comment">//存储当前命令所有参数</span></span><br><span class="line">string cmd;<span class="comment">//当前命令字符串</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Breakpoint</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr;</span><br><span class="line">    <span class="type">char</span> backup[CODE_SIZE];</span><br><span class="line">    <span class="type">bool</span> breakpoint_mode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断点结构体，包含有需要插入断点的地址，对断点地址处的指令进行备份，以及用来标记是否有断点存在的变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">argparse</span><span class="params">()</span></span>; <span class="comment">//解析参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdata</span><span class="params">(<span class="type">pid_t</span> child, <span class="type">long</span> addr, <span class="type">char</span>* str, <span class="type">int</span> len)</span></span>;<span class="comment">//从子进程指定地址获取指定长度的数据，长度单位为字节</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putdata</span><span class="params">(<span class="type">pid_t</span> child, <span class="type">long</span> addr, <span class="type">char</span>* str, <span class="type">int</span> len)</span></span>;<span class="comment">//将数据插入子进程指定地址处</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBytes</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* tip, <span class="type">char</span>* codes, <span class="type">int</span> len)</span></span>;<span class="comment">//打印字节</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMemory</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">long</span> offset = <span class="number">0</span>, <span class="type">int</span> nbytes = <span class="number">40</span>)</span></span>;<span class="comment">//显示指定地址处指定长度的内存内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait_breakpoint</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> status, Breakpoint&amp; bp)</span></span>;<span class="comment">//判断断点是否命中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">breakpoint_inject</span><span class="params">(<span class="type">pid_t</span> pid, Breakpoint&amp; bp)</span></span>;<span class="comment">//给子进程注入断点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_base_address</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&amp; base_addr)</span></span>;<span class="comment">//从当前子进程的虚拟地址范围获取子进程的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_help</span><span class="params">()</span></span>;<span class="comment">//显示帮助信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    string tracee_name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base_addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a debugger based on ptrace.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;For help type \&quot;help\&quot; or \&quot;h\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the name of program to be traced:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getline</span>(cin, tracee_name);<span class="comment">//获取本目录下被trace的进程</span></span><br><span class="line">    tracee_name = <span class="string">&quot;./&quot;</span> + tracee_name;<span class="comment">//转换成路径</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    Breakpoint breakpoint = &#123;.breakpoint_mode=<span class="literal">false</span>&#125;;<span class="comment">//默认不进入断点模式</span></span><br><span class="line">    <span class="keyword">switch</span> (pid = fork()) &#123;<span class="comment">//fork子进程</span></span><br><span class="line">        <span class="comment">//fork子进程失败</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Failed to create subprocess!\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//处理子进程</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;ptrace error in subprocess!\n&quot;</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">execl</span>(tracee_name.<span class="built_in">data</span>(), tracee_name.<span class="built_in">data</span>())) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;execvp error in subprocess!\n&quot;</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子进程，没有成功执行</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;invalid input command : \&quot;&quot;</span> &lt;&lt; tracee_name &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//开始轮询输入的命令</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(PDebugger) &gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">getline</span>(cin, cmd);</span><br><span class="line">                <span class="comment">// 如果输入为exit 则结束当前进程</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd.<span class="built_in">data</span>(), <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">argparse</span>();<span class="comment">//输入参数解析</span></span><br><span class="line">                <span class="comment">//execute_cmd(pid);</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">user_regs_struct</span> regs&#123;&#125;;<span class="comment">//存储子进程当前寄存器的值</span></span><br><span class="line">                <span class="type">int</span> argc = argv.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">char</span>** arguments = <span class="keyword">new</span> <span class="type">char</span>* [argc];<span class="comment">//转换参数类型，以便能够喂到exec函数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">                    arguments[i] = (<span class="type">char</span>*) argv[i].<span class="built_in">data</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;<span class="comment">//退出操作</span></span><br><span class="line">                    <span class="built_in">ptrace</span>(PTRACE_KILL, pid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);<span class="comment">//杀死子进程，避免出现僵尸进程</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;reg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>) &#123;<span class="comment">//获取寄存器内容</span></span><br><span class="line">                    <span class="built_in">ptrace</span>(PTRACE_GETREGS, pid, <span class="literal">nullptr</span>, &amp;regs);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;rax\t%llx\nrbx\t%llx\nrcx\t%llx\nrdx\t%llx\nrsi\t%llx\nrdi\t%llx\nrbp\t%llx\n&quot;</span></span><br><span class="line">                           <span class="string">&quot;rsp\t%llx\nrip\t%llx\neflags\t%llx\ncs\t%llx\nss\t%llx\nds\t%llx\nes\t%llx\n&quot;</span>,</span><br><span class="line">                           regs.rax, regs.rbx, regs.rcx, regs.rdx, regs.rsi, regs.rdi, regs.rbp,</span><br><span class="line">                           regs.rsp, regs.rip, regs.eflags, regs.cs, regs.ss, regs.ds, regs.es);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;step&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;s&quot;</span>) == <span class="number">0</span>) &#123;<span class="comment">//单步调试</span></span><br><span class="line">                    <span class="built_in">ptrace</span>(PTRACE_SINGLESTEP, pid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);<span class="comment">//发送single step给子进程</span></span><br><span class="line">                    <span class="built_in">wait</span>(&amp;status);<span class="comment">//等待子进程收到sigtrap信号</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;<span class="comment">//执行到最后一条指令退出循环，同时父进程也会结束</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Process finished.\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;continue&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;c&quot;</span>) == <span class="number">0</span>) &#123;<span class="comment">//继续执行</span></span><br><span class="line">                    <span class="built_in">ptrace</span>(PTRACE_CONT, pid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);<span class="comment">//继续执行，一直到子进程发出发出暂停信号</span></span><br><span class="line">                    <span class="built_in">wait</span>(&amp;status);<span class="comment">//等待子进程停止，并获取子进程状态值</span></span><br><span class="line">                    <span class="keyword">if</span> (!breakpoint.breakpoint_mode) &#123;<span class="comment">//没有断点，一直执行到子进程结束</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;Process finished.\n&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//断点模式被激活，breakpoint_mode字段被置为true</span></span><br><span class="line">                        <span class="built_in">wait_breakpoint</span>(pid, status, breakpoint);<span class="comment">//等待并判断断点是否被命中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;memory&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;m&quot;</span>) == <span class="number">0</span>) &#123;<span class="comment">//获取子进程制定区域的内存内容</span></span><br><span class="line">                    <span class="built_in">ptrace</span>(PTRACE_GETREGS, pid, <span class="literal">nullptr</span>, &amp;regs);</span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">Params</span> &#123;<span class="comment">//默认地址采用rip指针的内容，偏移默认为0，默认读取40个字节</span></span><br><span class="line">                        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr;</span><br><span class="line">                        <span class="type">long</span> offset;</span><br><span class="line">                        <span class="type">int</span> nbytes;</span><br><span class="line">                    &#125; params = &#123;regs.rip, <span class="number">0</span>, <span class="number">40</span>&#125;;</span><br><span class="line">                    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">showMemory</span>(pid, regs.rip);<span class="comment">//显示内存内容</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;<span class="comment">//检查是否有额外参数指定</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[i], <span class="string">&quot;-addr&quot;</span>) == <span class="number">0</span>) &#123;<span class="comment">//指定内存的起始地址</span></span><br><span class="line">                                params.addr = <span class="built_in">strtol</span>(arguments[++i], <span class="literal">nullptr</span>, <span class="number">16</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;<span class="comment">//当前参数指定功能，下一个参数指定具体的值，两项获取之后直接跳一步检查别的参数</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[i], <span class="string">&quot;-off&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                                params.offset = <span class="built_in">strtol</span>(arguments[++i], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[i], <span class="string">&quot;-nb&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                                params.nbytes = <span class="built_in">strtol</span>(arguments[++i], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">showMemory</span>(pid, params.addr, params.offset, params.nbytes);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;ic&quot;</span>) == <span class="number">0</span>) &#123;<span class="comment">//计算执行完毕所需指令数</span></span><br><span class="line">                    <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//                    struct user_regs_struct temp_regs&#123;&#125;;//存储子进程当前寄存器的值</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="built_in">wait</span>(&amp;status);<span class="comment">//当前子进程还是暂停状态，父进程被阻塞</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;\ntotal instruction count is %ld\n&quot;</span>, count);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//指令执行完子进程也结束运行了，父进程退出</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">ptrace</span>(PTRACE_SINGLESTEP, pid, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);<span class="comment">//单步执行下一条指令</span></span><br><span class="line"><span class="comment">//                        ptrace(PTRACE_GETREGS, pid, nullptr, &amp;temp_regs);</span></span><br><span class="line"><span class="comment">//                        printf(&quot;RIP:%llx\t&quot;, temp_regs.rip);</span></span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;break&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;b&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;<span class="comment">//打断点</span></span><br><span class="line">                        <span class="built_in">get_base_address</span>(pid, base_addr);<span class="comment">//获取子进程的起始虚拟地址</span></span><br><span class="line">                        <span class="comment">//输入的地址实际上是利用objdump反汇编得到的偏移地址，相加得到在虚拟内存中的实际地址</span></span><br><span class="line">                        breakpoint.addr = <span class="built_in">strtol</span>(arguments[<span class="number">1</span>], <span class="literal">nullptr</span>, <span class="number">16</span>) + base_addr;</span><br><span class="line">                        <span class="built_in">breakpoint_inject</span>(pid, breakpoint);<span class="comment">//注入断点</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Please input the address of breakpoint!\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;help&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(arguments[<span class="number">0</span>], <span class="string">&quot;h&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">show_help</span>();<span class="comment">//显示帮助信息</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;Invalid Argument!\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                argv.<span class="built_in">clear</span>();<span class="comment">//下一轮参数输入之前需要把当前存储的命令清除</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">wait</span>(&amp;status);<span class="comment">//等待子进程结束之后父进程再退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">argparse</span><span class="params">()</span> </span>&#123;<span class="comment">//解析输入参数</span></span><br><span class="line">    string param;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i:cmd + <span class="string">&quot; &quot;</span>) &#123;<span class="comment">//因为要用到空格进行分割，为了防止最后一个参数分割不到加一个空格</span></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            param += i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            argv.<span class="built_in">push_back</span>(param);</span><br><span class="line">            param = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 从子进程指定地址读取数据</span></span><br><span class="line"><span class="comment"> * child: 子进程pid号</span></span><br><span class="line"><span class="comment"> * addr: 地址</span></span><br><span class="line"><span class="comment"> * str: 用来存储读取的字节</span></span><br><span class="line"><span class="comment"> * len: 读取字节长度</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdata</span><span class="params">(<span class="type">pid_t</span> child, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">char</span>* str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* laddr = str;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = len / LONG_SIZE;<span class="comment">//计算一共需要读取多少个字</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">u</span> &#123;</span><br><span class="line">        <span class="type">long</span> val;</span><br><span class="line">        <span class="type">char</span> chars[LONG_SIZE];</span><br><span class="line">    &#125; word&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">//每次读取1个字，8个字节，每次地址加8(LONG_SIZE)</span></span><br><span class="line">        word.val = <span class="built_in">ptrace</span>(PTRACE_PEEKDATA, child, addr + i * LONG_SIZE, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (word.val == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;trace error&quot;</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, word.chars, LONG_SIZE);<span class="comment">//将这8个字节拷贝进数组</span></span><br><span class="line">        ++i;</span><br><span class="line">        laddr += LONG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % LONG_SIZE;<span class="comment">//不足一个字的虚读一个字</span></span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        word.val = <span class="built_in">ptrace</span>(PTRACE_PEEKDATA, child, addr + i * LONG_SIZE, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (word.val == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;trace error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 从子进程指定地址插入数据</span></span><br><span class="line"><span class="comment"> * child: 子进程pid号</span></span><br><span class="line"><span class="comment"> * addr: 地址</span></span><br><span class="line"><span class="comment"> * str: 用来插入的字节</span></span><br><span class="line"><span class="comment"> * len: 插入字节数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putdata</span><span class="params">(<span class="type">pid_t</span> child, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">char</span>* str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* laddr = str;<span class="comment">//与getdata类似</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = len / LONG_SIZE;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">u</span> &#123;</span><br><span class="line">        <span class="type">long</span> val;</span><br><span class="line">        <span class="type">char</span> chars[LONG_SIZE];</span><br><span class="line">    &#125; word&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(word.chars, laddr, LONG_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_POKEDATA, child, addr + i * LONG_SIZE, word.val) == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;trace error&quot;</span>);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += LONG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % LONG_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        word.val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(word.chars, laddr, j);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_POKEDATA, child, addr + i * LONG_SIZE, word.val) == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;trace error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 按字节打印数据</span></span><br><span class="line"><span class="comment"> * tip: 可以附带 字符串输出</span></span><br><span class="line"><span class="comment"> * codes: 需要打印的字节</span></span><br><span class="line"><span class="comment"> * len: 需要打印的字节数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBytes</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* tip, <span class="type">char</span>* codes, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, tip);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, (<span class="type">unsigned</span> <span class="type">char</span>) codes[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 显示任意内存内容</span></span><br><span class="line"><span class="comment"> * pid: 子进程pid</span></span><br><span class="line"><span class="comment"> * addr: 指定内存基地址</span></span><br><span class="line"><span class="comment"> * offset: 指定相对于基地址的偏移地址</span></span><br><span class="line"><span class="comment"> * nbytes: 需要显示的字节数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMemory</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">long</span> offset, <span class="type">int</span> nbytes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current base address is : 0x%llx\n&quot;</span><span class="comment">//显示任意内存内容</span></span><br><span class="line">           <span class="string">&quot;offset is : %ld\n&quot;</span>, addr, offset);</span><br><span class="line">    <span class="keyword">auto</span>* memory_content = <span class="keyword">new</span> <span class="type">char</span>[nbytes];</span><br><span class="line">    <span class="built_in">getdata</span>(pid, addr + offset, memory_content, nbytes);<span class="comment">//从指定的地址按照指定的偏移量读取指定的字节数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The %d bytes after start address: 0x%llx :\n&quot;</span>, nbytes, addr + offset);</span><br><span class="line">    <span class="built_in">printBytes</span>(<span class="string">&quot;&quot;</span>, memory_content, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 注入断点</span></span><br><span class="line"><span class="comment"> * pid: 子进程pid</span></span><br><span class="line"><span class="comment"> * bp: 断点结构体</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">breakpoint_inject</span><span class="params">(<span class="type">pid_t</span> pid, Breakpoint&amp; bp)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> code[LONG_SIZE] = &#123;<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(<span class="number">0xcc</span>)&#125;;<span class="comment">//int3中断指令</span></span><br><span class="line">    <span class="comment">//copy instructions into backup variable</span></span><br><span class="line">    <span class="built_in">getdata</span>(pid, bp.addr, bp.backup, CODE_SIZE);<span class="comment">//先把需要打断点的地址上指令取出备份</span></span><br><span class="line">    <span class="built_in">printBytes</span>(<span class="string">&quot;get tracee instruction: &quot;</span>, bp.backup, LONG_SIZE);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;try to set breakpoint&quot;</span>);</span><br><span class="line">    <span class="built_in">printBytes</span>(<span class="string">&quot;set breakpoint instruction: &quot;</span>, code, LONG_SIZE);</span><br><span class="line">    <span class="built_in">putdata</span>(pid, bp.addr, code, CODE_SIZE);<span class="comment">//将中断指令int3注入</span></span><br><span class="line">    bp.breakpoint_mode = <span class="literal">true</span>;<span class="comment">//将断点模式标识变量置为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 等待断点，判断是否命中</span></span><br><span class="line"><span class="comment"> * pid: 子进程pid</span></span><br><span class="line"><span class="comment"> * status: 由外部传入，获取当前tracee停止的状态码</span></span><br><span class="line"><span class="comment"> * bp: 断点结构体</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait_breakpoint</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> status, Breakpoint&amp; bp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_regs_struct</span> regs&#123;&#125;;</span><br><span class="line">    <span class="comment">/* 捕获信号之后判断信号类型*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">        <span class="comment">/* 如果是EXit信号 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nsubprocess EXITED!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) &#123;</span><br><span class="line">        <span class="comment">/* 如果是STOP信号 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WSTOPSIG</span>(status) == SIGTRAP) &#123;                <span class="comment">//如果是触发了SIGTRAP,说明碰到了断点</span></span><br><span class="line">            <span class="built_in">ptrace</span>(PTRACE_GETREGS, pid, <span class="number">0</span>, &amp;regs);    <span class="comment">//读取此时用户态寄存器的值，准备为回退做准备</span></span><br><span class="line">            <span class="comment">/* 将此时的指针与我的addr做对比，如果满足关系，说明断点命中 */</span></span><br><span class="line">            <span class="keyword">if</span> (bp.addr != (regs.rip - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">/*未命中*/</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Miss, fail to hit, rip:0x%llx\n&quot;</span>, regs.rip);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*如果命中*/</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hit Breakpoint at: 0x%llx\n&quot;</span>, bp.addr);</span><br><span class="line">                <span class="comment">/*把INT 3 patch 回本来正常的指令*/</span></span><br><span class="line">                <span class="built_in">putdata</span>(pid, bp.addr, bp.backup, CODE_SIZE);</span><br><span class="line">                <span class="built_in">ptrace</span>(PTRACE_SETREGS, pid, <span class="literal">nullptr</span>, &amp;regs);</span><br><span class="line">                <span class="comment">/*执行流回退，重新执行正确的指令*/</span></span><br><span class="line">                regs.rip = bp.addr;<span class="comment">//addr与rip不相等，恢复时以addr为准</span></span><br><span class="line">                <span class="built_in">ptrace</span>(PTRACE_SETREGS, pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">                bp.breakpoint_mode = <span class="literal">false</span>;<span class="comment">//命中断点之后取消断点状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * 获取子进程再虚拟地址空间的起始地址</span></span><br><span class="line"><span class="comment"> * pid: 子进程pid</span></span><br><span class="line"><span class="comment"> * base_addr: 用来存储起始地址</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_base_address</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&amp; base_addr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * Linux将每一个进程的内存分布暴露出来，以供读取</span></span><br><span class="line"><span class="comment">     * 每个进程的内存分布文件放在/proc/进程pid/maps文件夹里</span></span><br><span class="line"><span class="comment">     * 通过获取pid来读取对应的maps文件</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    string memory_path = <span class="string">&quot;/proc/&quot;</span> + <span class="built_in">to_string</span>(pid) + <span class="string">&quot;/maps&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">inf</span><span class="params">(memory_path.data())</span></span>;<span class="comment">//建立输入流</span></span><br><span class="line">    <span class="keyword">if</span> (!inf) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;read failed!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(inf, line);<span class="comment">//读第一行，根据文件的特点，起始地址之后是&quot;-&quot;字符</span></span><br><span class="line">    base_addr = <span class="built_in">strtol</span>(line.<span class="built_in">data</span>(), <span class="literal">nullptr</span>, <span class="number">16</span>);<span class="comment">//默认读到&quot;-&quot;字符为止，16进制</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get base_addr:0x&quot;</span> &lt;&lt; hex &lt;&lt; base_addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_help</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type \&quot;exit\&quot; to exit debugger.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type \&quot;reg\&quot; or \&quot;r\&quot; to show registers.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type \&quot;step\&quot; or \&quot;s\&quot; to single step.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type \&quot;continue\&quot; or \&quot;c\&quot; to continue until tracee stop.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type \&quot;memory\&quot; or \&quot;m\&quot; to show memory content.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tYou can use \&quot;-addr\&quot; or \&quot;-off\&quot; or \&quot;-nb\&quot; as argument.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tuse \&quot;-addr\&quot; to specify hexadecimal start address of the memory\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\t\tfor example: Type \&quot;m -addr ff\&quot; to specify the start address 0xff\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\t\t(default start address is RIP)\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tuse \&quot;-off\&quot; to specify the decimal offset from the start address\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\t\t(default offset is 0)\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tuse \&quot;-nb\&quot; to specify the decimal number of bytes to be displayed\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\t\t(default number is 40)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type \&quot;ic\&quot; to count total instructions.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type \&quot;break\&quot; or \&quot;b\&quot; to insert breakpoint.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tfor example: Type \&quot;b 555555555131\&quot; to specify the breakpoint address 0x555555555131\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.zhihu.com/question/60558543">linux工具pmap原理？ - 知乎</a><br><a href="https://www.coder.work/article/6731993">linux - 在 Linux 中如何确定 PIE 可执行文件的文本部分的地址？ - IT工具网</a><br><a href="https://www.cnblogs.com/xzzzh/p/6596982.html">Linux虚拟地址空间布局以及进程栈和线程栈总结 - Xzzzh - 博客园</a><br><a href="https://www.cnblogs.com/clover-toeic/p/3754433.html">Linux虚拟地址空间布局 - clover_toeic - 博客园</a><br><a href="https://www.cnblogs.com/yhjoker/p/9161716.html">针对 Linux 环境下 gdb 动态调试获取的局部变量地址与直接运行程序时不一致问题的解决方案 - yhjoker - 博客园</a><br><a href="https://blog.tartanllama.xyz/writing-a-linux-debugger-registers/">Writing a Linux Debugger Part 3: Registers and memory</a><br><a href="https://www.cnblogs.com/binfun/p/14175659.html">浅析Linux 64位系统虚拟地址和物理地址的映射及验证方法 - Binfun - 博客园</a><br><a href="https://cloud.tencent.com/developer/article/1626930">Linux：断点原理与实现 - 云+社区 - 腾讯云</a><br><a href="https://zhuanlan.zhihu.com/p/272135463">一口气看完45个寄存器，CPU核心技术大揭秘 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/110793460">断点原理与实现 - 知乎</a><br><a href="https://mp.weixin.qq.com/s/teERWh9IRMuO6tieOZNNng">一窥GDB原理</a><br><a href="https://www.anquanke.com/post/id/231078#h3-3">Linux沙箱入门——ptrace从0到1 - 安全客，安全资讯平台</a><br><a href="https://www.cnblogs.com/tongye/p/9558320.html">Linux内核学习笔记（4）— wait、waitpid、wait3 和 wait4 - tongye - 博客园</a><br><a href="https://cloud.tencent.com/developer/article/1742878">GDB原理之ptrace实现原理 - 云+社区 - 腾讯云</a><br><a href="https://cloud.tencent.com/developer/article/1823078?from=article.detail.1823077">用图文带你彻底弄懂GDB调试原理 - 云+社区 - 腾讯云</a><br><a href="https://evilpan.com/2016/02/22/linux-hook-ptrace/">Linux Hook 笔记 - evilpan</a><br><a href="https://bbs.pediy.com/thread-265599.htm">[原创]一窥GDB原理-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a><br><a href="https://www.anquanke.com/post/id/231078">Linux沙箱入门——ptrace从0到1 - 安全客，安全资讯平台</a><br><a href="https://www.cnblogs.com/zy666/p/10504272.html">Linux信号列表及其详解 - zy010101 - 博客园</a><br><a href="https://www.jianshu.com/p/f445bfeea40a">Linux 信号（signal） - 简书</a><br><a href="https://www.onitroad.com/jc/linux/man-pages/linux/man2/ptrace.2.html">PTRACE - Linux手册页-之路教程</a><br><a href="https://www.cnblogs.com/charlesblc/p/6434321.html">Linux的中断和系统调用 &amp; esp、eip等寄存器 - blcblc - 博客园</a><br><a href="https://gohalo.me/post/linux-ptrace-api-introduce.html">Linux ptrace 简介</a><br><a href="https://www.cnblogs.com/pannengzhi/p/5203467.html">Linux Hook 笔记 - 有价值炮灰 - 博客园</a><br><a href="https://www.cnblogs.com/mmmmar/p/6048711.html">linux ptrace II - mmmmar - 博客园</a><br><a href="https://0litost0.github.io/2018/10/14/Ptrace-Linux%E4%B8%AD%E4%B8%80%E7%A7%8D%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8/">Ptrace—Linux中一种代码注入技术的应用 | 力托斯特的博客</a><br><a href="https://www.cnblogs.com/mmmmar/p/6040325.html">linux ptrace I - mmmmar - 博客园</a><br><a href="https://www.cnblogs.com/dongguolei/p/8086346.html">linux中fork（）函数详解 - 学习记录园 - 博客园</a><br><a href="https://www.cnblogs.com/catch/p/3476280.html">[译] 玩转ptrace (一) - twoon - 博客园</a><br><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/print-process-memory.html">打印进程内存信息 | 100个gdb小技巧</a><br><a href="https://ch4r1l3.github.io/2018/06/22/pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94gdb%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">pwn从入门到放弃第三章——gdb的基本使用教程 | PWN? PWN!</a><br><a href="https://www.thinbug.com/q/21742827">c - objdump -d输出汇编的含义 - Thinbug</a><br><a href="https://www.thinbug.com/q/50594438">c - 为什么GDB和Objdump的指令地址相同？ - Thinbug</a><br><a href="https://devbins.github.io/post/gdb/">GDB调试 - devbins blog</a><br><a href="https://codeantenna.com/a/PsCThgFbhG">调试器工作原理之二——实现断点(ptrace) - CodeAntenna</a><br><a href="https://www.cnblogs.com/yungyu16/p/13024485.html">汇编语言基础:寄存器和系统调用 - Yungyu - 博客园</a><br><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/break-on-address.html">在程序地址上打断点 | 100个gdb小技巧</a><br><a href="https://www.cnblogs.com/Anker/p/3438480.html">C语言指针转换为intptr_t类型 - Rabbit_Dale - 博客园</a><br><a href="https://www.cnblogs.com/ym65536/p/4542646.html">x86_64汇编基础 - ym65536 - 博客园</a><br><a href="https://mp.weixin.qq.com/s/XxPIfrQ3E0GR88UsmQNggg">GDB调试-从入门实践到原理</a><br><a href="https://blog.csdn.net/wwchao2012/article/details/79980514">objdump(Linux)反汇编命令使用指南_wang.wenchao的博客-CSDN博客_linux 反汇编</a><br><a href="https://blog.csdn.net/xiamo20149/article/details/51964945">解决munmap_chunk(): invalid pointer和Segmentation fault的bug_summer的专栏-CSDN博客_munmap_chunk()</a><br><a href="https://blog.csdn.net/weixin_33895016/article/details/92754025">调试器工作原理之二——实现断点(ptrace)_weixin_33895016的博客-CSDN博客</a><br><a href="https://blog.csdn.net/counsellor/article/details/100034080">gdb查看当前汇编指令_counsellor的专栏-CSDN博客_gdb 查看汇编</a><br><a href="https://blog.csdn.net/beyondioi/article/details/7796414">objdump命令的使用_北落师门’的专栏-CSDN博客_objdump</a><br><a href="https://blog.csdn.net/lizhidefengzi/article/details/70231334">进程与进程描述符（task<em>struct）_Steve_Abelieve-CSDN博客</em>进程描述符</a><br><a href="https://blog.csdn.net/weixin_45505313/article/details/105287599">Linux 查看进程内存分布_谈谈1974-CSDN博客_linux 查看内存布局</a><br><a href="https://blog.csdn.net/counsellor/article/details/81543197">Linux下关闭ALSR(地址空间随机化)的方法_counsellor的专栏-CSDN博客_linux关闭地址随机化</a><br><a href="https://blog.csdn.net/Plus_RE/article/details/79199772">Linux平台的ASLR机制_加号减减号的博客-CSDN博客_aslr linux</a><br><a href="https://blog.csdn.net/ayu_ag/article/details/50737209">ELF entry point和装载地址_ayu_ag的专栏-CSDN博客_elf入口地址</a><br><a href="https://blog.csdn.net/weixin_34567845/article/details/116691038">linux中如何断点调试程序,开发一个Linux调试器（二）：断点_刘为龙的博客-CSDN博客</a><br><a href="https://blog.csdn.net/I_just_smile/article/details/106174289">Linux 命令（1）—— nm 命令_baboon_chen-CSDN博客</a><br><a href="https://blog.csdn.net/Wu_Roc/article/details/77203480">Linux X86<em>64位虚拟地址空间布局与试验_Meows的牧场-CSDN博客</em>虚拟空间64位</a><br><a href="https://blog.csdn.net/feelabclihu/article/details/108289461">深入理解 Linux 位置无关代码 PIC_内核工匠-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_44395686/article/details/104761488">Linux ELF装载过程及64位地址空间布局_@HDS的博客-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_42410566/article/details/116819824">linux内存地址断点,开发一个 Linux 调试器（三）：寄存器和内存_别总叫我大叔的博客-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_44966641/article/details/120616894">链接与加载-NJU-JYY_Adenialzz的博客-CSDN博客</a><br><a href="https://blog.csdn.net/neilhhw/article/details/14408637">自己写调试器 软断点 [Linux]_氺在飛天-CSDN博客</a><br><a href="https://blog.csdn.net/darmao/article/details/78535329">linux调试器的实现—-断点的实现_darmao的博客-CSDN博客_linux打断点</a><br><a href="https://blog.csdn.net/baidu_35679960/article/details/80463445">LINUX 逻辑地址、线性地址、虚拟地址和物理地址_十一月zz的博客-CSDN博客_linux 逻辑地址</a><br><a href="https://jrhar.blog.csdn.net/article/details/78508795">详解：物理地址，虚拟地址，内存管理，逻辑地址之间的关系<em>17岁boy的博客-CSDN博客</em>逻辑地址与物理地址</a><br><a href="https://blog.csdn.net/syzcch/article/details/8350189">调试器工作原理系列三篇_关注 Linux c/c++ 数据存储 网络 算法……-CSDN博客</a><br><a href="https://blog.csdn.net/u012417380/article/details/60468697">Linux源码分析之Ptrace_七月冷雨-CSDN博客_linux ptrace</a><br><a href="https://blog.csdn.net/qq_29328443/article/details/107250889">x86_64汇编之六：系统调用（system call）_ponnylv的博客-CSDN博客</a><br><a href="https://blog.csdn.net/u012417380/article/details/60470075">Linux Ptrace 详解_七月冷雨-CSDN博客_linux ptrace</a><br><a href="https://blog.csdn.net/zhangmiaoping23/article/details/51405281">玩转ptrace(二)_zhangmiaoping23的专栏-CSDN博客</a><br><a href="https://wangquan.blog.csdn.net/article/details/108471212">linux系统：ptrace系统调用浅析_老王不让用的博客-CSDN博客_ptrace 函数调用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【博客】Hexo在多台电脑上提交和更新</title>
      <link href="/2022/01/10/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0/"/>
      <url>/2022/01/10/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我现在有两台电脑，最初第一次装好hexo环境的电脑在宿舍，姑且叫这台电脑<strong>“老电脑”</strong>吧，代表最初拥有hexo环境的电脑，然后事情是这样的去到工位的电脑上想要更新博客总是要远程启动宿舍的电脑才行，于是想要在工位电脑也能更新，这里工位的电脑姑且叫做<strong>“新电脑”</strong>吧。</p><p>最初搞这个多设备同步属实折腾了好半天，看了很多博客也在知乎上参考了不少，但总是需要在不同博客之间相互参考最终才完美解决，所以想要把这几天的经历总结一下。</p><h2 id="一-hexo同步原理"><a href="#一-hexo同步原理" class="headerlink" title="一. hexo同步原理"></a>一. hexo同步原理</h2><h3 id="1-hexo博客目录结构说明"><a href="#1-hexo博客目录结构说明" class="headerlink" title="1.  hexo博客目录结构说明"></a>1.  hexo博客目录结构说明</h3><p>这是老电脑上的目录结构</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171703193.png" alt=""></p><div class="table-container"><table><thead><tr><th style="text-align:left">文件夹</th><th>说明</th><th style="text-align:left">是否需要上传github</th></tr></thead><tbody><tr><td style="text-align:left">node_modules</td><td>hexo需要的模块，就是一些基础的npm安装模块，比如一些美化插件，在执行<code>npm install</code>的时候会重新生成</td><td style="text-align:left">不需要</td></tr><tr><td style="text-align:left">themes</td><td>主题文件</td><td style="text-align:left">需要</td></tr><tr><td style="text-align:left">public</td><td>hexo g命令执行后生成的静态页面文件</td><td style="text-align:left">不需要</td></tr><tr><td style="text-align:left">packages.json</td><td>记录了hexo需要的包的信息，之后换电脑了npm根据这个信息来安装hexo环境</td><td style="text-align:left">需要</td></tr><tr><td style="text-align:left">_config.yml</td><td>全局配置文件，这个不用多说了吧</td><td style="text-align:left">需要</td></tr><tr><td style="text-align:left">.gitignore</td><td>hexo生成的默认的.gitignore模块</td><td style="text-align:left">需要</td></tr><tr><td style="text-align:left">scaffolds</td><td>文章的模板</td><td style="text-align:left">需要</td></tr><tr><td style="text-align:left">.deploy_git</td><td>hexo g自动生成的</td><td style="text-align:left">不需要</td></tr></tbody></table></div><h3 id="2-同步原理"><a href="#2-同步原理" class="headerlink" title="2. 同步原理"></a>2. 同步原理</h3><p>主要思路是利用git分支来实现hexo的同步。</p><p>hexo生成的静态页面文件默认放在master分支上，这是由_config.yml配置文件所决定的</p><p>你可以在全局配置文件_config.yml中找到这么一段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>因此每当我们执行hexo d的时候，hexo都会帮我们把生成好的静态页面文件推到master分支上。</p><p>(我这里可能和你的不太一样，因为之前使用http推送经常由于网络问题推送上不去，所以我复制了username.github.io仓库的ssh链接，用ssh推送成功率更搞，所以我的链接形式是git@github.com:username/username.github.io.git这样的)</p><p>在我们第一次部署好博客的时候，github给我们创建的唯一一个分支就是master分支，同时也是默认分支。默认分支就意味着每次我们执行<code>git clone 仓库地址</code>或者<code>git pull 仓库地址</code>拉取的是默认分支的代码。</p><p>但是执行hexo d 对应的分支和默认分支是没有关系的，因为这是由配置文件决定的，配置文件写的哪个分支就是哪个分支。</p><p>因此，hexo生成的静态博客文件默认放在master分支上。hexo的源文件（部署环境文件）可以都放在source分支上（可以新创建一个source分支）。然后把source分支设置成默认分支。有小伙伴可能会担心默认分支的改变会不会影响到原来的网页的正常显示，其实如果是用GitHub Pages对博客进行托管的话也很简单，第一次搭建博客默认使用master分支作为页面。在下图所示的设置里可以找到。如果不小心搞错了只要把分支设置成静态页面对应的分支就好了。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171704332.png" alt=""></p><p>把source分支设置成默认分支，用来存放源文件，master分支依然存放静态文件。在<strong>老电脑</strong>上，我们需要把必要的源文件push到source分支。换<strong>新电脑</strong>时，直接<code>git clone 仓库地址</code>此时会从source分支下载源文件，剩下的就是安装hexo环境，在<strong>新电脑</strong>上就可以重新生成静态页面了，并且因为配置文件clone下来，deploy配置依旧是master分支，所以在<strong>新电脑</strong>上执行<code>hexo d</code>还是会把更新过后的静态文件推送到master分支上。</p><p>由于master分支和source分支实际上是相互独立的两个普通的分支，所以我们源文件和静态页面的更新也是相互独立的，故而需要手动分别执行<code>git add . git commit git push</code>来更新源文件,然后执行<code>hexo d</code>更新静态页面。</p><h2 id="二-老电脑上的具体操作"><a href="#二-老电脑上的具体操作" class="headerlink" title="二. 老电脑上的具体操作"></a>二. 老电脑上的具体操作</h2><p>这里直接引用我看的一篇博客的步骤,</p><p><strong>1.github准备</strong></p><p>先创建一个分支hexo</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171704027.jpeg" alt="img"></p><p>将其设置为默认分支</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171704140.jpeg" alt="img"></p><p><strong>2.打包将要推送到GitHub上的原始文件</strong></p><p>（1）clone该仓库到本地（clone的是hexo默认分支）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure><p>（2）下载的文件夹里仅留下.git 文件夹，其他的文件都删除</p><p>（3）找见我们hexo原位置，将hexo文件夹内除.deploy_git 以外都复制到clone下来的文件夹中</p><p>注意：1.现在clone下来的文件夹内应该有个<code>.gitignore文件</code>，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p>2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除。因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</p><p><strong>3.将clone并修改以后的文件夹推送到远程库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m add_branch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>此时已经成功将整个网站推送到了远程库的默认分支hexo</p><p><strong>补充：后续写文章、修改配置后的保存推送操作</strong></p><p>至此，网站部署至master分支，整个网站备份至hexo分支。当网站的配置或文章修改后都要将远程仓库更新。首先，依次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .``git commit -m ChangeFiles（更新信息内容可改)``git push （或者git push origin hexo)</span><br></pre></td></tr></table></figure><p>保证hexo分支版本最新。然后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>（在此之前，有时可能需要执行<code>hexo clean</code>），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！</p><h2 id="二-新电脑上的操作"><a href="#二-新电脑上的操作" class="headerlink" title="二. 新电脑上的操作"></a>二. 新电脑上的操作</h2><ul><li>将新电脑的生成的ssh key添加到GitHub账户上</li><li>在新电脑上克隆username.github.io仓库的source分支(就是存放源码的分支)到本地，此时本地git仓库处于source分支,可以执行<code>git branch -v</code>查看。</li><li>在新电脑的username.github.io文件夹下执行<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>（记得，不需要hexo init这条指令）</li><li>最后执行<code>hexo g</code>、<code>hexo s</code>、<code>hexo d</code>等命令即可提交成功</li></ul><p>上面步骤中，<code>npm install</code>其实就是读取了packages.json里面的信息，自动安装依赖，有的小伙伴可能只执行<code>npm install</code>就行了，不过按照上面的三步是最稳妥的。</p><p>这里提一嘴，当新电脑上的操作成功之后，其实对于新电脑还是老电脑其实都无所谓了，任何一台电脑包括老电脑只要安装了NodeJs环境，就都可以按照在新电脑上的操作完整地复刻出一个hexo环境，你甚至可以把老电脑原有的hexo工程删掉再执行上面这几步一样可以快速构建hexo环境，可以看到步骤非常简单。</p><p>此外，为了保证同步，推荐先<code>git pull</code>合并更新再进行博客的编写。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/0b1fccce74e0">利用Hexo在多台电脑上提交和更新github pages博客 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/wy0526/p/13066869.html">hexo源码上传到GitHub-以防多台电脑操作/重装系统/要将hexo移动到其他磁盘 - 巧莓兔 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jianshu.com/p/57b5a384f234">Hexo博客备份 - 简书 (jianshu.com)</a></p><p><a href="https://www.zhihu.com/question/21193762">使用hexo，如果换了电脑怎么更新博客？ - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】ELF文件解析</title>
      <link href="/2021/12/10/ELF%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/12/10/ELF%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近选了Linux内核原理的选修课，虽然因为课时比较短涉及到的内容只能涵盖Linux知识的一小部分，但是老师的水平确实很高，讲的知识也很深入，这次布置的小作业是编写Linux平台下的C语言程序实现如下功能：</p><p>模仿实现Linux下readelf工具的部分功能，能够对ELF可执行文件进行简单分析。（至少支持readelf工具的-h、-S、-s三个命令选项功能）</p><p>关于原理部分自认为没有能力和大佬们讲得一样透彻清楚，所以参考文章链接贴在了文章的末尾，看了一定就会明白的。</p><h2 id="1-ELF文件介绍"><a href="#1-ELF文件介绍" class="headerlink" title="1.ELF文件介绍"></a>1.ELF文件介绍</h2><p>在 Linux 系统中，一个 ELF 文件主要用来表示 3 种类型的文件：</p><ul><li>可执行文件：被操作系统中的加载器从硬盘上读取，载入到内存中去执行;</li><li>目标文件：被链接器读取，用来产生一个可执行文件或者共享库文件;</li><li>共享库文件：在动态链接的时候，由 ld-linux.so 来读取;</li></ul><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171700566.png" alt="img" style="zoom:80%;" /></p><h2 id="2-readelf命令"><a href="#2-readelf命令" class="headerlink" title="2.readelf命令"></a>2.readelf命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-a ：--all 显示全部信息,等价于 -h -l -S -s -r -d -V -A -I</span><br><span class="line">-h ：--file-header 显示elf文件开始的文件头信息. </span><br><span class="line">-l ：--program-headers  ；--segments 显示程序头（段头）信息(如果有的话)。 </span><br><span class="line">-S ：--section-headers  ；--sections 显示节头信息(如果有的话)。 </span><br><span class="line">-g ：--section-groups 显示节组信息(如果有的话)。</span><br><span class="line">-t ：--section-details 显示节的详细信息(-S的)。 </span><br><span class="line">-s ：--syms  ；--symbols 显示符号表段中的项（如果有的话）。 </span><br><span class="line">-e ：--headers 显示全部头信息，等价于: -h -l -S </span><br><span class="line">-n ：--notes 显示note段（内核注释）的信息。 </span><br><span class="line">-r ：--relocs 显示可重定位段的信息。 </span><br><span class="line">-u ：--unwind 显示unwind段信息。当前只支持IA64 ELF的unwind段信息。 </span><br><span class="line">-d ：--dynamic 显示动态段的信息。 </span><br><span class="line">-V ：--version-info 显示版本段的信息。 </span><br><span class="line">-A ：--arch-specific 显示CPU构架信息。 </span><br><span class="line">-D ：--use-dynamic 使用动态段中的符号表显示符号，而不是使用符号段。 </span><br><span class="line">-x &lt;number or name&gt; ：--hex-dump=&lt;number or name&gt; 以16进制方式显示指定段内内容。number指定段表中段的索引,或字符串指定文件中的段名。 </span><br><span class="line">-w[liaprmfFsoR]或者</span><br><span class="line">-debugdump[=line,=info,=abbrev,=pubnames,=aranges,</span><br><span class="line">=macro,=frames,=frames-interp,=str,=loc,=Ranges] 显示调试段中指定的内容。 </span><br><span class="line">-I ：--histogram 显示符号的时候，显示bucket list长度的柱状图。 </span><br><span class="line">-v ：--version 显示readelf的版本信息。 </span><br><span class="line">-H ：--<span class="built_in">help</span> 显示readelf所支持的命令行选项。 </span><br><span class="line">-W ：--wide 宽行输出。 </span><br></pre></td></tr></table></figure><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h2><p><a href="https://github.com/Kakaluoto/ELFReader">Kakaluoto/ELFReader (github.com)</a></p><p>这次我一共分成了5个文件header.h ; main.cpp ; readelf_symbol.cpp ; readelf_Section.cpp ; readelf_header.cpp</p><p>头文件 header.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ELFREADER_HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFREADER_HEADER_H</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readelf_h</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readelf_S</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readelf_s</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ELFREADER_HEADER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数 main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="comment">//argv[0]是当前可执行文件路径</span></span><br><span class="line">    <span class="comment">//arv[1]是参数，参数以空格作为分隔符</span></span><br><span class="line">    <span class="comment">//argv[2]是被解析的可执行文件名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-h&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">readelf_h</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-S&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">readelf_S</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-s&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">readelf_s</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;invalid argument!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模仿readelf -h 的实现readelf_header.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readelf_h</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    FILE* fp;<span class="comment">//定义文件指针</span></span><br><span class="line">    Elf64_Ehdr elf_header;<span class="comment">//定义elf头用来存储</span></span><br><span class="line">    fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="built_in">fread</span>(&amp;elf_header, <span class="built_in">sizeof</span>(Elf64_Ehdr), <span class="number">1</span>, fp);<span class="comment">//读header</span></span><br><span class="line">    <span class="keyword">if</span> (elf_header.e_ident[<span class="number">0</span>] != <span class="number">0x7f</span> || elf_header.e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>) &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;<span class="comment">//判断是否是elf文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ELF Header:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Magic:\t&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> i : elf_header.e_ident) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Class:\t\t\t\t&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (elf_header.e_ident[EI_CLASS]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ELF%d\n&quot;</span>, <span class="number">32</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ELF%d\n&quot;</span>, <span class="number">64</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Data:\t\t\t\t\t&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (elf_header.e_ident[EI_DATA]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;2&#x27;s complement, little endian\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;2&#x27;s complement, big endian\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Version:\t\t\t\t%d (current)\n&quot;</span>, elf_header.e_ident[EI_VERSION]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  OS/ABI:\t\t\t\t&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (elf_header.e_ident[EI_OSABI]) &#123;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_NONE:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;UNIX System V ABI\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_HPUX:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;HP-UX\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_NETBSD:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NetBSD.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_GNU:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Object uses GNU ELF extensions.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_SOLARIS:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sun Solaris.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_AIX:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;IBM AIX.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_IRIX:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SGI Irix.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_FREEBSD:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;FreeBSD.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_TRU64:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Compaq TRU64 UNIX.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_MODESTO:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Novell Modesto.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_OPENBSD:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;OpenBSD.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_ARM_AEABI:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ARM EABI\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_ARM:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ARM\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ELFOSABI_STANDALONE:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Standalone (embedded) application\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ABI Version:\t\t\t\t%d\n&quot;</span>, elf_header.e_ident[EI_ABIVERSION]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Type:\t\t\t\t\t&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (elf_header.e_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ET_REL:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;REL (Relocatable file)\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ET_EXEC:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;EXEC (Executable file)\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ET_DYN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;DYN (Shared object file)\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Machine:\t\t\t\t&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (elf_header.e_machine) &#123;</span><br><span class="line">        <span class="keyword">case</span> EM_NONE:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No Machine!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_386:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Intel 80386\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_860:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Intel 80860\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_ARM:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ARM\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_X86_64:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;AMD x86-64 architecture\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_AVR:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Atmel AVR 8-bit microcontroller\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_MSP430:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Texas Instruments msp430\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_ALTERA_NIOS2:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Altera Nios II\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_MICROBLAZE:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Xilinx MicroBlaze\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_8051:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Intel 8051 and variants\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_STM8:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;STMicroelectronics STM8\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_CUDA:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NVIDIA CUDA\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_AMDGPU:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;AMD GPU\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_RISCV:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;RISC-V\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EM_BPF:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Linux BPF -- in-kernel virtual machine\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown Machine!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Version:\t\t\t\t%x\n&quot;</span>, elf_header.e_ident[EI_VERSION]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Entry point address:\t\t\t0x%016lx\n&quot;</span>, elf_header.e_entry);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Start of program headers:\t\t%ld (bytes into file)\n&quot;</span>, elf_header.e_phoff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Start of section headers:\t\t%ld (bytes into file)\n&quot;</span>, elf_header.e_shoff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Flags:\t\t\t\t0x%x\n&quot;</span>, elf_header.e_flags);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Size of this header:\t\t\t%d (bytes)\n&quot;</span>, elf_header.e_ehsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Size of program headers:\t\t%d (bytes)\n&quot;</span>, elf_header.e_phentsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Number of program headers:\t\t%d\n&quot;</span>, elf_header.e_phnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Size of section headers:\t\t%d (bytes)\n&quot;</span>, elf_header.e_shentsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Number of section headers:\t\t%d\n&quot;</span>, elf_header.e_shnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Section header string table index:\t%d\n&quot;</span>, elf_header.e_shstrndx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模仿readelf -S 的实现readelf_Section.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readelf_S</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    Elf64_Ehdr elf_header;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="built_in">fread</span>(&amp;elf_header, <span class="built_in">sizeof</span>(Elf64_Ehdr), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (elf_header.e_ident[<span class="number">0</span>] != <span class="number">0x7f</span> || elf_header.e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>) &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="comment">//定义数组用来存储段表里每一个section_header,段的数目:elf_header.e_shnum</span></span><br><span class="line">    Elf64_Shdr* sec_headers = <span class="keyword">new</span> Elf64_Shdr[elf_header.e_shnum];</span><br><span class="line">    <span class="comment">//将指针移动到段表起始地址，段起始地址elf_header.e_shoff即相对于整个elf文件的偏移量，SEEK_SET从文件起始开始偏移</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp, elf_header.e_shoff, SEEK_SET);</span><br><span class="line">    <span class="comment">//读section_header，每一个header大小为sizeof(Elf64_Shdr)，一共读elf_header.e_shnum个段表头</span></span><br><span class="line">    <span class="built_in">fread</span>(sec_headers, <span class="built_in">sizeof</span>(Elf64_Shdr), elf_header.e_shnum, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;There are %d section headers, starting at offset 0x%lx\n\n&quot;</span>, elf_header.e_shnum, elf_header.e_shoff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Section Headers:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> str_tab_ind = elf_header.e_shstrndx;<span class="comment">//获取字符串表在段表中的索引elf_header.e_shstrndx，用来读取段名</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp, sec_headers[str_tab_ind].sh_offset, SEEK_SET);<span class="comment">//将指针移动到字符串表</span></span><br><span class="line">    <span class="type">char</span>* string_table = <span class="keyword">new</span> <span class="type">char</span>[sec_headers[str_tab_ind].sh_size];<span class="comment">//构造字符数组用来存储字符串表里的字符</span></span><br><span class="line">    <span class="built_in">fread</span>(string_table, <span class="number">1</span>, sec_headers[str_tab_ind].sh_size, fp);<span class="comment">//将字符串表里面的字符全部读出来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取section段的类型,输入类型对应的数值，返回字符串型的类型名</span></span><br><span class="line">    <span class="keyword">auto</span> get_sh_type = [](<span class="type">int</span> sh_type, string&amp; sec_header_name) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (sh_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> SHT_NULL:</span><br><span class="line">                sec_header_name = <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_PROGBITS:</span><br><span class="line">                sec_header_name = <span class="string">&quot;PROGBITS&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_SYMTAB:</span><br><span class="line">                sec_header_name = <span class="string">&quot;SYMTAB&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_STRTAB:</span><br><span class="line">                sec_header_name = <span class="string">&quot;STRTAB&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_RELA:</span><br><span class="line">                sec_header_name = <span class="string">&quot;RELA&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_HASH:</span><br><span class="line">                sec_header_name = <span class="string">&quot;HASH&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_DYNAMIC:</span><br><span class="line">                sec_header_name = <span class="string">&quot;DYNAMIC&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_NOTE:</span><br><span class="line">                sec_header_name = <span class="string">&quot;NOTE&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_NOBITS:</span><br><span class="line">                sec_header_name = <span class="string">&quot;NOBITS&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_REL:</span><br><span class="line">                sec_header_name = <span class="string">&quot;REL&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_SHLIB:</span><br><span class="line">                sec_header_name = <span class="string">&quot;SHLIB&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_DYNSYM:</span><br><span class="line">                sec_header_name = <span class="string">&quot;DYNSYM&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_INIT_ARRAY:</span><br><span class="line">                sec_header_name = <span class="string">&quot;INIT_ARRAY&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_FINI_ARRAY:</span><br><span class="line">                sec_header_name = <span class="string">&quot;FINI_ARRAY&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_PREINIT_ARRAY:</span><br><span class="line">                sec_header_name = <span class="string">&quot;PREINIT_ARRAY&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_GROUP:</span><br><span class="line">                sec_header_name = <span class="string">&quot;GROUP&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_SYMTAB_SHNDX:</span><br><span class="line">                sec_header_name = <span class="string">&quot;SYMTAB_SHNDX&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_NUM:</span><br><span class="line">                sec_header_name = <span class="string">&quot;NUM&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_GNU_HASH:</span><br><span class="line">                sec_header_name = <span class="string">&quot;GNU_HASH&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_GNU_versym:</span><br><span class="line">                sec_header_name = <span class="string">&quot;VERSYM&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHT_GNU_verneed:</span><br><span class="line">                sec_header_name = <span class="string">&quot;VERNEED&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                sec_header_name = <span class="string">&quot;UnknownType&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取section段的标志flag,输入类型对应的数值，返回字符串型的flag</span></span><br><span class="line">    <span class="comment">//因为可能同时满足多个flag，所以根据对应位是否为1来判断是否满足对应的flag满足就将flag字符串拼凑</span></span><br><span class="line">    <span class="keyword">auto</span> get_sh_flags = [](<span class="type">unsigned</span> <span class="type">int</span> sh_flags, string&amp; sec_header_name) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_WRITE) &gt;&gt; <span class="number">0</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;W&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_ALLOC) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_EXECINSTR) &gt;&gt; <span class="number">2</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_MERGE) &gt;&gt; <span class="number">4</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;M&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_STRINGS) &gt;&gt; <span class="number">5</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;S&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_INFO_LINK) &gt;&gt; <span class="number">6</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;I&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_LINK_ORDER) &gt;&gt; <span class="number">7</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;L&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_OS_NONCONFORMING) &gt;&gt; <span class="number">8</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;O&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_GROUP) &gt;&gt; <span class="number">9</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;G&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_TLS) &gt;&gt; <span class="number">10</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;T&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sh_flags &amp; SHF_COMPRESSED) &gt;&gt; <span class="number">11</span>)</span><br><span class="line">            sec_header_name += <span class="string">&quot;C&quot;</span>;</span><br><span class="line">        <span class="comment">//特殊flag因为对应的位和上面的flag对应的位不重叠，所以可以单独处理</span></span><br><span class="line">        <span class="keyword">switch</span> (sh_flags) &#123;</span><br><span class="line">            <span class="keyword">case</span> SHF_MASKOS:</span><br><span class="line">                sec_header_name = <span class="string">&quot;o&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHF_MASKPROC:</span><br><span class="line">                sec_header_name = <span class="string">&quot;p&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHF_EXCLUDE:</span><br><span class="line">                sec_header_name = <span class="string">&quot;E&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  [Nr]\tName\t\t\tType\t\tAddr\t\tOffset\t\tSize\t\t&quot;</span></span><br><span class="line">           <span class="string">&quot;EntSize\t\tFlags\tLink\tInfo\tAlign\n&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历section_headers段表里的每个section,输出相应的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_header.e_shnum; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  [%2d]\t&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-24s&quot;</span>, &amp;string_table[sec_headers[i].sh_name]);</span><br><span class="line">        string sh_type;</span><br><span class="line">        <span class="built_in">get_sh_type</span>(sec_headers[i].sh_type, sh_type);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-16s&quot;</span>, sh_type.<span class="built_in">data</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%08lx\t&quot;</span>, sec_headers[i].sh_addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%08lx\t&quot;</span>, sec_headers[i].sh_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%08lx\t&quot;</span>, sec_headers[i].sh_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%08lx\t&quot;</span>, sec_headers[i].sh_entsize);</span><br><span class="line">        string sh_flags;</span><br><span class="line">        <span class="built_in">get_sh_flags</span>(sec_headers[i].sh_flags, sh_flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8s&quot;</span>, sh_flags.<span class="built_in">data</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8d&quot;</span>, sec_headers[i].sh_link);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8d&quot;</span>, sec_headers[i].sh_info);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8ld&quot;</span>, sec_headers[i].sh_addralign);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Key to Flags:\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tW (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tL (link order), O (extra OS processing required), G (group), T (TLS),\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tC (compressed), x (unknown), o (OS specific), E (exclude),\n&quot;</span></span><br><span class="line">           <span class="string">&quot;\tl (large), p (processor specific)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放堆内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] string_table;</span><br><span class="line">    <span class="keyword">delete</span>[] sec_headers;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模仿readelf -s 的实现readelf_symbol.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readelf_s</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    Elf64_Ehdr elf_header;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="built_in">fread</span>(&amp;elf_header, <span class="built_in">sizeof</span>(Elf64_Ehdr), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (elf_header.e_ident[<span class="number">0</span>] != <span class="number">0x7f</span> || elf_header.e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>) &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    Elf64_Shdr* sec_headers = <span class="keyword">new</span> Elf64_Shdr[elf_header.e_shnum];<span class="comment">//存放每个section_header的数组</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp, elf_header.e_shoff, SEEK_SET);<span class="comment">//移动指针到段表对应的偏移地址</span></span><br><span class="line">    <span class="built_in">fread</span>(sec_headers, <span class="built_in">sizeof</span>(Elf64_Shdr), elf_header.e_shnum, fp);<span class="comment">//将段表数据读到开辟的数组sec_headers里</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> str_tab_ind = elf_header.e_shstrndx;<span class="comment">//获取字符串表.shstrtab在段表中的索引</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp, sec_headers[str_tab_ind].sh_offset, SEEK_SET);<span class="comment">//移动指针到字符串表.shstrtab对应的偏移地址</span></span><br><span class="line">    <span class="type">char</span>* string_table = <span class="keyword">new</span> <span class="type">char</span>[sec_headers[str_tab_ind].sh_size];<span class="comment">//开辟堆内存用来存放字符串表.shstrtab</span></span><br><span class="line">    <span class="built_in">fread</span>(string_table, <span class="number">1</span>, sec_headers[str_tab_ind].sh_size, fp);<span class="comment">//将字符串表.shstrtab对应地址处的数据读到字符串数组里</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dynsym_ind = <span class="number">-1</span>;<span class="comment">//默认.dynsym符号表索引为-1</span></span><br><span class="line">    <span class="type">int</span> symtab_ind = <span class="number">-1</span>;<span class="comment">//默认.symtab符号表索引为-1</span></span><br><span class="line">    <span class="type">int</span> dynstr_ind = <span class="number">-1</span>;<span class="comment">//默认.dynstr字符串表索引为-1</span></span><br><span class="line">    <span class="type">int</span> strtab_ind = <span class="number">-1</span>;<span class="comment">//默认.strtab字符串索引为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历段表section_headers获取符号表.dynsym;.symtab;.dynstr;.strtab四张表在段表中的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elf_header.e_shnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sec_headers[i].sh_type == SHT_DYNSYM)<span class="comment">//是.dynsym符号表</span></span><br><span class="line">            dynsym_ind = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sec_headers[i].sh_type == SHT_SYMTAB)<span class="comment">//是.symtab符号表</span></span><br><span class="line">            symtab_ind = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;string_table[sec_headers[i].sh_name], <span class="string">&quot;.strtab&quot;</span>) == <span class="number">0</span>)<span class="comment">//是.strtab字符串表</span></span><br><span class="line">            strtab_ind = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;string_table[sec_headers[i].sh_name], <span class="string">&quot;.dynstr&quot;</span>) == <span class="number">0</span>)<span class="comment">//是.dynstr字符串表</span></span><br><span class="line">            dynstr_ind = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取符号表entry对应的st_info段，用来计算符号类型和绑定信息</span></span><br><span class="line">    <span class="keyword">auto</span> get_st_info = [](<span class="type">unsigned</span> <span class="type">int</span> st_info, string&amp; symbol_type, string&amp; symbol_binding) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> st_type = st_info &amp; <span class="number">0x0000000f</span>;<span class="comment">//低4位表示符号类型</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> st_binding = (st_info &amp; (~<span class="number">0x0000000f</span>)) &gt;&gt; <span class="number">4</span>;<span class="comment">//高28位表示符号绑定信息</span></span><br><span class="line">        <span class="keyword">switch</span> (st_binding) &#123;</span><br><span class="line">            <span class="keyword">case</span> STB_LOCAL:</span><br><span class="line">                symbol_binding = <span class="string">&quot;LOCAL&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STB_GLOBAL:</span><br><span class="line">                symbol_binding = <span class="string">&quot;GLOBAL&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STB_WEAK:</span><br><span class="line">                symbol_binding = <span class="string">&quot;WEAK&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STB_NUM:</span><br><span class="line">                symbol_binding = <span class="string">&quot;NUM&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STB_LOOS:</span><br><span class="line">                symbol_binding = <span class="string">&quot;LOOS&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STB_HIOS:</span><br><span class="line">                symbol_binding = <span class="string">&quot;HIOS&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STB_LOPROC:</span><br><span class="line">                symbol_binding = <span class="string">&quot;LOPROC&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STB_HIPROC:</span><br><span class="line">                symbol_binding = <span class="string">&quot;HIPROC&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                symbol_binding = <span class="string">&quot;UnknownType&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (st_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> STT_NOTYPE:</span><br><span class="line">                symbol_type = <span class="string">&quot;NOTYPE&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_OBJECT:</span><br><span class="line">                symbol_type = <span class="string">&quot;OBJECT&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_FUNC:</span><br><span class="line">                symbol_type = <span class="string">&quot;FUNC&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_SECTION:</span><br><span class="line">                symbol_type = <span class="string">&quot;SECTION&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_FILE:</span><br><span class="line">                symbol_type = <span class="string">&quot;FILE&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_COMMON:</span><br><span class="line">                symbol_type = <span class="string">&quot;COMMON&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_TLS:</span><br><span class="line">                symbol_type = <span class="string">&quot;TLS&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_NUM:</span><br><span class="line">                symbol_type = <span class="string">&quot;NUM&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_LOOS:</span><br><span class="line">                symbol_type = <span class="string">&quot;LOOS&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_HIOS:</span><br><span class="line">                symbol_type = <span class="string">&quot;HIOS&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_LOPROC:</span><br><span class="line">                symbol_type = <span class="string">&quot;LOPROC&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STT_HIPROC:</span><br><span class="line">                symbol_type = <span class="string">&quot;HIPROC&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                symbol_type = <span class="string">&quot;UnknownBinding&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取符号所在的段在段表的索引，并对特殊符号进行特殊处理</span></span><br><span class="line">    <span class="keyword">auto</span> get_st_shndx = [](<span class="type">unsigned</span> <span class="type">int</span> st_shndx, string&amp; Ndx) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (st_shndx) &#123;</span><br><span class="line">            <span class="keyword">case</span> SHN_UNDEF:</span><br><span class="line">                Ndx = <span class="string">&quot;UNDEF&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHN_COMMON:</span><br><span class="line">                Ndx = <span class="string">&quot;COMMON&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHN_ABS:</span><br><span class="line">                Ndx = <span class="string">&quot;ABS&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Ndx = <span class="built_in">to_string</span>(st_shndx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出符号表信息，输入符号表在段表中的索引sym_ind，符号表entry数目entry_num，符号表对应的字符串表string_table</span></span><br><span class="line">    <span class="keyword">auto</span> show_symbol_table = [&amp;](<span class="type">int</span> sym_ind, <span class="type">unsigned</span> <span class="type">long</span> entry_num, <span class="type">char</span>* string_table) &#123;</span><br><span class="line">        <span class="built_in">fseek</span>(fp, sec_headers[sym_ind].sh_offset, SEEK_SET);<span class="comment">//将指针移动到符号表对应的偏移地址</span></span><br><span class="line"></span><br><span class="line">        Elf64_Sym* sym_entries = <span class="keyword">new</span> Elf64_Sym[entry_num];<span class="comment">//开辟堆内存用来存储符号表中所有entry</span></span><br><span class="line">        <span class="built_in">fread</span>(sym_entries, <span class="built_in">sizeof</span>(Elf64_Sym), entry_num, fp);<span class="comment">//读符号表</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Num:\t\tValue\t\tSize\tType\tBind\tVis\t&quot;</span></span><br><span class="line">               <span class="string">&quot;Ndx\t\tName\n&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历符号表里的每个entry，并且输出entry的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entry_num; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  %3d:\t&quot;</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0x%016lx:\t&quot;</span>, sym_entries[i].st_value);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%4ld\t&quot;</span>, sym_entries[i].st_size);</span><br><span class="line">            string symbol_type;</span><br><span class="line">            string symbol_binding;</span><br><span class="line">            <span class="built_in">get_st_info</span>(sym_entries[i].st_info, symbol_type, symbol_binding);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, symbol_type.<span class="built_in">data</span>());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, symbol_binding.<span class="built_in">data</span>());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;DEFAULT\t&quot;</span>);</span><br><span class="line">            string Ndx;</span><br><span class="line">            <span class="built_in">get_st_shndx</span>(sym_entries[i].st_shndx, Ndx);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%4s\t&quot;</span>, Ndx.<span class="built_in">data</span>());</span><br><span class="line">            <span class="comment">//根据entry的st_name属性在符号表对应的字符串表表里找到entry的name</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, &amp;string_table[sym_entries[i].st_name]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放堆内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] sym_entries;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果.dynsym段存在,且.dynstr存在</span></span><br><span class="line">    <span class="keyword">if</span> ((dynsym_ind != <span class="number">-1</span>) &amp;&amp; (dynstr_ind != <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="comment">//符号表大小sec_headers[dynsym_ind].sh_size每个entry大小sec_headers[dynsym_ind].sh_entsize</span></span><br><span class="line">        <span class="comment">// 计算entry数目entry_num</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> entry_num = sec_headers[dynsym_ind].sh_size / sec_headers[dynsym_ind].sh_entsize;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Symbol table &#x27;.dynsym&#x27; contains %ld entries\n&quot;</span>, entry_num);</span><br><span class="line">        <span class="built_in">fseek</span>(fp, sec_headers[dynstr_ind].sh_offset, SEEK_SET);<span class="comment">//将指针移动到.dynstr字符串表对应的偏移地址</span></span><br><span class="line">        <span class="comment">//开辟堆内存用来存储字符串表</span></span><br><span class="line">        <span class="type">char</span>* dynstr_string_table = <span class="keyword">new</span> <span class="type">char</span>[sec_headers[dynstr_ind].sh_size];</span><br><span class="line">        <span class="comment">//将数据读到字符串表里</span></span><br><span class="line">        <span class="built_in">fread</span>(dynstr_string_table, <span class="number">1</span>, sec_headers[dynstr_ind].sh_size, fp);</span><br><span class="line">        <span class="built_in">show_symbol_table</span>(dynsym_ind, entry_num, dynstr_string_table);</span><br><span class="line">        <span class="comment">//释放字符串表</span></span><br><span class="line">        <span class="keyword">delete</span>[] dynstr_string_table;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Dynamic linker symbol table!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//如果.symtab段存在，且.strtab存在</span></span><br><span class="line">    <span class="keyword">if</span> ((symtab_ind != <span class="number">-1</span>) &amp;&amp; (strtab_ind != <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> entry_num = sec_headers[symtab_ind].sh_size / sec_headers[symtab_ind].sh_entsize;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Symbol table &#x27;.symtab&#x27; contains %ld entries\n&quot;</span>, entry_num);</span><br><span class="line">        <span class="built_in">fseek</span>(fp, sec_headers[strtab_ind].sh_offset, SEEK_SET);</span><br><span class="line">        <span class="type">char</span>* strtab_string_table = <span class="keyword">new</span> <span class="type">char</span>[sec_headers[strtab_ind].sh_size];</span><br><span class="line">        <span class="built_in">fread</span>(strtab_string_table, <span class="number">1</span>, sec_headers[strtab_ind].sh_size, fp);</span><br><span class="line">        <span class="built_in">show_symbol_table</span>(symtab_ind, entry_num, strtab_string_table);</span><br><span class="line">        <span class="keyword">delete</span>[] strtab_string_table;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No symbol table!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="keyword">delete</span>[] string_table;</span><br><span class="line">    <span class="keyword">delete</span>[] sec_headers;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-使用CMake-Make编译并执行"><a href="#4-使用CMake-Make编译并执行" class="headerlink" title="4.使用CMake-Make编译并执行"></a>4.使用CMake-Make编译并执行</h2><p>进入ELFReader所在目录执行如下命令即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ELFReader -h filename</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ELFReader -S filename</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ELFReader -s filename</span><br></pre></td></tr></table></figure><p>其中filename是被解析的elf文件所在路径。</p><p>示例：</p><p>在build文件夹下执行cmake .. 再make最后工程目录结构如下，ELFReader是elf文件解析器，libMylib.so共享库和helloworld可执行文件是待解析测试文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── bin</span><br><span class="line">│   │   ├── ELFReader</span><br><span class="line">│   │   ├── helloworld</span><br><span class="line">│   │   └── libMylib.so</span><br><span class="line">......</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── readme.md</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── header.h</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── readefl_h.cpp</span><br><span class="line">    ├── readelf_s.cpp</span><br><span class="line">    └── readelf_S.cpp</span><br></pre></td></tr></table></figure><p>根目录CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(ELFReader)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(./src)</span><br></pre></td></tr></table></figure><p>src目录下CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(./ DIR_SRCS)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(ELFReader <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入bin目录并执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd build/bin/</span><br><span class="line">./ELFReader -h helloworld</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:ELF64</span><br><span class="line">  Data:2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:UNIX System V ABI</span></span><br><span class="line"><span class="string">  ABI Version:0</span></span><br><span class="line"><span class="string">  Type:DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:AMD x86-64 architecture</span></span><br><span class="line"><span class="string">  Version:1</span></span><br><span class="line"><span class="string">  Entry point address:0x00000000000010c0</span></span><br><span class="line"><span class="string">  Start of program headers:64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:36440 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:0x0</span></span><br><span class="line"><span class="string">  Size of this header:64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:13</span></span><br><span class="line"><span class="string">  Size of section headers:64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:36</span></span><br><span class="line"><span class="string">  Section header string table index:35</span></span><br></pre></td></tr></table></figure><p>执行-S命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ELFReader -S helloworld</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">There are 36 section headers, starting at offset 0x8e58</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr]NameTypeAddrOffsetSizeEntSizeFlagsLinkInfoAlign</span><br><span class="line">  [ 0]                        NULL            0x000000000x000000000x000000000x00000000        0       0       0       </span><br><span class="line">  [ 1].interp                 PROGBITS        0x000003180x000003180x0000001c0x00000000A       0       0       1       </span><br><span class="line">  [ 2].note.gnu.property      NOTE            0x000003380x000003380x000000200x00000000A       0       0       8       </span><br><span class="line">  [ 3].note.gnu.build-id      NOTE            0x000003580x000003580x000000240x00000000A       0       0       4       </span><br><span class="line">  [ 4].note.ABI-tag           NOTE            0x0000037c0x0000037c0x000000200x00000000A       0       0       4       </span><br><span class="line">  [ 5].gnu.hash               GNU_HASH        0x000003a00x000003a00x000000280x00000000A       6       0       8       </span><br><span class="line">  [ 6].dynsym                 DYNSYM          0x000003c80x000003c80x000001380x00000018A       7       1       8       </span><br><span class="line">  [ 7].dynstr                 STRTAB          0x000005000x000005000x000001630x00000000A       0       0       1       </span><br><span class="line">  [ 8].gnu.version            VERSYM          0x000006640x000006640x0000001a0x00000002A       6       0       2       </span><br><span class="line">  [ 9].gnu.version_r          VERNEED         0x000006800x000006800x000000400x00000000A       7       2       8       </span><br><span class="line">  [10].rela.dyn               RELA            0x000006c00x000006c00x000001200x00000018A       6       0       8       </span><br><span class="line">  [11].rela.plt               RELA            0x000007e00x000007e00x000000600x00000018AI      6       24      8       </span><br><span class="line">  [12].init                   PROGBITS        0x000010000x000010000x0000001b0x00000000AX      0       0       4       </span><br><span class="line">  [13].plt                    PROGBITS        0x000010200x000010200x000000500x00000010AX      0       0       16      </span><br><span class="line">  [14].plt.got                PROGBITS        0x000010700x000010700x000000100x00000010AX      0       0       16      </span><br><span class="line">  [15].plt.sec                PROGBITS        0x000010800x000010800x000000400x00000010AX      0       0       16      </span><br><span class="line">  [16].text                   PROGBITS        0x000010c00x000010c00x000002050x00000000AX      0       0       16      </span><br><span class="line">  [17].fini                   PROGBITS        0x000012c80x000012c80x0000000d0x00000000AX      0       0       4       </span><br><span class="line">  [18].rodata                 PROGBITS        0x000020000x000020000x000000130x00000000A       0       0       4       </span><br><span class="line">  [19].eh_frame_hdr           PROGBITS        0x000020140x000020140x000000540x00000000A       0       0       4       </span><br><span class="line">  [20].eh_frame               PROGBITS        0x000020680x000020680x000001480x00000000A       0       0       8       </span><br><span class="line">  [21].init_array             INIT_ARRAY      0x00003d780x00002d780x000000100x00000008WA      0       0       8       </span><br><span class="line">  [22].fini_array             FINI_ARRAY      0x00003d880x00002d880x000000080x00000008WA      0       0       8       </span><br><span class="line">  [23].dynamic                DYNAMIC         0x00003d900x00002d900x000002000x00000010WA      7       0       8       </span><br><span class="line">  [24].got                    PROGBITS        0x00003f900x00002f900x000000700x00000008WA      0       0       8       </span><br><span class="line">  [25].data                   PROGBITS        0x000040000x000030000x000000100x00000000WA      0       0       8       </span><br><span class="line">  [26].bss                    NOBITS          0x000040400x000030100x000001180x00000000WA      0       0       64      </span><br><span class="line">  [27].comment                PROGBITS        0x000000000x000030100x0000002a0x00000001MS      0       0       1       </span><br><span class="line">  [28].debug_aranges          PROGBITS        0x000000000x0000303a0x000000300x00000000        0       0       1       </span><br><span class="line">  [29].debug_info             PROGBITS        0x000000000x0000306a0x00002c340x00000000        0       0       1       </span><br><span class="line">  [30].debug_abbrev           PROGBITS        0x000000000x00005c9e0x000006490x00000000        0       0       1       </span><br><span class="line">  [31].debug_line             PROGBITS        0x000000000x000062e70x000004060x00000000        0       0       1       </span><br><span class="line">  [32].debug_str              PROGBITS        0x000000000x000066ed0x00001b080x00000001MS      0       0       1       </span><br><span class="line">  [33].symtab                 SYMTAB          0x000000000x000081f80x000007800x00000018        34      55      8       </span><br><span class="line">  [34].strtab                 STRTAB          0x000000000x000089780x000003810x00000000        0       0       1       </span><br><span class="line">  [35].shstrtab               STRTAB          0x000000000x00008cf90x0000015a0x00000000        0       0       1       </span><br><span class="line">Key to Flags:</span><br><span class="line">W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">l (large), p (processor specific)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行-s命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ELFReader -s helloworld</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains 13 entries</span><br><span class="line">  Num:ValueSizeTypeBindVisNdxName</span><br><span class="line">    0:0x0000000000000000:   0NOTYPELOCALDEFAULTUNDEF</span><br><span class="line">    1:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_</span><br><span class="line">    2:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF__cxa_atexit</span><br><span class="line">    3:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc</span><br><span class="line">    4:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZNSolsEPFRSoS_E</span><br><span class="line">    5:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZNSt8ios_base4InitC1Ev</span><br><span class="line">    6:0x0000000000000000:   0NOTYPEWEAKDEFAULTUNDEF_ITM_deregisterTMCloneTable</span><br><span class="line">    7:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF__libc_start_main</span><br><span class="line">    8:0x0000000000000000:   0NOTYPEWEAKDEFAULTUNDEF__gmon_start__</span><br><span class="line">    9:0x0000000000000000:   0NOTYPEWEAKDEFAULTUNDEF_ITM_registerTMCloneTable</span><br><span class="line">   10:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZNSt8ios_base4InitD1Ev</span><br><span class="line">   11:0x0000000000000000:   0FUNCWEAKDEFAULTUNDEF__cxa_finalize</span><br><span class="line">   12:0x0000000000004040: 272OBJECTGLOBALDEFAULT  26_ZSt4cout</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains 80 entries</span><br><span class="line">  Num:ValueSizeTypeBindVisNdxName</span><br><span class="line">    0:0x0000000000000000:   0NOTYPELOCALDEFAULTUNDEF</span><br><span class="line">    1:0x0000000000000318:   0SECTIONLOCALDEFAULT   1</span><br><span class="line">    2:0x0000000000000338:   0SECTIONLOCALDEFAULT   2</span><br><span class="line">    3:0x0000000000000358:   0SECTIONLOCALDEFAULT   3</span><br><span class="line">    4:0x000000000000037c:   0SECTIONLOCALDEFAULT   4</span><br><span class="line">    5:0x00000000000003a0:   0SECTIONLOCALDEFAULT   5</span><br><span class="line">    6:0x00000000000003c8:   0SECTIONLOCALDEFAULT   6</span><br><span class="line">    7:0x0000000000000500:   0SECTIONLOCALDEFAULT   7</span><br><span class="line">    8:0x0000000000000664:   0SECTIONLOCALDEFAULT   8</span><br><span class="line">    9:0x0000000000000680:   0SECTIONLOCALDEFAULT   9</span><br><span class="line">   10:0x00000000000006c0:   0SECTIONLOCALDEFAULT  10</span><br><span class="line">   11:0x00000000000007e0:   0SECTIONLOCALDEFAULT  11</span><br><span class="line">   12:0x0000000000001000:   0SECTIONLOCALDEFAULT  12</span><br><span class="line">   13:0x0000000000001020:   0SECTIONLOCALDEFAULT  13</span><br><span class="line">   14:0x0000000000001070:   0SECTIONLOCALDEFAULT  14</span><br><span class="line">   15:0x0000000000001080:   0SECTIONLOCALDEFAULT  15</span><br><span class="line">   16:0x00000000000010c0:   0SECTIONLOCALDEFAULT  16</span><br><span class="line">   17:0x00000000000012c8:   0SECTIONLOCALDEFAULT  17</span><br><span class="line">   18:0x0000000000002000:   0SECTIONLOCALDEFAULT  18</span><br><span class="line">   19:0x0000000000002014:   0SECTIONLOCALDEFAULT  19</span><br><span class="line">   20:0x0000000000002068:   0SECTIONLOCALDEFAULT  20</span><br><span class="line">   21:0x0000000000003d78:   0SECTIONLOCALDEFAULT  21</span><br><span class="line">   22:0x0000000000003d88:   0SECTIONLOCALDEFAULT  22</span><br><span class="line">   23:0x0000000000003d90:   0SECTIONLOCALDEFAULT  23</span><br><span class="line">   24:0x0000000000003f90:   0SECTIONLOCALDEFAULT  24</span><br><span class="line">   25:0x0000000000004000:   0SECTIONLOCALDEFAULT  25</span><br><span class="line">   26:0x0000000000004040:   0SECTIONLOCALDEFAULT  26</span><br><span class="line">   27:0x0000000000000000:   0SECTIONLOCALDEFAULT  27</span><br><span class="line">   28:0x0000000000000000:   0SECTIONLOCALDEFAULT  28</span><br><span class="line">   29:0x0000000000000000:   0SECTIONLOCALDEFAULT  29</span><br><span class="line">   30:0x0000000000000000:   0SECTIONLOCALDEFAULT  30</span><br><span class="line">   31:0x0000000000000000:   0SECTIONLOCALDEFAULT  31</span><br><span class="line">   32:0x0000000000000000:   0SECTIONLOCALDEFAULT  32</span><br><span class="line">   33:0x0000000000000000:   0FILELOCALDEFAULT ABScrtstuff.c</span><br><span class="line">   34:0x00000000000010f0:   0FUNCLOCALDEFAULT  16deregister_tm_clones</span><br><span class="line">   35:0x0000000000001120:   0FUNCLOCALDEFAULT  16register_tm_clones</span><br><span class="line">   36:0x0000000000001160:   0FUNCLOCALDEFAULT  16__do_global_dtors_aux</span><br><span class="line">   37:0x0000000000004150:   1OBJECTLOCALDEFAULT  26completed.8060</span><br><span class="line">   38:0x0000000000003d88:   0OBJECTLOCALDEFAULT  22__do_global_dtors_aux_fini_array_entry</span><br><span class="line">   39:0x00000000000011a0:   0FUNCLOCALDEFAULT  16frame_dummy</span><br><span class="line">   40:0x0000000000003d78:   0OBJECTLOCALDEFAULT  21__frame_dummy_init_array_entry</span><br><span class="line">   41:0x0000000000000000:   0FILELOCALDEFAULT ABSmain.cpp</span><br><span class="line">   42:0x0000000000002004:   1OBJECTLOCALDEFAULT  18_ZStL19piecewise_construct</span><br><span class="line">   43:0x0000000000004151:   1OBJECTLOCALDEFAULT  26_ZStL8__ioinit</span><br><span class="line">   44:0x00000000000011e0:  77FUNCLOCALDEFAULT  16_Z41__static_initialization_and_destruction_0ii</span><br><span class="line">   45:0x000000000000122d:  25FUNCLOCALDEFAULT  16_GLOBAL__sub_I_main</span><br><span class="line">   46:0x0000000000000000:   0FILELOCALDEFAULT ABScrtstuff.c</span><br><span class="line">   47:0x00000000000021ac:   0OBJECTLOCALDEFAULT  20__FRAME_END__</span><br><span class="line">   48:0x0000000000000000:   0FILELOCALDEFAULT ABS</span><br><span class="line">   49:0x0000000000002014:   0NOTYPELOCALDEFAULT  19__GNU_EH_FRAME_HDR</span><br><span class="line">   50:0x0000000000001000:   0FUNCLOCALDEFAULT  12_init</span><br><span class="line">   51:0x0000000000003d90:   0OBJECTLOCALDEFAULT  23_DYNAMIC</span><br><span class="line">   52:0x0000000000003d88:   0NOTYPELOCALDEFAULT  21__init_array_end</span><br><span class="line">   53:0x0000000000003d78:   0NOTYPELOCALDEFAULT  21__init_array_start</span><br><span class="line">   54:0x0000000000003f90:   0OBJECTLOCALDEFAULT  24_GLOBAL_OFFSET_TABLE_</span><br><span class="line">   55:0x0000000000004010:   0NOTYPEGLOBALDEFAULT  25_edata</span><br><span class="line">   56:0x0000000000004000:   0NOTYPEWEAKDEFAULT  25data_start</span><br><span class="line">   57:0x0000000000002000:   4OBJECTGLOBALDEFAULT  18_IO_stdin_used</span><br><span class="line">   58:0x0000000000000000:   0FUNCWEAKDEFAULTUNDEF__cxa_finalize@@GLIBC_2.2.5</span><br><span class="line">   59:0x00000000000011a9:  55FUNCGLOBALDEFAULT  16main</span><br><span class="line">   60:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@@GLIBCXX_3.4</span><br><span class="line">   61:0x0000000000004008:   0OBJECTGLOBALDEFAULT  25__dso_handle</span><br><span class="line">   62:0x00000000000012c8:   0FUNCGLOBALDEFAULT  17_fini</span><br><span class="line">   63:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF__cxa_atexit@@GLIBC_2.2.5</span><br><span class="line">   64:0x00000000000010c0:  47FUNCGLOBALDEFAULT  16_start</span><br><span class="line">   65:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@@GLIBCXX_3.4</span><br><span class="line">   66:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZNSolsEPFRSoS_E@@GLIBCXX_3.4</span><br><span class="line">   67:0x0000000000004010:   0OBJECTGLOBALDEFAULT  25__TMC_END__</span><br><span class="line">   68:0x0000000000004040: 272OBJECTGLOBALDEFAULT  26_ZSt4cout@@GLIBCXX_3.4</span><br><span class="line">   69:0x0000000000004000:   0NOTYPEGLOBALDEFAULT  25__data_start</span><br><span class="line">   70:0x0000000000004158:   0NOTYPEGLOBALDEFAULT  26_end</span><br><span class="line">   71:0x0000000000004010:   0NOTYPEGLOBALDEFAULT  26__bss_start</span><br><span class="line">   72:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4</span><br><span class="line">   73:0x0000000000001250: 101FUNCGLOBALDEFAULT  16__libc_csu_init</span><br><span class="line">   74:0x0000000000000000:   0NOTYPEWEAKDEFAULTUNDEF_ITM_deregisterTMCloneTable</span><br><span class="line">   75:0x00000000000012c0:   5FUNCGLOBALDEFAULT  16__libc_csu_fini</span><br><span class="line">   76:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF__libc_start_main@@GLIBC_2.2.5</span><br><span class="line">   77:0x0000000000000000:   0NOTYPEWEAKDEFAULTUNDEF__gmon_start__</span><br><span class="line">   78:0x0000000000000000:   0NOTYPEWEAKDEFAULTUNDEF_ITM_registerTMCloneTable</span><br><span class="line">   79:0x0000000000000000:   0FUNCGLOBALDEFAULTUNDEF_ZNSt8ios_base4InitD1Ev@@GLIBCXX_3.4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/linhaostudy/p/8855238.html">ELF文件结构描述 - yooooooo - 博客园 (cnblogs.com)</a></p><p><a href="https://mp.weixin.qq.com/s/ZOvHG_ofiU6iWtoSR9bFow">Linux系统中编译、链接的基石-ELF文件：扒开它的层层外衣，从字节码的粒度来探索 (qq.com)</a></p><p><a href="https://www.cnblogs.com/LyShark/p/12936375.html">C/C++ 实现ELF结构解析工具 - lyshark - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq_45228537/article/details/107020572">C语言实现ELF文件解析_Yuhan的博客-CSDN博客_elf文件读取</a></p><p>《程序员的自我修养——链接、装载与库》俞甲子，石凡，潘爱民</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】推荐系统 Factorization Machines 因子分解机</title>
      <link href="/2021/11/30/Factorization%20Machines/"/>
      <url>/2021/11/30/Factorization%20Machines/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>因子分解机 (Factorization Machines) 是CTR预估的重要模型之一。要讲述因子分解机FM，就避不开<strong>逻辑回归LR</strong>（logistic Rgeression）和<strong>矩阵分解MF</strong>（Matrix Factorization）。</p><p>转自<a href="https://zhuanlan.zhihu.com/p/153500425">推荐系统玩家 之 因子分解机FM（Factorization Machines） - 知乎 (zhihu.com)</a></p><h2 id="1-因子分解机的演变"><a href="#1-因子分解机的演变" class="headerlink" title="1.因子分解机的演变"></a>1.因子分解机的演变</h2><p>传统的推荐模型<br><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171702148.jpeg" alt="img"></p><p>上图是传统的推荐系统模型的分类，逻辑回归LR模型在传统的推荐模型中占据着非常重要的位置。而因子分解机的出现，也来源于<strong>逻辑回归和矩阵分解</strong>的演化。</p><p>首先我们知道，<strong>逻辑回归</strong>的是对所有特征的一个线性加权组合, 然后再加入Sigmoid逻辑函数：</p><script type="math/tex; mode=display">\large \hat{y}(x)=w_{0}+w_{1} x_{1}+\ldots+w_{n} x_{n}=w_{0}+\sum_{i=1}^{n} w_{i} x_{i} \tag{1}</script><p>对比与矩阵分解，虽然逻辑回归模型已经<strong>不单单</strong>考虑了用户的行为特征，也可以加入年龄，性别，物品的属性，时间，地点等等特征。但是逻辑回归表达能力仍然差的原因是仅仅用了每个单一的特征，而没有考虑到<strong>特征之间的关系</strong>。</p><p>那有没有模型可以加入特征之间的联系呢？</p><p><strong>POLY2模型（Degree-2 Polynomial Margin）</strong>则在LR的基础上采用了一种<strong>暴力的特征组合模式</strong>，即将所有特征两两相交，因此原来的LR模型就变成了：</p><script type="math/tex; mode=display">\large \hat{y}(x)=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n-1} \sum_{j=i\llcorner 1}^{n} w_{i j} x_{i} x_{j} \tag{2}</script><p>其中$\Large w_{i j}$​​是特征组合的$ (i, j)$​​权重。</p><p>也就是说，<strong>POLY2模型</strong>将所有的特征两两相交，暴力的组合了特征。这样以来，就增加了特征的维度，考虑到了特征之间的关系。但是同时，暴力的组合带来的是维度的增加。在机器学习中，我们普遍使用<strong>One-hot</strong>编码，这样的暴力组合，就使得复杂度从$\large n$​​​​上升到了 ,$\large n^2$​​​​ 特征维度也上升，同时数据极度稀疏，在训练过程中很难收敛。</p><p>那么有没有方法可以处理稀疏数据，同时保持特征之间的联系呢？</p><h2 id="2-因子分解机"><a href="#2-因子分解机" class="headerlink" title="2.因子分解机"></a>2.因子分解机</h2><p>用户对电影打分的onehot编码</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171702828.jpeg" alt="img"></p><p>上图是电影背景下，用户对电影打分的onehot编码形式。每行代表一个样本，每列都代表一个特征。同时特征可以分为五个部分：用户ID，电影ID，用户对其他电影的打分（归一化），时间信息，以及对上一次电影的打分。</p><p>首先我们直观的看下，为什么<strong>POLY2模型</strong>在很多情况下是不适用的。</p><script type="math/tex; mode=display">\large \hat{y}(x)=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n-1} \sum_{j=i+1}^{n} w_{i j} x_{i} x_{j} \tag{3}</script><p><strong>POLY2模型</strong>的表达式如上， $\Large w<em>{0}$是常数项， $\Large w</em>{i}$是一阶特征的系数， $\Large w<em>{i}w</em>{j}$是二阶特征的系数，也就是交叉特征的系数。而由于在数据中，不是每个特征组合都有相互作用，因此， $\Large x<em>{i}\cdot x</em>{j}$为0。</p><p>举个例子来说，如上图中，我们要估计用户A对电影ST星际迷航（Star Trek）的相互作用，来预测A都ST的打分。显然，上图中A列乘以ST列是等于0的。也就是说，交叉项  $\Large x<em>{i}\cdot x</em>{j}$ 为0了，那么对应的  $\Large w<em>{i}w</em>{j}$ 在梯度更新时，$\Large\frac{\partial \hat{y}(x)}{\partial w<em>{i, j}}=x</em>{i} x<em>{j}=0$，因此也就会导致  $\Large w</em>{i}w_{j}$ 的训练不充分且不准确，进而影响模型的效果。</p><p>因此，<strong>因子分解机</strong>的应运而生。</p><p>因子分解机的<strong>优势</strong>是为每个特征学习了一个<strong>隐权重向量（latent vector），</strong>在特征交叉的时候，用这两个特征隐向量内积作为交叉特征的权重。如何理解这个含义呢？</p><p>在这里我们就要提一嘴矩阵分解。矩阵分解其实是将一个稀疏矩阵R分解为两个矩阵内积的形式，通过内积回乘，就能够得到一个满秩的矩阵。如果是电影的评分矩阵，也就是可以对未知的电影评分进行预测。具体可以看这篇文章：</p><p>而因子分解机FM就是在POLY2模型的基础上，融合了矩阵分解的思想。即，对二阶交叉特征的系数以矩阵分解的方式调整，让系数不再是独立无关的，同时解决数据稀疏导致的无法训练参数的问题：</p><script type="math/tex; mode=display">\large\hat{y}(\mathbf{x}):=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j} \tag{4}</script><p>其中，$\large w_{0} \in \mathbb{R}, \quad \mathbf{w} \in \mathbb{R}^{n}, \quad \mathbf{V} \in \mathbb{R}^{n \times k}, V$是一个$\large n * k$的向量矩阵，$\large n$是特征$\large x$的个数，$\large k$是个待确定的参数。</p><p>$\large \left\langle\mathbf{v}<em>{i}, \mathbf{v}</em>{j}\right\rangle$ 表示点乘,即向量对应位置乘积的和</p><script type="math/tex; mode=display">\large \left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle:=\sum_{f=1}^{k} v_{i, f} \cdot v_{j, f} \tag{5}</script><p>由矩阵分解可知，对任意一个正定矩阵$\large \mathbf{W}$，都可以找到一个矩阵$\large \mathbf{V}$，$\large \mathbf{}$且在矩阵$\large \mathbf{V}$维度$\large k$足够大的情况下使得$\large \mathbf{W}=\mathbf{V} \cdot \mathbf{V}^{t}$成立。因此，通过矩阵分解用两个向量 $\Large v<em>{i}$ 和 $\Large v</em>{j}$ 的内积近似原先矩阵$\large \mathbf{W}$。</p><p>其次，在拆解为 $\large\mathbf{v}<em>{i}$ 和之 $\large\mathbf{v}</em>{j}$ 后，参数更新时是对这两个向量分别更新的，那么在更新时，对于向量，我$\large\mathbf{v}<em>{i}$们不需要寻找到一组 $\Large x</em>{i}$和 $\Large x<em>{j}$同时不为0，我们只需要在$\large x</em>{i} \neq 0$的情况下，找到任意一个样本$\large x<em>{k} \neq 0$即可通过 $\Large x</em>{i}x<em>{k}$ 来更新 $\Large v</em>{i}$ 。</p><p>我们举个例子来理解下上面的定义：</p><p>在商品推荐的场景下，样本有两个特征，分别是类品和品牌。某个训练样本的特征组合是（足球，阿迪达斯）。在POLY2模型中，只有当“足球”和“阿迪达斯”同时出现在一个训练样本中时，模型才能够学到这个组合特征对应的权重。而在因子分解机FM中，“足球”的的隐向量也可以根据（足球，耐克）进行更新。“阿迪达斯”的隐向量也可以根据（篮球，阿迪达斯）更新，由此一来，就大幅度的降低了模型对稀疏性的要求。</p><p>更极端的情况，对于一个从未出现的组合（篮球，耐克），因为模型已经学习了“篮球”和“耐克”的隐向量，因此就具备了更新权重  $\Large w$​ 的能力，使其泛化能力大大提高。</p><h2 id="3-降低时间复杂度"><a href="#3-降低时间复杂度" class="headerlink" title="3.降低时间复杂度"></a>3.降低时间复杂度</h2><p>公式（3）的时间复杂度为 $O\left(k n^{2}\right)$ , 我们可以对二阶交叉特征进行化简，使时间复杂度降低到 $O\left(k n\right)$ 。</p><script type="math/tex; mode=display">\large \sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j} \tag{6}</script><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171702081.jpeg" alt="img"></p><p>首先矩阵A中的上三角，红色方框部分代表公式（6），也就是因子分解机中二阶交叉项部分。由图可以看出，他是矩阵的全部元素减去对角线元素之和得到的, 即：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171702370.png" alt="img"></p><script type="math/tex; mode=display">\large \sum_{i=1}^{n} \sum_{j=i+1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j}=\frac{1}{2}\left(\sum_{i=1}^{n} \sum_{j=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j}-\sum_{i=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{i}\right\rangle x_{i} x_{i}\right)</script><p>其中， $\large \sum<em>{i=1}^{n} \sum</em>{j=1}^{n}\left\langle\mathbf{v}<em>{i}, \mathbf{v}</em>{j}\right\rangle x<em>{i} x</em>{j}$​ 是矩阵全部元素之和。  $\large \sum<em>{i=1}^{n}\left\langle\mathbf{v}</em>{i}, \mathbf{v}<em>{i}\right\rangle x</em>{i} x_{i}$​代表对角线元素之和。</p><p>因为 ：</p><script type="math/tex; mode=display">\large \left\langle\mathbf{v}_{i}, \mathbf{v}_{i}\right\rangle=\sum_{f=1}^{k} v_{i, f}, v_{j, f}</script><p>因此继续化简：</p><script type="math/tex; mode=display">\large =\frac{1}{2}\left(\sum_{i=1}^{n} \sum_{j=1}^{n} \sum_{f=1}^{k} v_{i, f} v_{j, f} x_{i} x_{j}-\sum_{i=1}^{n} \sum_{f=1}^{k} v_{i, f} v_{i, f} x_{i} x_{i}\right)</script><script type="math/tex; mode=display">\large =\frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)\left(\sum_{j=1}^{n} v_{j, f} x_{j}\right)-\sum_{i=1}^{n} v_{i, f}^{2} x_{i}^{2}\right)</script><script type="math/tex; mode=display">\large =\frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)^{2}-\sum_{i=1}^{n} v_{i, f}^{2} x_{i}^{2}\right) \tag{7}</script><p>那么，<strong>因子分解机的二阶表达式</strong>就为：</p><script type="math/tex; mode=display">\large \hat{y}(x):=w_{0}+\sum_{i=1}^{n} w_{i} x_{i}+\frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)^{2}-\sum_{i=1}^{n} v_{i, f}^{2} x_{i}^{2}\right) \tag{8}</script><p>其复杂度为  $O\left(k n\right)$​​  。考虑到特征的稀疏性，尽管  $\large n$​​可能很大，但很多  $\Large x_{i}$​​ 都是零。因此其实际复杂度应该是 $O(k \bar{n})$​​ ,其中  $\large \bar{n}$​​表示样本不为零的特征维度数量的平均值。</p><h2 id="4-因子分解机FM求解"><a href="#4-因子分解机FM求解" class="headerlink" title="4.因子分解机FM求解"></a>4.因子分解机FM求解</h2><p>我们对公式（8）求偏导，可以计算因子分解模型对参数的梯度：</p><ul><li>当参数为  $\large w_{i}$​​ 时：</li></ul><script type="math/tex; mode=display">\large \frac{\partial \hat{y}(x)}{\partial w_{0}}=1 \tag{9}</script><ul><li>当参数为  $\large w<em>{i}$ 时，只跟它相关的  $\large x</em>{i}$ 有关:</li></ul><script type="math/tex; mode=display">\large \frac{\partial \hat{y}(x)}{\partial w_{i}}=x_i \tag{10}</script><p>当参数为   $\large v_{i,f}$​ 时:</p><script type="math/tex; mode=display">\large \begin{aligned} \frac{\partial \hat{y}(x)}{\partial v_{i, f}} &=\frac{\partial \frac{1}{2}\left(\left(\sum_{i=1}^{n} v_{i, f} x_{i}\right)^{2}-v_{i, f}^{2} x_{i}^{2}\right)}{\partial v_{i, f}} \\ &=\frac{1}{2}\left(2 x_{i} \sum_{i=1}^{n} v_{i, f} x_{i}-2 v_{i, f} x_{i}^{2}\right) \\ &=x_{i} \sum_{j=1}^{n} v_{j, f} x_{j}-v_{i, f} x_{i}^{2} \end{aligned} \tag{11}</script><p>因此，<strong>因子分解机FM模型对参数的梯度为</strong>：</p><script type="math/tex; mode=display">\large \frac{\partial \hat{y}(x)}{\partial \theta}= \begin{cases}1, & \text { if } \theta \text { is } w_{0} \\ x_{i}, & \text { if } \theta \text { is } w_{i} \\ x_{i} \sum_{j=1}^{n} v_{j, f} x_{j}-v_{i, f} x_{i}^{2} & \text { if } \theta \text { is } v_{i, f}\end{cases} \tag{12}</script><h2 id="5-损失函数选取及算法流程"><a href="#5-损失函数选取及算法流程" class="headerlink" title="5.损失函数选取及算法流程"></a>5.损失函数选取及算法流程</h2><p>至此，我们就推导出了因子分解机的表达式以及参数的梯度。那么，损失函数在这里我们以以下两个为例, 并用梯度下降法求解：</p><h3 id="回归问题：平方差损失函数"><a href="#回归问题：平方差损失函数" class="headerlink" title="回归问题：平方差损失函数"></a>回归问题：平方差损失函数</h3><script type="math/tex; mode=display">\large Loss =\frac{1}{2} \sum_{i=1}^{n}\left(\hat{y}_{i}-y_{i}\right)^{2}</script><p>求偏导得：</p><script type="math/tex; mode=display">\large \frac{\partial L}{\partial \hat{y}(x)}=(\hat{y}(x)-y)</script><p>平方损失函数的梯度为：</p><script type="math/tex; mode=display">\large \frac{\partial L}{\partial \theta}=(\hat{y}(x)-y) * \frac{\partial \hat{y}(x)}{\partial \theta}</script><h3 id="分类问题：对数损失函数"><a href="#分类问题：对数损失函数" class="headerlink" title="分类问题：对数损失函数"></a>分类问题：对数损失函数</h3><script type="math/tex; mode=display">\large L o s s=\frac{1}{2} \sum_{i=1}^{n}-\ln \left(\sigma\left(\hat{y}_{i} y_{i}\right)\right)^{2}</script><p>其中：</p><script type="math/tex; mode=display">\large \sigma(\hat{y} y)=\frac{1}{1+e^{-\hat{y} y}}</script><script type="math/tex; mode=display">\large \frac{\partial(\sigma(\hat{y} y))}{\partial \hat{y}}=\sigma(\hat{y} y) *[1-\sigma(\hat{y} y)] * y</script><p>对数函数下的梯度为：</p><script type="math/tex; mode=display">\large \frac{\partial L}{\partial \theta}=\frac{1}{\sigma(\hat{y} y)} * \sigma(\hat{y} y) *\left[1-\sigma(\hat{y} y] * y * \frac{\partial \hat{y}(x)}{\partial \theta}\right.</script><script type="math/tex; mode=display">\large =[1-\sigma(\hat{y} y)] * y * \frac{\partial \hat{y}(x)}{\partial \theta}</script><h3 id="算法流程-以对数损失函数为例）"><a href="#算法流程-以对数损失函数为例）" class="headerlink" title="算法流程(以对数损失函数为例）"></a>算法流程(以对数损失函数为例）</h3><ol><li>初始化权重 $\large w<em>{0}, w</em>{1}, \ldots, w_{n}$​​ 和矩阵  $\mathbf{V}$​​</li><li>对每一个样本：</li></ol><script type="math/tex; mode=display">\large w_{0}=w_{0}-\alpha[1-\sigma(\hat{y} y)] * y</script><p>对特征 $i \in(1, \ldots, n)$​ :</p><script type="math/tex; mode=display">\large w_{i}=w_{i}-\alpha[1-\sigma(\hat{y} y)] * y * x_{i}</script><p>对  $f \in(1, \ldots, k)$​ :</p><script type="math/tex; mode=display">\large v_{i, f}=v_{i, f}-\alpha[1-\sigma(\hat{y} y)] * y *\left[x_{i} \sum_{j=1}^{n} v_{j, f} x_{j}-v_{i, f} x_{i}^{2}\right]</script><ol><li>重复步骤2，直到满足终止条件。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/u014595019/article/details/80586438">Matrix Factorization 学习记录（一）：基本原理及实现_Multiangle’s Notepad-CSDN博客</a></p><p><a href="http://www.d2l.ai/chapter_recommender-systems/fm.html">16.9. Factorization Machines — Dive into Deep Learning 0.17.0 documentation (d2l.ai)</a></p><p><a href="https://blog.csdn.net/qq_19446965/article/details/82079367?tdsourcetag=s_pctim_aiomsg">推荐系统中的矩阵分解总结<em>Rnan_prince的博客-CSDN博客</em>推荐系统矩阵分解</a></p><p><a href="https://zhuanlan.zhihu.com/p/35262187">推荐系统之矩阵分解家族 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/153500425">推荐系统玩家 之 因子分解机FM（Factorization Machines） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/145120275">推荐系统玩家 之 矩阵分解(Matrix Factorization)的基本方法 及其 优缺点 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/pinard/p/6370127.html">分解机(Factorization Machines)推荐算法原理 - 刘建平Pinard - 博客园 (cnblogs.com)</a></p><p><a href="http://xiang578.com/post/fm.html">(FM) Factorization Machines | 算法花园 (xiang578.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/24798389">浅谈张量分解（一）：如何简单地进行张量分解？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/24824550">浅谈张量分解（二）：张量分解的数学基础 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/25512080">浅谈张量分解（三）：如何对稀疏矩阵进行奇异值分解？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/wy-ei/p/11534427.html">论文阅读 - Factorization Machines - wy-ei - 博客园 (cnblogs.com)</a></p><p>《深度学习推荐系统》王喆</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 推荐系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【01】【C++】C++引用</title>
      <link href="/2021/11/27/01_C++%E5%BC%95%E7%94%A8/"/>
      <url>/2021/11/27/01_C++%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基本用法"><a href="#一-基本用法" class="headerlink" title="一. 基本用法"></a>一. 基本用法</h2><h3 id="1-例子1"><a href="#1-例子1" class="headerlink" title="1. 例子1"></a>1. 例子1</h3><p>使用引用改变值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt;x&lt;&lt;std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span>&amp; ref = a;<span class="comment">//相当于创建了一个别名</span></span><br><span class="line">    ref = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出2</p><p>需要注意的是，并不存在真正的引用类型的“变量”ref,ref只是a的一个引用，在编译过后也不会存在ref和a两个变量，ref只存在于源代码中。</p><h3 id="2-例子2"><a href="#2-例子2" class="headerlink" title="2. 例子2"></a>2. 例子2</h3><p>给函数传递引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt;x&lt;&lt;std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">Increment</span>(a);</span><br><span class="line">    <span class="built_in">LOG</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出6</p><h2 id="二-需要注意的点"><a href="#二-需要注意的点" class="headerlink" title="二. 需要注意的点"></a>二. 需要注意的点</h2><h3 id="1-一旦声明了一个引用，就不能改变它引用的东西"><a href="#1-一旦声明了一个引用，就不能改变它引用的东西" class="headerlink" title="1.  一旦声明了一个引用，就不能改变它引用的东西"></a>1.  一旦声明了一个引用，就不能改变它引用的东西</h3><p>错误示范</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">8</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br></pre></td></tr></table></figure><p>上述代码只是简单地将a的值更改为8，并没有将原本对a的引用改成对b的引用</p><p>因此，引用声明的时候必须赋值。</p><h3 id="2-与指针的异同"><a href="#2-与指针的异同" class="headerlink" title="2. 与指针的异同"></a>2. 与指针的异同</h3><p>引用能做的指针都能做，指针比引用更为强大，且指针是实际存在的变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】CMake使用示例与整理总结</title>
      <link href="/2021/11/25/CMake%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
      <url>/2021/11/25/CMake%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一-CMake使用示例与整理总结"><a href="#一-CMake使用示例与整理总结" class="headerlink" title="一. CMake使用示例与整理总结"></a>一. CMake使用示例与整理总结</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/wzzfeitian/article/details/40963457">cmake使用示例与整理总结_carl的修行-CSDN博客</a></p><p><a href="https://www.quarkhackers.space/2021/11/18/CMake工程目录结构/">Linux CMake工程目录结构 | 蘑菇的博客 (quarkhackers.space)</a></p><h2 id="1-cmake中一些预定义变量"><a href="#1-cmake中一些预定义变量" class="headerlink" title="1. cmake中一些预定义变量"></a>1. cmake中一些预定义变量</h2><ul><li><p><strong>PROJECT_SOURCE_DIR </strong>工程的根目录</p></li><li><p><strong>PROJECT_BINARY_DIR</strong> 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}/build</p></li><li><p><strong>CMAKE_INCLUDE_PATH</strong> 环境变量,非cmake变量</p></li><li><p><strong>CMAKE_LIBRARY_PATH</strong> 环境变量</p></li><li><p><strong>CMAKE_CURRENT_SOURCE_DIR</strong> 当前处理的CMakeLists.txt所在的路径</p></li><li><p><strong>CMAKE_CURRENT_BINARY_DIR</strong>  target编译目录</p><ul><li>使用<strong>ADD_SURDIRECTORY(src bin)</strong>可以更改此变量的值<br><strong>SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)</strong>并不会对此变量有影响,只是改变了最终目标文件的存储路径</li></ul></li></ul><ul><li><p><strong>CMAKE_CURRENT_LIST_FILE</strong> 输出调用这个变量的CMakeLists.txt的完整路径</p></li><li><p><strong>CMAKE_CURRENT_LIST_LINE</strong> 输出这个变量所在的行</p></li><li><p><strong>CMAKE_MODULE_PATH</strong> 定义自己的cmake模块所在的路径</p><ul><li><strong>SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)</strong>,然后可以用INCLUDE命令来调用自己的模块</li></ul></li></ul><ul><li><p><strong>EXECUTABLE_OUTPUT_PATH</strong> 重新定义目标二进制可执行文件的存放位置</p></li><li><p><strong>LIBRARY_OUTPUT_PATH</strong> 重新定义目标链接库文件的存放位置</p></li><li><p><strong>PROJECT_NAME</strong> 返回通过PROJECT指令定义的项目名称</p></li><li><p><strong>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</strong> 用来控制IF ELSE语句的书写方式</p></li></ul><p>系统信息</p><ul><li><strong>CMAKE_MAJOR_VERSION</strong> cmake主版本号,如2.8.6中的2</li><li><strong>CMAKE_MINOR_VERSION</strong> cmake次版本号,如2.8.6中的8</li><li><strong>CMAKE_PATCH_VERSION</strong> cmake补丁等级,如2.8.6中的6</li><li><strong>CMAKE_SYSTEM</strong> 系统名称,例如Linux-2.6.22</li><li><strong>CAMKE_SYSTEM_NAME</strong> 不包含版本的系统名,如Linux</li><li><strong>CMAKE_SYSTEM_VERSION</strong> 系统版本,如2.6.22</li><li><strong>CMAKE_SYSTEM_PROCESSOR</strong> 处理器名称,如i686<ul><li>UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin</li><li>WIN32 在所有的win32平台为TRUE,包括cygwin</li></ul></li></ul><p>开关选项</p><ul><li><strong>BUILD_SHARED_LIBS</strong> 控制默认的库编译方式。如果未进行设置,使用<strong>ADD_LIBRARY</strong>时又没有指定库类型,默认编译生成的库都是静态库 （可在t3中稍加修改进行验证）</li><li><strong>CMAKE_C_FLAGS</strong> 设置C编译选项</li><li><strong>CMAKE_CXX_FLAGS</strong> 设置C++编译选项</li></ul><h2 id="2-cmake常用命令"><a href="#2-cmake常用命令" class="headerlink" title="2. cmake常用命令"></a>2. cmake常用命令</h2><h3 id="基本语法规则"><a href="#基本语法规则" class="headerlink" title="基本语法规则"></a>基本语法规则</h3><ul><li><p>cmake变量使用<strong>${}</strong>方式取值,但是在<strong>IF</strong>控制语句中是直接使用变量名</p></li><li><p>环境变量使用<strong>$ENV{}</strong>方式取值,使用<strong>SET(ENV{VAR} VALUE)</strong>赋值</p></li><li><p>指令(参数1 参数2…)<br>参数使用括弧括起,参数之间使用空格或分号分开。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以ADD_EXECUTABLE指令为例：</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.c func.c)或者</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.c;func.c)</span><br></pre></td></tr></table></figure></li><li><p>指令是大小写无关的,参数和变量是大小写相关的。推荐全部使用大写指令。</p></li></ul><h3 id="部分常用命令列表："><a href="#部分常用命令列表：" class="headerlink" title="部分常用命令列表："></a>部分常用命令列表：</h3><ul><li><p><strong>PROJECT</strong></p><ul><li><strong>PROJECT(projectname [CXX] [C] [Java])</strong><br>指定工程名称,并可指定工程支持的语言。支持语言列表可忽略,默认支持所有语言</li></ul></li><li><p><strong>SET</strong></p><ul><li><strong>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</strong><br>定义变量(可以定义多个<strong>VALUE</strong>,如<strong>SET(SRC_LIST main.c util.c reactor.c))</strong></li></ul></li><li><p><strong>MESSAGE</strong></p><ul><li><strong>MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] “message to display” …)</strong><br>向终端输出用户定义的信息或变量的值<br><strong>SEND_ERROR</strong>, 产生错误,生成过程被跳过<br><strong>STATUS</strong>, 输出前缀为—的信息<br><strong>FATAL_ERROR</strong>, 立即终止所有cmake过程</li></ul></li><li><p><strong>ADD_EXECUTABLE</strong></p><ul><li><strong>ADD_EXECUTABLE(bin_file_name ${SRC_LIST})</strong>生成可执行文件</li></ul></li><li><p><strong>ADD_LIBRARY</strong></p><ul><li><strong>ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] SRC_LIST)</strong><br>生成动态库或静态库<br><strong>SHARED</strong> 动态库<br><strong>STATIC</strong> 静态库<br><strong>MODULE</strong> 在使用dyld的系统有效,若不支持dyld,等同于<strong>SHARED</strong><br><strong>EXCLUDE_FROM_ALL</strong> 表示该库不会被默认构建</li></ul></li><li><p><strong>SET_TARGET_PROPERTIES</strong></p><ul><li>设置输出的名称,设置动态库的版本和API版本</li></ul></li><li><p><strong>CMAKE_MINIMUM_REQUIRED</strong></p><ul><li><strong>CMAKE_MINIMUM_REQUIRED(VERSION version_number [FATAL_ERROR])</strong><br>声明CMake的版本要求</li></ul></li><li><p><strong>ADD_SUBDIRECTORY</strong></p><ul><li><strong>ADD_SUBDIRECTORY(src_dir [binary_dir] [EXCLUDE_FROM_ALL])</strong><br>向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制的存放位置<br><strong>EXCLUDE_FROM_ALL</strong>含义：将这个目录从编译过程中排除</li></ul></li><li><p><strong>SUBDIRS</strong></p><ul><li>deprecated,不再推荐使用<br>(hello sample)相当于分别写<strong>ADD_SUBDIRECTORY(hello),ADD_SUBDIRECTORY(sample)</strong></li></ul></li><li><p><strong>INCLUDE_DIRECTORIES</strong></p><ul><li><strong>INCLUDE_DIRECTORIES([AFTER | BEFORE] [SYSTEM] dir1 dir2 … )</strong><br>向工程添加多个特定的头文件搜索路径,路径之间用空格分隔,如果路径包含空格,可以使用双引号将它括起来,默认的行为为追加到当前头文件搜索路径的后面。有如下两种方式可以控制搜索路径添加的位置：<ul><li><strong>CMAKE_INCLUDE_DIRECTORIES_BEFORE</strong>,通过SET这个cmake变量为on,可以将添加的头文件搜索路径放在已有路径的前面</li><li>通过<strong>AFTER</strong>或<strong>BEFORE</strong>参数,也可以控制是追加还是置前</li></ul></li></ul></li><li><p><strong>LINK_DIRECTORIES</strong></p><ul><li><strong>LINK_DIRECTORIES(dir1 dir2 …)</strong><br>添加非标准的共享库搜索路径</li></ul></li><li><p><strong>TARGET_LINK_LIBRARIES</strong></p><ul><li><strong>TARGET_LINK_LIBRARIES(target lib1 lib2 …)</strong><br>为target添加需要链接的共享库</li></ul></li><li><p><strong>ADD_DEFINITIONS</strong></p><ul><li>向C/C++编译器添加-D定义<br><strong>ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)</strong>,参数之间用空格分隔</li></ul></li><li><p><strong>ADD_DEPENDENCIES</strong></p><ul><li><strong>ADD_DEPENDENCIES(target-name depend-target1 depend-target2 …)</strong><br>定义target依赖的其他target,确保target在构建之前,其依赖的target已经构建完毕</li></ul></li><li><p><strong>AUX_SOURCE_DIRECTORY</strong></p><ul><li><strong>AUX_SOURCE_DIRECTORY(dir DIR_SRCS)</strong><br>发现一个目录下所有的源代码文件并将列表存储在一个变量中<br>把当前目录下的所有源码文件名赋给变量<strong>DIR_SRCS</strong></li></ul></li><li><p><strong>EXEC_PROGRAM</strong></p><ul><li><p><strong>EXEC_PROGRAM(Executable [dir where to run] [[ARGS<args>]][OUTPUT_VARIABLE ] [RETURN_VALUE <value>])</strong></p></li><li><p>用于在指定目录运行某个程序（默认为当前CMakeLists.txt所在目录）,通过ARGS添加参数,通过<strong>OUTPUT_VARIABLE</strong>和RETURN_VALUE获取输出和返回值,如下示例:</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在src中运行ls命令,在src/CMakeLists.txt添加</span></span><br><span class="line"><span class="keyword">EXEC_PROGRAM</span>(ls ARGS <span class="string">&quot;*.c&quot;</span> OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)</span><br><span class="line"><span class="keyword">IF</span> (<span class="keyword">not</span> LS_RVALUE)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;ls result: &quot;</span> <span class="variable">$&#123;LS_OUTPUT&#125;</span>) </span><br><span class="line">    <span class="comment">#缩进仅为美观,语法无要求</span></span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">not</span> LS_RVALUE)</span><br></pre></td></tr></table></figure></li><li><p><strong>INCLUDE</strong></p><ul><li><strong>INCLUDE(file [OPTIONAL])</strong> 用来载入CMakeLists.txt文件<br><strong>INCLUDE(module [OPTIONAL])</strong>用来载入预定义的cmake模块<br><strong>OPTIONAL</strong>参数的左右是文件不存在也不会产生错误<br>可以载入一个文件,也可以载入预定义模块（模块会在<strong>CMAKE_MODULE_PATH</strong>指定的路径进行搜索）<br>载入的内容将在处理到<strong>INCLUDE</strong>语句时直接执行</li></ul></li><li><p><strong>FIND_</strong></p><ul><li><p><strong>FIND_FILE(<VAR> name path1 path2 …)</strong> <strong>VAR</strong>变量代表找到的文件全路径,包含文件名</p></li><li><p><strong>FIND_LIBRARY(<VAR> name path1 path2 …)</strong> <strong>VAR</strong>变量代表找到的库全路径,包含库文件名</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FIND_LIBRARY</span>(libX X11 /usr/lib)</span><br><span class="line"><span class="keyword">IF</span> (<span class="keyword">NOT</span> libx)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(FATAL_ERROR <span class="string">&quot;libX not found&quot;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">NOT</span> libX)</span><br></pre></td></tr></table></figure></li><li><p><strong>FIND_PATH(<VAR> name path1 path2 …)</strong> <strong>VAR</strong>变量代表包含这个文件的路径</p></li><li><p><strong>FIND_PROGRAM(<VAR> name path1 path2 …) VAR</strong>变量代表包含这个程序的全路径</p></li><li><p><strong>FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE] [[REQUIRED | COMPONENTS] [componets …]]) </strong></p><p>用来调用预定义在<strong>CMAKE_MODULE_PATH</strong>下的<strong>Find<name>.cmake</strong>模块,你也可以自己定义<strong>Find<name></strong> 模块,通过<strong>SET(CMAKE_MODULE_PATH dir)</strong>将其放入工程的某个目录供工程使用</p></li></ul></li><li><p><strong>IF</strong></p><ul><li><p>语法:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span> (expression)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ELSE</span> (expression)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDIF</span> (expression) <span class="comment"># 一定要有ENDIF与IF对应</span></span><br></pre></td></tr></table></figure></li><li><p><strong>IF (expression), expression</strong>不为：空,0,N,NO,OFF,FALSE,NOTFOUND或<var>_NOTFOUND,为真</p><p><strong>IF (not exp)</strong>, 与上面相反<br><strong>IF (var1 AND var2)</strong><br><strong>IF (var1 OR var2)</strong><br><strong>IF (COMMAND cmd)</strong> 如果cmd确实是命令并可调用,为真<br><strong>IF (EXISTS dir) IF (EXISTS file)</strong> 如果目录或文件存在,为真<br><strong>IF (file1 IS_NEWER_THAN file2)</strong>,当file1比file2新,或file1/file2中有一个不存在时为真,文件名需使用全路径<br><strong>IF (IS_DIRECTORY dir)</strong> 当dir是目录时,为真<br><strong>IF (DEFINED var)</strong> 如果变量被定义,为真<br><strong>IF (var MATCHES regex)</strong> 此处<strong>var</strong>可以用<strong>var</strong>名,也可以用<strong>${var}</strong><br><strong>IF (string MATCHES regex)</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当给定的变量或者字符串能够匹配正则表达式regex时为真。比如：</span><br><span class="line"><span class="keyword">IF</span> (<span class="string">&quot;hello&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;ell&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span> (<span class="string">&quot;hello&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;ell&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>数字比较表达式</strong></p><p><strong>IF (variable LESS number)</strong><br><strong>IF (string LESS number)</strong><br><strong>IF (variable GREATER number)</strong><br><strong>IF (string GREATER number)</strong><br><strong>IF (variable EQUAL number)</strong><br><strong>IF (string EQUAL number)</strong></p></li><li><p><strong>按照字母表顺序进行比较</strong></p><p><strong>IF (variable STRLESS string)</strong><br><strong>IF (string STRLESS string)</strong><br><strong>IF (variable STRGREATER string)</strong><br><strong>IF (string STRGREATER string)</strong><br><strong>IF (variable STREQUAL string)</strong><br><strong>IF (string STREQUAL string)</strong></p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">一个小例子,用来判断平台差异：</span><br><span class="line"><span class="keyword">IF</span> (WIN32)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS “This is windows.”)</span><br><span class="line"><span class="keyword">ELSE</span> (WIN32)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS “This is <span class="keyword">not</span> windows”)</span><br><span class="line"><span class="keyword">ENDIF</span> (WIN32)</span><br><span class="line">上述代码用来控制在不同的平台进行不同的控制,但是,阅读起来却并不是那么舒服,<span class="keyword">ELSE</span>(WIN32)之类的语句很容易引起歧义。</span><br><span class="line">可以<span class="keyword">SET</span>(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS <span class="keyword">ON</span>)</span><br><span class="line">这时候就可以写成:</span><br><span class="line"><span class="keyword">IF</span> (WIN32)</span><br><span class="line"><span class="keyword">ELSE</span> ()</span><br><span class="line"><span class="keyword">ENDIF</span> ()</span><br><span class="line">配合<span class="keyword">ELSEIF</span>使用,可能的写法是这样:</span><br><span class="line"><span class="keyword">IF</span> (WIN32)</span><br><span class="line">    <span class="comment">#do something related to WIN32</span></span><br><span class="line"><span class="keyword">ELSEIF</span> (UNIX)</span><br><span class="line">    <span class="comment">#do something related to UNIX</span></span><br><span class="line"><span class="keyword">ELSEIF</span>(APPLE)</span><br><span class="line">    <span class="comment">#do something related to APPLE</span></span><br><span class="line"><span class="keyword">ENDIF</span> (WIN32)</span><br></pre></td></tr></table></figure></li><li><p><strong>WHILE</strong></p><ul><li><p>语法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHILE</span>(condition)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDWHILE</span>(condition)</span><br></pre></td></tr></table></figure><p>其真假判断条件可以参考IF指令</p></li></ul></li><li><p><strong>FOREACH</strong></p><p><strong>FOREACH</strong>指令的使用方法有三种形式：</p><ul><li><p><strong>列表</strong></p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var arg1 arg2 ...)</span><br><span class="line">     COMMAND1(ARGS ...)</span><br><span class="line">     COMMAND2(ARGS ...)</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">FOREACH</span>(F <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line">     <span class="keyword">MESSAGE</span>(<span class="variable">$&#123;F&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(F)</span><br></pre></td></tr></table></figure></li><li><p><strong>范围</strong></p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var RANGE total)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从<span class="number">0</span>到total以１为步进</span><br><span class="line"><span class="keyword">FOREACH</span>(VAR RANGE <span class="number">10</span>)</span><br><span class="line">   <span class="keyword">MESSAGE</span>(<span class="variable">$&#123;VAR&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(VAR)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">012345678910</span></span><br></pre></td></tr></table></figure></li><li><p><strong>范围和步进</strong></p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var RANGE start stop [step])</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure><p>从start开始到stop结束,以step为步进,<br><strong>注意：</strong>直到遇到ENDFOREACH指令,整个语句块才会得到真正的执行。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(A RANGE <span class="number">5</span> <span class="number">15</span> <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(<span class="variable">$&#123;A&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(A)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">581114</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-cmake中如何生成动态库和静态库"><a href="#3-cmake中如何生成动态库和静态库" class="headerlink" title="3. cmake中如何生成动态库和静态库"></a>3. cmake中如何生成动态库和静态库</h2><p>参考<strong>ADD_LIBRARY</strong>和SET_TARGET_PROPERTIES用法<br>t3示例</p><h2 id="4-cmake中如何使用动态库和静态库（查找库的路径）"><a href="#4-cmake中如何使用动态库和静态库（查找库的路径）" class="headerlink" title="4. cmake中如何使用动态库和静态库（查找库的路径）"></a>4. cmake中如何使用动态库和静态库（查找库的路径）</h2><p>参考<strong>INCLUDE_DIRECTORIES</strong>, <strong>LINK_DIRECTORIES</strong>, <strong>TARGET_LINK_LIBRARIES</strong>用法<br>t4示例使用动态库或静态库<br>t5示例如何使用cmake预定义的cmake模块(以FindCURL.cmake为例演示)<br>t6示例如何使用自定义的cmake模块(编写了自定义的FindHELLO.cmake)<br>注意读t5和t6的CMakeLists.txt和FindHELLO.cmake中的注释部分</p><h2 id="5-cmake中如何指定生成文件的输出路径"><a href="#5-cmake中如何指定生成文件的输出路径" class="headerlink" title="5. cmake中如何指定生成文件的输出路径"></a>5. cmake中如何指定生成文件的输出路径</h2><p>如上<strong>ADD_SUBDIRECTORY</strong>的时候指定目标二进制文件输出路径（推荐使用下面这种）<br>使用SET命令重新定义<strong>EXECUTABLE_OUTPUT_PATH</strong>和<strong>LIBRARY_OUTPUT_PATH</strong>变量来指定最终的二进制文件的位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure><p>上面的两条命令通常紧跟<strong>ADD_EXECUTABLE</strong>和<strong>ADD_LIBRARY</strong>,与其写在同一个CMakeLists.txt即可</p><h2 id="6-cmake中如何增加编译选项"><a href="#6-cmake中如何增加编译选项" class="headerlink" title="6. cmake中如何增加编译选项"></a>6. cmake中如何增加编译选项</h2><p>使用变量<strong>CMAKE_C_FLAGS</strong>添加C编译选项<br>使用变量<strong>CMAKE_CXX_FLAGS</strong>添加C++编译选项<br>使用A<strong>DD_DEFINITION</strong>添加</p><h2 id="7-cmake中如何增加头文件路径"><a href="#7-cmake中如何增加头文件路径" class="headerlink" title="7. cmake中如何增加头文件路径"></a>7. cmake中如何增加头文件路径</h2><p>参考<strong>INCLUDE_DIRECTORIES</strong>命令用法</p><h2 id="8-cmake中如何在屏幕上打印信息"><a href="#8-cmake中如何在屏幕上打印信息" class="headerlink" title="8. cmake中如何在屏幕上打印信息"></a>8. cmake中如何在屏幕上打印信息</h2><p>参考<strong>MESSAGE</strong>用法</p><h2 id="9-cmake中如何给变量赋值"><a href="#9-cmake中如何给变量赋值" class="headerlink" title="9. cmake中如何给变量赋值"></a>9. cmake中如何给变量赋值</h2><p>参考<strong>SET</strong>和<strong>AUX_SOURCE_DIRECTORY</strong>用法</p><p>建议：在Project根目录先建立build,然后在build文件夹内运行cmake ..，这样就不会污染源代码, 如果不想要这些自动生成的文件了，只要简单的删除build文件夹就可以</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】Bert微调</title>
      <link href="/2021/11/20/bert_finetune/"/>
      <url>/2021/11/20/bert_finetune/</url>
      
        <content type="html"><![CDATA[<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/98855346">什么是BERT？ - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/48612853">词向量之BERT - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/103226488">BERT 详解 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/48508221">详解Transformer （Attention Is All You Need） - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/406786658">从Transformer到Bert - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zh-v2.d2l.ai/chapter_natural-language-processing-pretraining/bert-pretraining.html">14.10. 预训练BERT — 动手学深度学习 2.0.0-alpha2 documentation (d2l.ai)</a></p></li><li><p><a href="https://www.bilibili.com/video/av246993280?p=49">(强推)李宏毅2021春机器学习课程_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://www.bilibili.com/video/av847491605">70 BERT微调【动手学深度学习v2】_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://www.jianshu.com/p/2daf69f8408f">Bert细节整理 - 简书 (jianshu.com)</a></p></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><ul><li><a href="http://www.d2l.ai/chapter_natural-language-processing-applications/natural-language-inference-bert.html">http://www.d2l.ai/chapter_natural-language-processing-applications/natural-language-inference-bert.html</a></li></ul><h2 id="一-回顾Transformer"><a href="#一-回顾Transformer" class="headerlink" title="一. 回顾Transformer"></a>一. 回顾Transformer</h2><p>Transformer就是结合了自注意力机制的encoder-decoder网络。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171658412.jpeg" style="zoom: 80%;" /></p><p>图的左边是Encoder右边是Decoder</p><h2 id="二-BERT是什么有什么用"><a href="#二-BERT是什么有什么用" class="headerlink" title="二. BERT是什么有什么用"></a>二. BERT是什么有什么用</h2><h3 id="1-BERT的优点"><a href="#1-BERT的优点" class="headerlink" title="1.BERT的优点"></a>1.BERT的优点</h3><p>​       在我们熟知的图像处理方向，模型微调的技术已经十分的成熟，我们CNN在学习过程中可以提取到一些深层特征和浅层特征，浅层的CNN网络往往学习到一些边缘，形状的很低级的特征，而深层网络可以学习到更加高级的特征，这些特征在许多图像处理问题中是通用的，所以可以载入预先训练好的模型权重，根据具体问题修改输出层进行再训练就可以取得比较好的效果。</p><p>​        在NLP领域的模型预训练和微调，就是采用的BERT,我们可以用特定的文本处理任务训练BERT,再将训练好的BERT模型进行魔改以适应不同的任务。</p><p>​        BERT有如下的特点：</p><ul><li><p>采用MLM对双向的Transformers进行预训练，以生成深层的双向语言表征。</p></li><li><p>预训练后，只需要添加一个额外的输出层进行fine-tune，就可以在各种各样的下游任务中取得很好的表现。在这过程中并不需要对BERT进行任务特定的结构修改。</p></li></ul><h3 id="2-BERT与Transformer的联系"><a href="#2-BERT与Transformer的联系" class="headerlink" title="2. BERT与Transformer的联系"></a>2. BERT与Transformer的联系</h3><p>我们可能都知道BERT只采用了Transformer的Encoder部分，但实际上这样的说法很容易让人产生误解，让人以为BERT只是Transformer的缩小版而已，实际上BERT模型比是Transformer大几个数量级。</p><p>下图更加直观地展示了BERT与Transformer之间的关系。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171658907.jpeg" style="zoom:80%;" /><br>BERT将Transformer的编码器部分进行叠加。</p><p>论文中的BERT提供了简单和复杂两个模型，对应的超参数分别如下：</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BBERT%7D_%7B%5Cmathbf%7BBASE%7D%7D" alt="[公式]"> : L=12，H=768，A=12，参数总量110M；</li><li><img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7BBERT%7D_%7B%5Cmathbf%7BLARGE%7D%7D" alt="[公式]"> : L=24，H=1024，A=16，参数总量340M；</li></ul><p>在上面的超参数中，L表示网络的层数（即Transformer blocks的数量），A表示Multi-Head Attention中self-Attention的数量，filter的尺寸是4H。</p><h2 id="三-BERT预训练"><a href="#三-BERT预训练" class="headerlink" title="三. BERT预训练"></a>三. BERT预训练</h2><h3 id="1-关于自监督学习Self-supervised-learning"><a href="#1-关于自监督学习Self-supervised-learning" class="headerlink" title="1. 关于自监督学习Self-supervised-learning"></a>1. 关于自监督学习Self-supervised-learning</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171658594.png" style="zoom:67%;" /><br>自监督学习与监督学习的区别在于标签并不是特意标注的，而是通过训练数据集自己产生的，而BERT可以看作是一种自监督学习模型，即BERT在进行与训练的时候所用的标签其实就是来自与文本数据自身。</p><p>具体是如何做到的呢？主要是通过两个预训练任务的设计来实现的，一个是MLM(Masked Language Model),另一个是NSP(Next Sentence Prediction),这个之后再解释。</p><h3 id="2-BERT输入表示"><a href="#2-BERT输入表示" class="headerlink" title="2. BERT输入表示"></a>2. BERT输入表示</h3><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171658642.jpeg" style="zoom: 80%;" /></p><p>BERT的输入为每一个token对应的表征<em>（图中的粉红色块就是token，黄色块就是token对应的表征）</em>，并且单词字典是采用WordPiece算法来进行构建的。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171658947.jpeg"  /></p><p>每一个token对应的表征组成一个编码向量（长度是512），该编码向量是3个嵌入特征的单位和，这三个词嵌入特征是：</p><ol><li><p>WordPiece 嵌入：</p><p>WordPiece是指将单词划分成一组有限的公共子词单元，能在单词的有效性和字符的灵活性之间取得一个折中的平衡。例如将‘playing’被拆分成了‘play’和‘ing’；</p></li><li><p>位置嵌入（Position Embedding）：</p><p>位置嵌入是指将单词的位置信息编码成特征向量，位置嵌入是向模型中引入单词位置关系的至关重要的一环。</p><p>位置嵌入其实就是一种代替位置编码的方法，当初讲自注意力机制的时候，使用的是不用带参数的位置编码，并且采用的是三角函数，为的是让输入数据带有位置信息，而BERT延续了这一思想，只不过将参数全部改成了可以学习的参数。</p></li><li><p>分割嵌入（Segment Embedding）：用于区分两个句子，例如B是否是A的下文（对话场景，问答场景等）。对于句子对，第一个句子的特征值是0，第二个句子的特征值是1。</p></li></ol><p>两个特殊符号<code>[CLS]</code>和<code>[SEP]</code>，其中<code>[CLS]</code>表示该特征用于分类模型，对非分类模型，该符合可以省去。<code>[SEP]</code>表示分句符号，用于断开输入语料中的两个句子。</p><h3 id="3-BERT预训练任务"><a href="#3-BERT预训练任务" class="headerlink" title="3. BERT预训练任务"></a>3. BERT预训练任务</h3><h4 id="3-1-Masked-Language-Model（MLM）"><a href="#3-1-Masked-Language-Model（MLM）" class="headerlink" title="3.1 Masked Language Model（MLM）"></a>3.1 Masked Language Model（MLM）</h4><p>​        所谓MLM是指在训练的时候随即从输入预料上mask掉一些单词，然后通过的上下文预测该单词，该任务非常像完形填空。</p><p>​        mask的好处，即预测一个词汇时，模型并不知道输入对应位置的词汇是否为正确的词汇（ 10% 概率），这就迫使模型更多地依赖于上下文信息去预测词汇，并且赋予了模型一定的纠错能力。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171658945.png" style="zoom: 50%;" /></p><p>这个mask可以是特殊符号‘<mask>’也可以是随机选取一些乱七八糟的符号，又或者是原来正确的符号。</p><p>在BERT的实验中，15%的WordPiece Token会被随机Mask掉。在训练模型时，一个句子会被多次喂到模型中用于参数学习，但是Google并没有在每次都mask掉这些单词，而是在确定要Mask掉的单词之后，80%的时候会直接替换为[Mask]，10%的时候将其替换为其它任意单词，10%的时候会保留原始Token。</p><ul><li>80%：<code>my dog is hairy -&gt; my dog is [mask]</code></li><li>10%：<code>my dog is hairy -&gt; my dog is apple</code></li><li>10%：<code>my dog is hairy -&gt; my dog is hairy</code></li></ul><p>​        这么做的原因是如果句子中的某个Token100%都会被mask掉，那么在fine-tuning的时候模型就会有一些没有见过的单词。加入随机Token的原因是因为Transformer要保持对每个输入token的分布式表征，否则模型就会记住这个[mask]是token ’hairy‘，但是实际fine-tune的时候并没有[mask]这个符号。至于随机单词带来的负面影响，因为一个单词被随机替换掉的概率只有15%*10% =1.5%，这个负面影响其实是可以忽略不计的。</p><h4 id="3-2-Next-Sentence-Prediction（NSP）"><a href="#3-2-Next-Sentence-Prediction（NSP）" class="headerlink" title="3.2 Next Sentence Prediction（NSP）"></a>3.2 Next Sentence Prediction（NSP）</h4><p>​        为了帮助 理解两个⽂本序列之间的关系，BERT在预训练中考虑了⼀个⼆元分类任务——下⼀句预测。在为预训练⽣成 句⼦对时，有⼀半的时间它们确实是标签为“真”的连续句⼦；在另⼀半的时间⾥，第⼆个句⼦是从语料库 中随机抽取的，标记为“假”。</p><ul><li>预测一个句子对中的两个句子是否相邻</li><li>训练样本中：<ul><li>50%概率选择相邻句子对:<cls>this movie is great <seq>i like it<sep></li><li>50%概率选择随机句子对:<cls>this movie is great <seq>hello world<sep></li><li>将<cls>对应的输出放到一个全连接层来预测</li></ul></li></ul><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171659492.png" style="zoom: 50%;" /></p><p>​       关于NSP是否有用是存在争议的，(参见RoBERTa这篇论文)。因为选定一个句子作为前一个句子，大部分情况下随机选到的句子都不是后一个句子，也就是BERT是很容易判断出来两个句子是否相邻的。对此也有人提出了改进方法SOP，SOP更加侧重于判断两个句子的前后关系，而不是两个句子是否相邻。</p><h4 id="Tips-BERT预训练是多任务模型的预训练，因此NSP和MLM两个任务的训练是同时进行的。"><a href="#Tips-BERT预训练是多任务模型的预训练，因此NSP和MLM两个任务的训练是同时进行的。" class="headerlink" title="Tips: BERT预训练是多任务模型的预训练，因此NSP和MLM两个任务的训练是同时进行的。"></a>Tips: BERT预训练是多任务模型的预训练，因此NSP和MLM两个任务的训练是同时进行的。</h4><h2 id="四-BERT微调fine-tune"><a href="#四-BERT微调fine-tune" class="headerlink" title="四. BERT微调fine-tune"></a>四. BERT微调fine-tune</h2><h3 id="1-自然语言推理-Natural-Language-Inference"><a href="#1-自然语言推理-Natural-Language-Inference" class="headerlink" title="1. 自然语言推理(Natural Language Inference)"></a>1. 自然语言推理(Natural Language Inference)</h3><p>自然语言推理研究是否有假设可以从前提推断出来，其中两者都是文本序列。换句话说，自然语言推理决定了一对文本序列之间的逻辑关系。这种关系通常分为三种类型：</p><ul><li><em>蕴含（entailment）</em>：假设可以从前提中推断出来。</li><li><em>矛盾（contradiction）</em>：可以从前提中推断假设的否定。</li><li><em>中立（neutral）</em>：所有其他情况。</li></ul><p>自然语言推理也被称为识别文本蕴含任务。例如，下面的词元对将被标记为<em>蕴含（entailment）</em>，因为假设中的 “显示亲情” 可以从前提中的 “相互拥抱” 推断出来。</p><blockquote><p>前提：两个女人互相拥抱。</p><p>假设：两个女人表现出亲情。</p></blockquote><p>以下是 <em>矛盾</em> 的例子，因为 “运行编码示例” 表示 “没有睡觉” 而不是 “睡觉”。</p><blockquote><p>前提：一个男人正在运行从 “潜入深度学习” 中的编码示例。</p><p>假设：那个男人在睡觉。</p></blockquote><p>第三个例子显示了 <em> 中立性 </em> 关系，因为 “正在为我们表演” 这一事实既不能推断 “著名的” 也不是 “不出名”。</p><blockquote><p>前提：音乐家们正在为我们表演。</p><p>假设：音乐家很有名。</p></blockquote><h3 id="2-NLI微调模型"><a href="#2-NLI微调模型" class="headerlink" title="2. NLI微调模型"></a>2. NLI微调模型</h3><p>​        BERT在预训练好之后就可以通过更改输出层来完成不同的任务，本节所讲的fine-tune应用是自然语言推理Natural Language Inference</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171659848.png" style="zoom: 80%;" /></p><p>本次微调所用的输出层很简单，直接在BERT输出层添加一个多层感知机。</p><h3 id="3-SNLI数据集"><a href="#3-SNLI数据集" class="headerlink" title="3. SNLI数据集"></a>3. SNLI数据集</h3><p>To Be Continued !</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文】英文摘抄</title>
      <link href="/2021/11/14/en_paper_tips/"/>
      <url>/2021/11/14/en_paper_tips/</url>
      
        <content type="html"><![CDATA[<h2 id="一-常用句式"><a href="#一-常用句式" class="headerlink" title="一. 常用句式"></a>一. 常用句式</h2><h3 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h3><h3 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h3><p>In recent years, DG has received increasing attention from the research community due to its importance to practical applications.</p><p>To overcome the domain shift problem, as well as the absence of target data, the problem of domain generalization (DG) is introduced .</p><p>In this survey paper, we aim to provide a timely and comprehensive literature review.   </p><p>In the context of DG,(就DG而言)</p><p>There has been a lively interest since pansharpening in the last few decades.</p><p>They are generally superior to the CS class in preserving spectral contents but suffer from spatial distortion.</p><h3 id="3-Related-work"><a href="#3-Related-work" class="headerlink" title="3. Related work"></a>3. Related work</h3><h3 id="4-Formulation"><a href="#4-Formulation" class="headerlink" title="4. Formulation"></a>4. Formulation</h3><h3 id="5-Implementation"><a href="#5-Implementation" class="headerlink" title="5. Implementation"></a>5. Implementation</h3><h3 id="6-Results"><a href="#6-Results" class="headerlink" title="6. Results"></a>6. Results</h3><h3 id="7-Limitations-and-Discussion"><a href="#7-Limitations-and-Discussion" class="headerlink" title="7. Limitations and Discussion"></a>7. Limitations and Discussion</h3><h2 id="二-常用词汇"><a href="#二-常用词汇" class="headerlink" title="二. 常用词汇"></a>二. 常用词汇</h2><ul><li>exploiting image characteristic 提取图像特征</li><li>learn the mapping between 学习A与B之间的映射</li><li>are solely based on 仅仅基于</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【多媒体】ffmpeg将webm格式转换成mp4</title>
      <link href="/2021/10/25/ffmpeg%E5%B0%86webm%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%88%90mp4/"/>
      <url>/2021/10/25/ffmpeg%E5%B0%86webm%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%88%90mp4/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>手头有一部4K风景视频，辛辛苦苦从油管上下载下来，想要用wallpaper engine做成壁纸，却发现格式是webm,vp9编码，wallpaper engine并不支持，所以想要将格式进行转换。<br>怎么说呢，感觉还是ffmpeg更方便，就是参数很难调。所以在此记录一下。</p><h1 id="转换成HEVC编码-H-265"><a href="#转换成HEVC编码-H-265" class="headerlink" title="转换成HEVC编码(H.265)"></a>转换成HEVC编码(H.265)</h1><p>因为是使用的硬件编码，<a href="https://www.jianshu.com/p/1d645b9d26d5">硬件编码教程</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -c:v vp9_cuvid -i video.webm -c:v hevc_nvenc -cq 0 video.mp4</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-c:v ：指定编解码器</li><li>-i : 指定输入参数</li><li>vp9_cuvid : 使用nvdia硬件vp9解码器</li><li>hevc_enc:   使用nvdia硬件h.265编码器</li><li>-cq : 也就是软压的-crf参数很类似,控制码率的参数，0最低对应画质好，数字越大越差</li></ul><p>转换之后发现wallpaper engine不支持hevc，麻了，而且码率输入进去的有20000K左右，出来只有2000K了，压得实在太狠了。</p><h1 id="转换成AVC编码-h-264"><a href="#转换成AVC编码-h-264" class="headerlink" title="转换成AVC编码(h.264)"></a>转换成AVC编码(h.264)</h1><p>考虑到想要无损编码，至少码率不要损失得太严重，所以找到了新的解决办法</p><p>根据<a href="https://blog.csdn.net/ETalien_/article/details/102931065">这篇博客</a></p><p>这次采用的是硬解软编<br>输出直接用CPU编码了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -c:v vp9_cuvid -i video.webm -c:v libx264 -preset ultrafast -qp 0 video.mp4</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>libx264:   使用软件h.264编码器</li><li>-qp : constant quantizer恒定量化器模式,并且画质为无损的画质</li><li>-preset : 使用预设参数，preset由快到慢可以分为：ultrafast、superfast、veryfast、faster、fast、medium、slow、slower、veryslow、placebo这9个等级</li><li>ultralfast预设参数最快 </li></ul><p>好家伙，最快的情况下CPU编码比GPU还快，但是输出码率超级无敌大，简直就是直接往硬盘里面写数据罢了，换成fast试过，马上就慢下来不敌GPU了。</p><p>最后委屈求全，手动指定码率，并且采用h.264硬件编码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -c:v vp9_cuvid -i video.webm -c:v h264_nvenc -b:v 23000k video.mp4</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>h264_nvenc:   使用硬件h.264编码器</li><li>-b:v : 控制平均码率</li></ul><p>总算是解决了，即把视频转码了，也没损失太多码率保证了画质，然后可以上传wallpaper engine了！</p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a href="https://blog.csdn.net/ETalien_/article/details/102931065">ffmpeg：码率控制模式、编码方式</a><br><a href="https://blog.csdn.net/yu540135101/article/details/84346146">ffmpeg实例，比特率码率（-b）、帧率（-r）和文件大小（-fs）相关操作</a><br><a href="https://blog.csdn.net/qq_22633333/article/details/107701301">ffmpeg实现硬件转码（使用FFmpeg调用NVIDIA GPU实现H265转码H264）</a><br><a href="https://cloud.tencent.com/developer/article/1641894">阅读3分 | ffmpeg无损转换mp4到webm可不可行？为你揭晓答案</a><br><a href="https://magiclen.org/ffmpeg-h265/">如何用FFmpeg将影像转成H.265/HEVC格式？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 多媒体 </tag>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】自注意力</title>
      <link href="/2021/10/14/self_attention/"/>
      <url>/2021/10/14/self_attention/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们前面说过，注意力机制包含几个重要的参数，query，key，value，针对不同的问题，往往需要选择合适的变量来作为query，key,和value，当遇到query,key,value都是同一个东西，同一种参数的时候，这样的机制叫做自注意力机制。</p><h2 id="1-自注意力"><a href="#1-自注意力" class="headerlink" title="1. 自注意力"></a>1. 自注意力</h2><p>假设我们有一个输入序列</p><script type="math/tex; mode=display">\mathbf{x}_{1}, \ldots, \mathbf{x}_{n}, \forall \mathbf{x}_{i} \in \mathbb{R}^{d}</script><p>xi是第i个时间步的输入，d是输入值的特征维度，自注意力池化层将xi同时作为query,key,value，对序列抽取特征得到</p><script type="math/tex; mode=display">\mathbf{y}_{1}, \ldots, \mathbf{y}_{n}</script><p>其中  </p><script type="math/tex; mode=display">\mathbf{y}_{i}=f\left(\mathbf{x}_{i},\left(\mathbf{x}_{1}, \mathbf{x}_{1}\right), \ldots,\left(\mathbf{x}_{n}, \mathbf{x}_{n}\right)\right) \in \mathbb{R}^{d}</script><p>xi作为query，key-value对包含了所有的xi对，对应序列中的每一个元素xi都会输出一个yi。</p><p><a href="https://imgtu.com/i/f4TBZ9"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171709274.png" alt="f4TBZ9.png"></a></p><h2 id="2-与CNN-RNN对比"><a href="#2-与CNN-RNN对比" class="headerlink" title="2. 与CNN,RNN对比"></a>2. 与CNN,RNN对比</h2><p><a href="https://imgtu.com/i/f4q77Q"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171709628.png" alt="f4q77Q.png"></a></p><p>对于CNN，k就是指卷积核的大小，n是输入数据量，d是指数据维度，并行度就是说每个输出之间可以各自独立运算出结果，第一个输出的结果不取决于上一个输出，这样的话就很方便进行并行的计算，大家可以同时计算，这样的计算效率就比较高。<br><a href="https://imgtu.com/i/f4OIoQ"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171709132.png" alt="f4OIoQ.png"></a></p><p>最长路径我理解的是输入信息在前向计算和反向传播过程中影响到另一个输入所需要走过的最长路径。</p><p><a href="https://imgtu.com/i/f4quYn"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171710321.png" alt="f4quYn.png"></a></p><p>自注意力的计算复杂度比较高，尤其是输入序列较长的时候，根据之前计算yi的公式，我们需要把序列中的每个元素都进行计算，这带来了比较大的计算负担。但是最大路径很短，这在网路示意图中可以很明显的看到，当序列很长的时候可以很快获取到距离比较远的信息。且相较于RNN多级传递可以有较少的信息损失。</p><p>我们都知道RNN适合处理序列但处理长序列就会有长程依赖的问题，为了解决这个问题提出了LSTM，但LSTM正如它的名字长短时记忆网络，终究只是比较长的短时记忆网络，原有局限性有改善但是依旧存在，因此结合自注意力池化可以做得更好，付出的代价就是高昂的计算成本。</p><h2 id="3-位置编码"><a href="#3-位置编码" class="headerlink" title="3. 位置编码"></a>3. 位置编码</h2><p>跟CNN和RNN不同，自注意力并没有记录位置信息。</p><p><a href="https://imgtu.com/i/f5pDXR"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171710457.png" alt="f5pDXR.png" style="zoom:50%;" /></a></p><p>意思就是当我输入序列顺序打乱，输出的顺序也会打乱，但是对应位置上的输出本身内容并不会发生改变，但是我们知道在处理序列的时候元素的顺序也是信息的一部分，比如在在翻译任务里面语序的不同往往对应不同的输出。</p><p>一个解决办法就是把位置信息添加到输入序列中，让输入数据本身就带有位置信息。</p><h4 id="位置矩阵"><a href="#位置矩阵" class="headerlink" title="位置矩阵"></a>位置矩阵</h4><p>假设长度为n的序列是$\mathbf{X} \in \mathbb{R}^{n \times d}$，那么使用一个位置编码矩阵$\mathbf{P} \in \mathbb{R}^{n \times d}$,​将P加在X上，将X+P作为输入。其中P本身包含了许多关于X元素的位置信息，那么我们的目标就是找到一个合理的算法能够有效的提取X的位置信息并且存储在P里面。</p><p>P的计算公式如下：</p><p>$p<em>{i, 2 j}=\sin \left(\frac{i}{10000^{2 j / d}}\right), \quad p</em>{i, 2 j+1}=\cos \left(\frac{i}{10000^{2 j / d}}\right)$</p><p>i代表序列的第几个元素，即所谓的位置，j代表第几个特征维度。奇数列和偶数列不一样。</p><p>这是位置矩阵的图像。</p><p><a href="https://imgtu.com/i/f5PQpD"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171710409.png" alt="f5PQpD.png"  /></a></p><p>途中的Row(position)对应的是位置矩阵的n，即第几个元素，不同的col列对应不同的特征维度。</p><p>模型需要有一定能力才能够学习到输入数据和位置信息之间的关系，这个位置矩阵存储的是相对位置信息。</p><p>我觉得可以借助信号处理的知识来理解这个位置矩阵，在信号与系统我们可以知道，对于任意一个时序信号我们都可以通过傅里叶变换将一个信号变换到频域，这个信号就会存在许多频域的分量。每一个频率分量在时域上进行叠加就得到一个完整的信号。</p><p>我们可以将输入序列X的每一维特征类比到频域的每一个频率分量即col6,col7都对应一个频率分量，然后不同的位置i或者时间点t即Row（position）就对应输入信号的不同的相位。不同的时间点i之间的差就可以类比相位差。</p><p>我们知道正弦信号具有周期性，所以其实相位差代表的就是相对位置关系，所以我们可以认为位置矩阵存储的是相对位置关系。</p><p><a href="https://imgtu.com/i/f5Abse"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171710408.png" alt="f5Abse.png" style="zoom: 80%;" /></a></p><h4 id="绝对位置信息"><a href="#绝对位置信息" class="headerlink" title="绝对位置信息"></a>绝对位置信息</h4><p>或者可以借助计算机使用的二进制编码来理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 in binary is 000</span><br><span class="line">1 in binary is 001</span><br><span class="line">2 in binary is 010</span><br><span class="line">3 in binary is 011</span><br><span class="line">4 in binary is 100</span><br><span class="line">5 in binary is 101</span><br><span class="line">6 in binary is 110</span><br><span class="line">7 in binary is 111</span><br></pre></td></tr></table></figure><p>我们也可以将$0~7$这个序列的每个元素都由长度为3的特征表示，低位的特征变化频率就比高位的变化要快。</p><p><a href="https://imgtu.com/i/f5mh3q"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171710776.png" alt="f5mh3q.png"></a></p><h4 id="相对位置信息"><a href="#相对位置信息" class="headerlink" title="相对位置信息"></a>相对位置信息</h4><p>位置位于$i+\delta$​处的位置编码可由线性投影位置$i$​处的位置编码来表示​</p><p>记$\omega_{j}=1 / 10000^{2 j / d}$，那么</p><p>$\left[\begin{array}{cc}\cos \left(\delta \omega<em>{j}\right) &amp; \sin \left(\delta \omega</em>{j}\right) \ -\sin \left(\delta \omega<em>{j}\right) &amp; \cos \left(\delta \omega</em>{j}\right)\end{array}\right]\left[\begin{array}{c}p<em>{i, 2 j} \ p</em>{i, 2 j+1}\end{array}\right]=\left[\begin{array}{c}p<em>{i+\delta, 2 j} \ p</em>{i+\delta, 2 j+1}\end{array}\right]$</p><p>这样就意味着输入序列的两个元素之间的相对位置关系固定的情况下，不管其中一个元素的绝对位置在哪，它们之间的相对位置关系都可以用同一个投影矩阵表示，毕竟这个投影矩阵和绝对位置$i$​没有关系。如果要用一个参数$W$​，表示相对位置关系采用这样的形式就可以不用顾及元素出现在序列的哪一个位置。</p><p>其实也可以用相位差来类比，正弦信号相乘会引起相位变化。</p><p><a href="https://imgtu.com/i/f5Kkct"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171710421.jpeg" alt="f5Kkct.md.jpg"></a></p><p>可以看到，在与投影矩阵相乘之后，原来的正弦函数发生了相位偏移。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>自注意力池化层将$x_i$​当作key,value,query来对序列抽取特征​</li><li>完全并行，最长序列为1(对于任何一个输出都参考了整个序列的信息)，长序列计算成本高</li><li>位置编码在输入中加入位置信息，使得自注意力能够记忆位置信息。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/13/hello-world/"/>
      <url>/2021/10/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】基于PyQt5的Huffman编解码系统</title>
      <link href="/2020/07/04/%E5%9F%BA%E4%BA%8EPyQt5%E7%9A%84Huffman%E7%BC%96%E8%A7%A3%E7%A0%81%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/07/04/%E5%9F%BA%E4%BA%8EPyQt5%E7%9A%84Huffman%E7%BC%96%E8%A7%A3%E7%A0%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p> 最近布置的作业要整个编码压缩译码解压缩系统，唉真是难啊，临时花了几天看PyQt5，踩了无数坑，终于算是弄完了。</p><p>弄了动态背景，其实就是GIF图播放，计算任务是放在子线程里面的，任务进度在主线程UI界面更新。</p><p>参考博客：</p><p>Huffman编码：</p><p><a href="https://blog.csdn.net/weixin_43690347/article/details/84146979">基于哈夫曼编码的压缩算法的Python实现_字节莫的CSDN博客-CSDN博客_python 哈夫曼压缩</a></p><p><a href="https://blog.csdn.net/cc815107613/article/details/103260408">Python中使用哈夫曼算法实现文件的压缩与解压缩_cc815107613的博客-CSDN博客_python基于哈夫曼编码的文件压缩及解压缩</a></p><p>Pyqt5多线程：</p><p><a href="https://blog.csdn.net/wuwei_201/article/details/104720386">pyqt5 的多线程（QThread）遇到的坑（一）_HHKJ 的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/wuwei_201/article/details/104803019">pyqt5 的多线程（QThread）遇到的坑（二）_HHKJ 的博客-CSDN博客_pyqt多线程闪退</a></p><p>Pyqt5刷新页面：</p><p><a href="https://blog.csdn.net/qq_34765552/article/details/78860540">pyqt5学习笔记——刷新页面_OneKey-CSDN博客_pyqt5 刷新界面</a></p><p>Pyqt5打包：</p><p><a href="https://blog.csdn.net/wn0112/article/details/47973953">[PyQt] 使用.qrc 生成资源文件供程序中使用_的专栏-CSDN博客_pyqt 编译qrc文件</a></p><p><a href="https://blog.csdn.net/gongjianbo1992/article/details/105361880">PyQt5，资源文件 .qrc 的使用_龚建波-CSDN博客_pyqt5 qrc</a></p><p>先上效果图：</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171715223.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171715348.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>压缩解压缩结果分析：<strong>结果与分析</strong></p><p>测试用样本</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171714057.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 压缩结果</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171714637.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>不同格式压缩率统计</p><div class="table-container"><table><thead><tr><th>文件格式</th><th>.mp3</th><th>.wav</th><th>.bmp</th><th>.jpg</th><th>.gif</th><th>.doc</th><th>.txt</th><th>.py</th></tr></thead><tbody><tr><td>压缩前/KB</td><td>10012</td><td>244</td><td>2026</td><td>227</td><td>1980</td><td>20</td><td>330</td><td>21</td></tr><tr><td>压缩后/KB</td><td>9998</td><td>205</td><td>1001</td><td>227</td><td>1965</td><td>14</td><td>241</td><td>14</td></tr><tr><td>压缩率</td><td>0.9986</td><td>0.8401</td><td>0.494</td><td>1</td><td>0.9924</td><td>0.7</td><td>0.7303</td><td>0.6667</td></tr></tbody></table></div><p>通过数据可以看到，文件多少有被压缩过；对于原始数据格式像bmp图片格式和wav音频格式这类格式，或者txt文本，压缩率是比较低的，效果较好。像mp3和jpg这类已经被高度压缩过的文件格式，数据冗余较少，可供压缩的空间不多。其中bmp格式图片压缩率明显低于其它，还有一个可能的原因是，该图像虽然体积大，但是属于像素风图像，颜色阶数较少，像素感很明显。</p><p>增大数据样本量进行统计</p><p> 平均压缩率</p><div class="table-container"><table><thead><tr><th>文件格式</th><th>.mp3</th><th>.wav</th><th>.bmp</th><th>.jpg</th><th>.txt</th></tr></thead><tbody><tr><td>平均压缩率</td><td>0.9986</td><td>0.8173</td><td>0.7768</td><td>1</td><td>0.7238</td></tr></tbody></table></div><p>但是，因为采用的是Huffman算法，压缩率与输入符号的概率分布有关，越是均匀分布的数据，冗余越少，压缩率越高，压缩效果自然不是很好，反而越是分布集中甚至单一的数据存在大量的数据冗余，压缩率理论上会比较低，压缩效果会更好。于是我选取了一些比较典型的图片，来验证我的想法。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171715817.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><br> 图片格式统一采用bmp格式，两张颜色分布均匀色彩丰富的图和两张颜色分布集中的图片，来看一下效果。</p><p>图 16压缩结果</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171715130.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>压缩结果统计</p><div class="table-container"><table><thead><tr><th></th><th>色彩丰富1.bmp</th><th>色彩丰富2.bmp</th><th>色彩集中1.bmp</th><th>色彩集中2.bmp</th></tr></thead><tbody><tr><td>压缩前/KB</td><td>5401</td><td>2002</td><td>2453</td><td>6751</td></tr><tr><td>压缩后/KB</td><td>5376</td><td>1964</td><td>2360</td><td>6425</td></tr><tr><td>压缩率</td><td>0.9953</td><td>0.981</td><td>0.962</td><td>0.9517</td></tr></tbody></table></div><p>可以看到，色彩丰富，数据分布较为均匀的图像压缩率高，压缩效果不好，色彩分布集中较为单一的图像，压缩率低，压缩效果好。此外，色彩集中2.bmp颜色比色彩集中1.bmp颜色更为单调，对应压缩率也更低，压缩效果更好。</p><p>代码由于注释比较多，就不啰嗦了。</p><p>Huffman编码部分：主要是参考大佬们的，最后用类封装了一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QThread, pyqtSignal, QObject</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)  <span class="comment"># 压缩大文件实时会出现超出递归深度，故修改限制</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span>, father=<span class="literal">None</span></span>):</span><br><span class="line">        self.value = value  <span class="comment"># 节点的权值</span></span><br><span class="line">        self.left = left  <span class="comment"># 左节点</span></span><br><span class="line">        self.right = right  <span class="comment"># 右节点</span></span><br><span class="line">        self.father = father  <span class="comment"># 父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_father</span>(<span class="params">left, right</span>):  <span class="comment"># 构造父节点</span></span><br><span class="line">        n = node(value=left.value + right.value, left=left, right=right)  <span class="comment"># 子节点权值相加</span></span><br><span class="line">        left.father = right.father = n</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">n</span>):  <span class="comment"># huffman编码，从下往上递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> n.father == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> n.father.left == n:</span><br><span class="line">            <span class="keyword">return</span> node.encode(n.father) + <span class="string">b&#x27;0&#x27;</span>  <span class="comment"># 左节点编码0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node.encode(n.father) + <span class="string">b&#x27;1&#x27;</span>  <span class="comment"># 右节点编码为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有继承了QObject类才可以使用信号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanEncoder</span>(QObject, <span class="built_in">object</span>):</span><br><span class="line">    progress = pyqtSignal(<span class="built_in">int</span>)  <span class="comment"># 发送进度信号，这个类可以向外发送当前进度值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, node_dict=<span class="literal">None</span>, count_dict=<span class="literal">None</span>, ec_dict=<span class="literal">None</span>, nodes=<span class="literal">None</span>, inverse_dict=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(HuffmanEncoder, self).__init__()</span><br><span class="line">        <span class="keyword">if</span> node_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            node_dict = &#123;&#125;</span><br><span class="line">            <span class="comment"># 存储节点的字典，key为读入的字节，value为对应的节点对象</span></span><br><span class="line">        <span class="keyword">if</span> count_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            count_dict = &#123;&#125;</span><br><span class="line">            <span class="comment"># 字符频率对应字典，key为读入的字节(字符)，value为该字节出现次数，为了解码重构哈夫曼树</span></span><br><span class="line">        <span class="keyword">if</span> ec_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            ec_dict = &#123;&#125;</span><br><span class="line">            <span class="comment"># 符号编码表 key:字节(符号),value:编码如b&#x27;1001000&#x27;，都是字符串</span></span><br><span class="line">        <span class="keyword">if</span> nodes <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            nodes = []</span><br><span class="line">            <span class="comment"># 存放节点的列表</span></span><br><span class="line">        <span class="keyword">if</span> inverse_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            inverse_dict = &#123;&#125;</span><br><span class="line">            <span class="comment"># 反向字典，key:编码 value:编码对应的字符</span></span><br><span class="line">        self.node_dict = node_dict</span><br><span class="line">        self.count_dict = count_dict</span><br><span class="line">        self.ec_dict = ec_dict</span><br><span class="line">        self.nodes = nodes</span><br><span class="line">        self.inverse_dict = inverse_dict</span><br><span class="line">        self.temp = <span class="number">0</span>  <span class="comment"># 当前进度，用于向外发送信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造哈夫曼树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_tree</span>(<span class="params">self, l</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">            <span class="comment"># 节点列表只剩一个根节点的时候，返回</span></span><br><span class="line">            <span class="comment"># 此时根节点连接了两个子节点，子节点又连接了孙节点，可以通过叶子节点递归遍历</span></span><br><span class="line">        sorts = <span class="built_in">sorted</span>(l, key=<span class="keyword">lambda</span> x: x.value, reverse=<span class="literal">False</span>)  <span class="comment"># 根据节点的权值进行排序</span></span><br><span class="line">        n = node.build_father(sorts[<span class="number">0</span>], sorts[<span class="number">1</span>])  <span class="comment"># 权值最小的两个节点，生成父节点</span></span><br><span class="line">        sorts.pop(<span class="number">0</span>)  <span class="comment"># 将节点列表里面节点权值最小的丢掉</span></span><br><span class="line">        sorts.pop(<span class="number">0</span>)  <span class="comment"># 继续把参与合并的第二个节点丢掉</span></span><br><span class="line">        sorts.append(n)  <span class="comment"># 把合并之后得到新权值的父节点，加入节点列表</span></span><br><span class="line">        <span class="keyword">return</span> self.build_tree(sorts)  <span class="comment"># 递归构造</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以看出，因为每次都是选择最小的两个节点，其中较小的那个节点做左节点，较大的做右节点</span></span><br><span class="line">    <span class="comment"># 所以编码结果是唯一的，与手工编码随机选取左右节点不同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当树构建好之后调用，根据每个叶子结点，从下往上编码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">self, echo</span>):</span><br><span class="line">        <span class="comment"># node_dict存储节点的字典，key为读入的字节，value为对应的节点对象</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.node_dict.keys():</span><br><span class="line">            <span class="comment"># ec_dict[x]符号编码表 key:字节(符号),value:编码如b&#x27;1001000&#x27;</span></span><br><span class="line">            self.ec_dict[x] = node.encode(self.node_dict[x])</span><br><span class="line">            <span class="keyword">if</span> echo:  <span class="comment"># 输出编码表（用于调试）</span></span><br><span class="line">                <span class="built_in">print</span>(x)</span><br><span class="line">                <span class="built_in">print</span>(self.ec_dict[x])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编码函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encodefile</span>(<span class="params">self, inputfile, outputfile</span>):</span><br><span class="line">        node_dict = self.node_dict</span><br><span class="line">        <span class="comment"># node_dict存储节点的字典，key为读入的字节，value为对应的节点对象</span></span><br><span class="line">        count_dict = self.count_dict</span><br><span class="line">        <span class="comment"># 字符频率对应字典，key为读入的字节(字符)，value为该字节出现次数，为了解码重构哈夫曼树</span></span><br><span class="line">        ec_dict = self.ec_dict</span><br><span class="line">        <span class="comment"># ec_dict[x]符号编码表 key:字节(符号),value:编码如b&#x27;1001000&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Starting encode...&quot;</span>)</span><br><span class="line">        f = <span class="built_in">open</span>(inputfile, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">        bytes_width = <span class="number">1</span>  <span class="comment"># 每次读取的字节宽度</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        f.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        count = f.tell() / bytes_width  <span class="comment"># 一共有多少个符号数</span></span><br><span class="line">        <span class="built_in">print</span>(count)</span><br><span class="line">        nodes = []  <span class="comment"># 结点列表，用于构建哈夫曼树</span></span><br><span class="line">        buff = [<span class="string">b&#x27;&#x27;</span>] * <span class="built_in">int</span>(count)  <span class="comment"># 初始化字节存储列表buff</span></span><br><span class="line">        f.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算字符频率,并将单个字符构建成单一节点</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; count:</span><br><span class="line">            buff[i] = f.read(bytes_width)  <span class="comment"># 每次读取bytes_width个字节</span></span><br><span class="line">            <span class="keyword">if</span> count_dict.get(buff[i], -<span class="number">1</span>) == -<span class="number">1</span>:</span><br><span class="line">                count_dict[buff[i]] = <span class="number">0</span>  <span class="comment"># key:buff[i] ，value:0</span></span><br><span class="line">            count_dict[buff[i]] = count_dict[buff[i]] + <span class="number">1</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Read OK&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(count_dict)  <span class="comment"># 输出权值字典,可注释掉</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> count_dict.keys():</span><br><span class="line">            node_dict[x] = node(count_dict[x])</span><br><span class="line">            <span class="comment"># 生成一个频率为count_dict[x]的节点，存入字典 node_dict[x]</span></span><br><span class="line">            nodes.append(node_dict[x])</span><br><span class="line">            <span class="comment"># 把这个节点加入节点列表</span></span><br><span class="line"></span><br><span class="line">        f.close()</span><br><span class="line">        tree = self.build_tree(nodes)  <span class="comment"># 哈夫曼树构建</span></span><br><span class="line">        self.encode(<span class="literal">False</span>)  <span class="comment"># 构建编码表</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Encode OK&quot;</span>)</span><br><span class="line">        <span class="comment"># sorted_nodes是被排过序的节点列表[(key1,value1),(key2,value2)...]</span></span><br><span class="line">        <span class="comment"># 每个元素是一个元组(key,value)，其中key是对应的字符(字节),value是该字符出现的频率</span></span><br><span class="line">        sorted_nodes = <span class="built_in">sorted</span>(count_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 对所有根节点进行排序，找出频率最高的节点</span></span><br><span class="line">        bit_width = <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;head:&quot;</span>, sorted_nodes[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 动态调整编码表的字节长度，优化文件头大小，sorted_nodes[0][1]即value1，最大的频率值</span></span><br><span class="line">        <span class="comment"># 计算存储最大频率值需要的字节数</span></span><br><span class="line">        <span class="keyword">if</span> sorted_nodes[<span class="number">0</span>][<span class="number">1</span>] &gt; <span class="number">255</span>:</span><br><span class="line">            bit_width = <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> sorted_nodes[<span class="number">0</span>][<span class="number">1</span>] &gt; <span class="number">65535</span>:</span><br><span class="line">                bit_width = <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> sorted_nodes[<span class="number">0</span>][<span class="number">1</span>] &gt; <span class="number">16777215</span>:</span><br><span class="line">                    bit_width = <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bit_width:&quot;</span>, bit_width)</span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 计数变量，用于遍历所有字节</span></span><br><span class="line">        byte_written = <span class="number">0b1</span></span><br><span class="line">        <span class="comment"># 初始化为1占位，移位运算调用bit_length判断当前长度，这个变量是要被写入硬盘的</span></span><br><span class="line"></span><br><span class="line">        o = <span class="built_in">open</span>(outputfile, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        name = inputfile.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        o.write((name[<span class="built_in">len</span>(name) - <span class="number">1</span>] + <span class="string">&#x27;\n&#x27;</span>).encode(encoding=<span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># 写出原文件名</span></span><br><span class="line">        o.write(<span class="built_in">int</span>.to_bytes(<span class="built_in">len</span>(ec_dict), <span class="number">2</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))  </span><br><span class="line">        <span class="comment"># 写出不同符号种类数，即叶子结点总数</span></span><br><span class="line">        o.write(<span class="built_in">int</span>.to_bytes(bit_width, <span class="number">1</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))  <span class="comment"># 写出编码表字节宽度</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> ec_dict.keys():  <span class="comment"># 编码文件头</span></span><br><span class="line">            o.write(x)  <span class="comment"># 写入符号</span></span><br><span class="line">            o.write(<span class="built_in">int</span>.to_bytes(count_dict[x], bit_width, byteorder=<span class="string">&#x27;big&#x27;</span>)) </span><br><span class="line">            <span class="comment"># 写入符号对应频率</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;head OK&#x27;</span>)</span><br><span class="line">        <span class="comment"># 注意是按字节写入</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; count:  <span class="comment"># 开始压缩数据,一个一个字节遍历，将编码结果写入</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> ec_dict[buff[i]]:</span><br><span class="line">                <span class="comment"># buff[i]是一个符号(字节)</span></span><br><span class="line">           <span class="comment">#作为key从编码字典ec_dict[buff[i]]取出一个编码b&#x27;1100...111000..&#x27;，类型是字符串</span></span><br><span class="line">                byte_written = byte_written &lt;&lt; <span class="number">1</span>  <span class="comment"># 右移腾出空位</span></span><br><span class="line">                <span class="keyword">if</span> x == <span class="number">49</span>:  <span class="comment"># 如果，x当前是&#x27;1&#x27;，那就将byte_written最后一位置1</span></span><br><span class="line">                    byte_written = byte_written | <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> byte_written.bit_length() == <span class="number">9</span>:</span><br><span class="line">                    <span class="comment"># 一个字节有8位，9位包含了第一位是1的那个占位符</span></span><br><span class="line">                    <span class="comment">#因为bit_length只从第一个非0位算起</span></span><br><span class="line">                    byte_written = byte_written &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>))  <span class="comment"># 取出一个字节，即低8位</span></span><br><span class="line">                    o.write(<span class="built_in">int</span>.to_bytes(byte_written, <span class="number">1</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">                    o.flush()  <span class="comment"># 立即写入，更新缓冲区</span></span><br><span class="line">                    byte_written = <span class="number">0b1</span>  <span class="comment"># 置1复位</span></span><br><span class="line">            tem = <span class="built_in">int</span>(i / <span class="built_in">len</span>(buff) * <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">if</span> tem &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> tem - self.temp &gt;= <span class="number">1</span>:  <span class="comment"># 防止频繁发送信号阻塞主线程UI</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;encode:&quot;</span>, tem, <span class="string">&#x27;%&#x27;</span>)  <span class="comment"># 输出压缩进度</span></span><br><span class="line">                    <span class="keyword">if</span> tem &gt; <span class="number">95</span>:</span><br><span class="line">                        self.temp = <span class="number">100</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.temp = tem</span><br><span class="line">                    self.progress.emit(self.temp)  <span class="comment"># 发送当前进度</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> byte_written.bit_length() &gt; <span class="number">1</span>:  <span class="comment"># 处理文件尾部不足一个字节的数据</span></span><br><span class="line">            byte_written = byte_written &lt;&lt; (<span class="number">8</span> - (byte_written.bit_length() - <span class="number">1</span>))</span><br><span class="line">            byte_written = byte_written &amp; (~(<span class="number">1</span> &lt;&lt; byte_written.bit_length() - <span class="number">1</span>))</span><br><span class="line">            o.write(<span class="built_in">int</span>.to_bytes(byte_written, <span class="number">1</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">        o.close()</span><br><span class="line">        self.node_dict = node_dict</span><br><span class="line">        self.count_dict = count_dict</span><br><span class="line">        self.ec_dict = ec_dict</span><br><span class="line">        self.nodes = nodes</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;File encode successful.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodefile</span>(<span class="params">self, inputfile, outputfile</span>):</span><br><span class="line">        node_dict = self.node_dict</span><br><span class="line">        <span class="comment"># node_dict存储节点的字典，key为读入的字节，value为对应的节点对象</span></span><br><span class="line">        ec_dict = self.ec_dict</span><br><span class="line">        <span class="comment"># 字符频率对应字典，key为读入的字节(字符)，value为该字节出现次数，为了解码重构哈夫曼树</span></span><br><span class="line">        inverse_dict = self.inverse_dict</span><br><span class="line">        <span class="comment"># 反向字典，key:编码 value:编码对应的字符</span></span><br><span class="line">        nodes = self.nodes  <span class="comment"># 存放节点的列表</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Starting decode...&quot;</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        byte_written = <span class="number">0</span></span><br><span class="line">        f = <span class="built_in">open</span>(inputfile, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        f.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        eof = f.tell()  <span class="comment"># 获取文件末尾位置</span></span><br><span class="line">        f.seek(<span class="number">0</span>)</span><br><span class="line">        outputfile = (outputfile + f.readline().decode(encoding=<span class="string">&quot;utf-8&quot;</span>)).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="comment"># 文件保存路径和文件名结合生成文件指针</span></span><br><span class="line">        o = <span class="built_in">open</span>(outputfile, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        count = <span class="built_in">int</span>.from_bytes(f.read(<span class="number">2</span>), byteorder=<span class="string">&#x27;big&#x27;</span>)  </span><br><span class="line">        <span class="comment"># 取出叶子结点数量，也就是不同符号种类数</span></span><br><span class="line">        bit_width = <span class="built_in">int</span>.from_bytes(f.read(<span class="number">1</span>), byteorder=<span class="string">&#x27;big&#x27;</span>)  <span class="comment"># 取出编码表字宽</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        de_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> i &lt; count:  <span class="comment"># 解析文件头</span></span><br><span class="line">            key = f.read(<span class="number">1</span>)  <span class="comment"># 取出符号</span></span><br><span class="line">            value = <span class="built_in">int</span>.from_bytes(f.read(bit_width), byteorder=<span class="string">&#x27;big&#x27;</span>)  <span class="comment"># 取出符号对应频率</span></span><br><span class="line">            de_dict[key] = value  <span class="comment"># 建立符号频率表 key:符号 value:该符号出现次数</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> de_dict.keys():</span><br><span class="line">            node_dict[x] = node(de_dict[x])</span><br><span class="line">            nodes.append(node_dict[x])</span><br><span class="line">        tree = self.build_tree(nodes)  <span class="comment"># 重建哈夫曼树</span></span><br><span class="line">        self.encode(<span class="literal">False</span>)  <span class="comment"># 建立编码表，此时产生 self.ec_dict编码字典，key:符号，value:b&#x27;010101....1010..&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> ec_dict.keys():  <span class="comment"># 反向字典构建</span></span><br><span class="line">            inverse_dict[ec_dict[x]] = x  <span class="comment"># key和value对调,key:是编码b&#x27;010101....1010..&#x27;,value:是x即符号，8位</span></span><br><span class="line">        i = f.tell()  <span class="comment"># 获取当前指针位置</span></span><br><span class="line">        data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; eof:  <span class="comment"># 开始解压数据</span></span><br><span class="line">            byte_written = <span class="built_in">int</span>.from_bytes(f.read(<span class="number">1</span>), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">            <span class="comment"># print(&quot;byte_written:&quot;,byte_written)</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            j = <span class="number">8</span>  <span class="comment"># 一个字节八位</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (byte_written &gt;&gt; (j - <span class="number">1</span>)) &amp; <span class="number">1</span> == <span class="number">1</span>:  <span class="comment"># 取最高位判断</span></span><br><span class="line">                    data = data + <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">                    byte_written = byte_written &amp; (~(<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) </span><br><span class="line">                    <span class="comment"># 去掉最高位，保留剩下几位</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    data = data + <span class="string">b&#x27;0&#x27;</span></span><br><span class="line">                    byte_written = byte_written &amp; (~(<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))</span><br><span class="line">                <span class="keyword">if</span> inverse_dict.get(data, <span class="number">0</span>) != <span class="number">0</span>: </span><br><span class="line">                    <span class="comment"># key:是编码b&#x27;010101....1010..&#x27;,value:是x即符号，8位</span></span><br><span class="line">                    o.write(inverse_dict[data])</span><br><span class="line">                    o.flush()</span><br><span class="line">                    <span class="comment"># print(&quot;decode&quot;,data,&quot;:&quot;,inverse_dict[data])</span></span><br><span class="line">                    data = <span class="string">b&#x27;&#x27;</span>  </span><br><span class="line">             <span class="comment"># 如果匹配到了就清零，如果没有就不清零，比如码长大于8，不会清零会继续变长直到匹配</span></span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">            tem = <span class="built_in">int</span>(i / eof * <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">if</span> tem &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> tem - self.temp &gt;= <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;decode:&quot;</span>, tem, <span class="string">&#x27;%&#x27;</span>)  <span class="comment"># 输出解压进度</span></span><br><span class="line">                    <span class="keyword">if</span> tem &gt; <span class="number">95</span>:</span><br><span class="line">                        self.temp = <span class="number">100</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.temp = tem</span><br><span class="line">                    self.progress.emit(self.temp)</span><br><span class="line">            byte_written = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        f.close()</span><br><span class="line">        o.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;File decode successful.&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>UI部分：这里比较繁琐，不需要的不要也行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtGui, QtWidgets</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> (Qt, pyqtSignal, pyqtSlot, QThread, QTimer)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> (QMovie, QIcon, QCursor)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QApplication, QVBoxLayout, QLabel,</span><br><span class="line">                             QTabWidget, QPushButton, QHBoxLayout, QPlainTextEdit,</span><br><span class="line">                             QFileDialog, QDesktopWidget, QDialog, QProgressBar)</span><br><span class="line"><span class="keyword">import</span> images_rc  <span class="comment"># 加载图片资源文件</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> huffman</span><br><span class="line"><span class="keyword">from</span> huffman <span class="keyword">import</span> HuffmanEncoder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ui_MainWindow</span>(<span class="title class_ inherited__">QTabWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Ui_MainWindow, self).__init__(parent)</span><br><span class="line">        self.setupUi()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setupUi</span>(<span class="params">self</span>):</span><br><span class="line">        self.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">550</span>, <span class="number">550</span>)</span><br><span class="line">        self.setFixedSize(<span class="number">550</span>, <span class="number">550</span>)</span><br><span class="line">        self.tab1 = QWidget()</span><br><span class="line">        self.tab2 = QWidget()</span><br><span class="line">        self.addTab(self.tab1, <span class="string">&#x27;压缩&#x27;</span>)</span><br><span class="line">        self.addTab(self.tab2, <span class="string">&#x27;解压&#x27;</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;Huffman压缩-解压&#x27;</span>)</span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">&#x27;:/image/bird.ico&#x27;</span>))</span><br><span class="line">        self.loadpath = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 导入文件路径</span></span><br><span class="line">        <span class="comment"># 控件样式定义</span></span><br><span class="line">        self.style = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                    #btn_code&#123;</span></span><br><span class="line"><span class="string">                        border-radius: 4px;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/code.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_code:Pressed&#123;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/code_press.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">                    #btn_select_file1&#123;</span></span><br><span class="line"><span class="string">                        border-radius: 4px;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/sele_file.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_select_file1:Pressed&#123;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/sele_file_press.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_select_file2&#123;</span></span><br><span class="line"><span class="string">                        border-radius: 4px;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/sele_file.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_select_file2:Pressed&#123;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/sele_file_press.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_decode&#123;</span></span><br><span class="line"><span class="string">                                border-radius: 4px;</span></span><br><span class="line"><span class="string">                                border-image: url(&#x27;:/image/decode.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_decode:Pressed&#123;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/decode_press.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;  </span></span><br><span class="line"><span class="string">                    #dir_edit1&#123;</span></span><br><span class="line"><span class="string">                        background-color: rgba(255, 255, 255, 0);</span></span><br><span class="line"><span class="string">                        font-family:微软雅黑;</span></span><br><span class="line"><span class="string">                        font-size:14px</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #dir_edit2&#123;</span></span><br><span class="line"><span class="string">                        background-color: rgba(255, 255, 255, 0);</span></span><br><span class="line"><span class="string">                        font-family:微软雅黑;</span></span><br><span class="line"><span class="string">                        font-size:14px</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_change_dir1&#123;</span></span><br><span class="line"><span class="string">                        border-radius: 4px;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/change_dir.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_change_dir1:Pressed&#123;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/change_dir_press.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_change_dir2&#123;</span></span><br><span class="line"><span class="string">                        border-radius: 4px;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/change_dir.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    #btn_change_dir2:Pressed&#123;</span></span><br><span class="line"><span class="string">                        border-image: url(&#x27;:/image/change_dir_press.png&#x27;);</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.tab1UI()  <span class="comment"># 压缩标签页初始化</span></span><br><span class="line">        self.tab2UI()  <span class="comment"># 解压标签页初始化</span></span><br><span class="line">        self.center()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">center</span>(<span class="params">self</span>):  <span class="comment"># 窗口居中函数</span></span><br><span class="line">        screen = QDesktopWidget().screenGeometry()</span><br><span class="line">        size = self.geometry()</span><br><span class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>,</span><br><span class="line">                  (screen.height() - size.height()) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tab1UI</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 动态背景</span></span><br><span class="line">        self.gif = QMovie(<span class="string">&#x27;:/image/bgi.gif&#x27;</span>)</span><br><span class="line">        label = QLabel(self.tab1)</span><br><span class="line">        label.setMovie(self.gif)</span><br><span class="line">        label.setFixedSize(<span class="number">550</span>, <span class="number">550</span>)</span><br><span class="line">        label.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 标题</span></span><br><span class="line">        label_title = QLabel(self.tab1)</span><br><span class="line">        label_title.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">50</span>)</span><br><span class="line">        label_title.setPixmap(QtGui.QPixmap(<span class="string">&#x27;:/image/title.png&#x27;</span>))</span><br><span class="line">        label_title.setScaledContents(<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 开始压缩按钮</span></span><br><span class="line">        btn_code = QPushButton(self.tab1)</span><br><span class="line">        btn_code.setGeometry(<span class="number">350</span>, <span class="number">420</span>, <span class="number">170</span>, <span class="number">55</span>)</span><br><span class="line">        btn_code.setObjectName(<span class="string">&#x27;btn_code&#x27;</span>)</span><br><span class="line">        btn_code.setStyleSheet(self.style)</span><br><span class="line">        btn_code.setCursor(QCursor(Qt.PointingHandCursor))</span><br><span class="line">        btn_code.clicked.connect(self.start_coding)  <span class="comment"># 连接槽函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 操作区域布局</span></span><br><span class="line">        menu_layout = QVBoxLayout()</span><br><span class="line">        <span class="comment"># 选择文件按钮</span></span><br><span class="line">        select_file_layout = QHBoxLayout()</span><br><span class="line">        btn_select_file1 = QPushButton()</span><br><span class="line">        btn_select_file1.setObjectName(<span class="string">&#x27;btn_select_file1&#x27;</span>)</span><br><span class="line">        btn_select_file1.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">120</span>, <span class="number">35</span>)</span><br><span class="line">        btn_select_file1.setFixedSize(<span class="number">120</span>, <span class="number">35</span>)</span><br><span class="line">        btn_select_file1.setStyleSheet(self.style)</span><br><span class="line">        btn_select_file1.setCursor(QCursor(Qt.PointingHandCursor))</span><br><span class="line">        btn_select_file1.clicked.connect(self.select_file)</span><br><span class="line"></span><br><span class="line">        label_filename = QLabel(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">        label_filename.setObjectName(<span class="string">&#x27;label_filename&#x27;</span>)</span><br><span class="line">        label_filename.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">120</span>, <span class="number">35</span>)</span><br><span class="line">        label_filename.setFixedHeight(<span class="number">35</span>)</span><br><span class="line">        select_file_layout.addWidget(btn_select_file1)</span><br><span class="line">        select_file_layout.addWidget(label_filename, Qt.AlignRight)</span><br><span class="line">        select_file_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        self.label_filename1 = label_filename  <span class="comment"># 为了回调函数调用存在类变量里面</span></span><br><span class="line">        <span class="comment"># 载入文件子布局</span></span><br><span class="line">        load_file_layout = QHBoxLayout()</span><br><span class="line">        <span class="comment"># “压缩到“子控件</span></span><br><span class="line">        dir_to_code = QLabel()</span><br><span class="line">        dir_to_code.setFixedSize(<span class="number">95</span>, <span class="number">35</span>)</span><br><span class="line">        dir_to_code.setPixmap(QtGui.QPixmap(<span class="string">&#x27;:/image/code_to_dir.png&#x27;</span>))</span><br><span class="line">        dir_to_code.setScaledContents(<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># ”输入路径“子控件</span></span><br><span class="line">        dir_edit1 = QPlainTextEdit()</span><br><span class="line">        dir_edit1.setObjectName(<span class="string">&#x27;dir_edit1&#x27;</span>)</span><br><span class="line">        dir_edit1.setFixedHeight(<span class="number">35</span>)</span><br><span class="line">        dir_edit1.setObjectName(<span class="string">&#x27;dir_edit1&#x27;</span>)</span><br><span class="line">        dir_edit1.setStyleSheet(self.style)</span><br><span class="line">        self.dir_edit1 = dir_edit1</span><br><span class="line">        <span class="comment"># &quot;更改路径&quot;子控件</span></span><br><span class="line">        btn_change_dir1 = QPushButton()</span><br><span class="line">        btn_change_dir1.setObjectName(<span class="string">&#x27;btn_change_dir1&#x27;</span>)</span><br><span class="line">        btn_change_dir1.setFixedSize(<span class="number">120</span>, <span class="number">35</span>)</span><br><span class="line">        btn_change_dir1.setStyleSheet(self.style)</span><br><span class="line">        btn_change_dir1.setCursor(QCursor(Qt.PointingHandCursor))</span><br><span class="line">        btn_change_dir1.clicked.connect(self.change_directory)</span><br><span class="line">        self.btn_change_dir1 = btn_change_dir1</span><br><span class="line">        <span class="comment"># 子控件加入子布局(水平布局)</span></span><br><span class="line">        load_file_layout.addWidget(dir_to_code)</span><br><span class="line">        load_file_layout.addWidget(dir_edit1)</span><br><span class="line">        load_file_layout.addWidget(btn_change_dir1)</span><br><span class="line">        load_file_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        <span class="comment"># 选择文件按钮布局</span></span><br><span class="line">        choose_file = QWidget()</span><br><span class="line">        choose_file.setGeometry(<span class="number">0</span>, <span class="number">35</span>, <span class="number">200</span>, <span class="number">35</span>)</span><br><span class="line">        choose_file.setFixedSize(<span class="number">200</span>, <span class="number">35</span>)</span><br><span class="line">        choose_file.setLayout(select_file_layout)</span><br><span class="line">        <span class="comment"># 子布局和load_file子控件结合</span></span><br><span class="line">        load_file = QWidget()</span><br><span class="line">        load_file.setGeometry(<span class="number">0</span>, <span class="number">35</span>, <span class="number">540</span>, <span class="number">35</span>)</span><br><span class="line">        load_file.setFixedSize(<span class="number">540</span>, <span class="number">35</span>)</span><br><span class="line">        load_file.setLayout(load_file_layout)</span><br><span class="line">        <span class="comment"># 子控件载入布局</span></span><br><span class="line">        menu_layout.addWidget(choose_file)</span><br><span class="line">        menu_layout.addWidget(load_file)</span><br><span class="line">        <span class="comment"># 纵向控件，包含选择文件按钮和路径输入框等</span></span><br><span class="line">        menu = QWidget(self.tab1)</span><br><span class="line">        menu.setGeometry(-<span class="number">10</span>, <span class="number">50</span>, <span class="number">540</span>, <span class="number">100</span>)</span><br><span class="line">        menu.setFixedSize(<span class="number">540</span>, <span class="number">100</span>)</span><br><span class="line">        menu.setLayout(menu_layout)</span><br><span class="line">        self.gif.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tab2UI</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 动态背景</span></span><br><span class="line">        self.gif = QMovie(<span class="string">&#x27;:/image/bgi3.gif&#x27;</span>)</span><br><span class="line">        label = QLabel(self.tab2)</span><br><span class="line">        label.setMovie(self.gif)</span><br><span class="line">        label.setFixedSize(<span class="number">550</span>, <span class="number">550</span>)</span><br><span class="line">        label.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 标题</span></span><br><span class="line">        label_title = QLabel(self.tab2)</span><br><span class="line">        label_title.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">50</span>)</span><br><span class="line">        label_title.setPixmap(QtGui.QPixmap(<span class="string">&#x27;:/image/title2.png&#x27;</span>))</span><br><span class="line">        label_title.setScaledContents(<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 开始解压缩按钮</span></span><br><span class="line">        btn_decode = QPushButton(self.tab2)</span><br><span class="line">        btn_decode.setGeometry(<span class="number">350</span>, <span class="number">420</span>, <span class="number">170</span>, <span class="number">55</span>)</span><br><span class="line">        btn_decode.setObjectName(<span class="string">&#x27;btn_decode&#x27;</span>)</span><br><span class="line">        btn_decode.setStyleSheet(self.style)</span><br><span class="line">        btn_decode.setCursor(QCursor(Qt.PointingHandCursor))</span><br><span class="line">        btn_decode.clicked.connect(self.start_decoding)  <span class="comment"># 解压按钮的信号连接到解压按钮的槽函数</span></span><br><span class="line">        <span class="comment"># 操作区域布局</span></span><br><span class="line">        menu_layout = QVBoxLayout()</span><br><span class="line">        <span class="comment"># 选择文件按钮</span></span><br><span class="line">        select_file_layout = QHBoxLayout()</span><br><span class="line">        btn_select_file2 = QPushButton()</span><br><span class="line">        btn_select_file2.setObjectName(<span class="string">&#x27;btn_select_file2&#x27;</span>)</span><br><span class="line">        btn_select_file2.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">120</span>, <span class="number">35</span>)</span><br><span class="line">        btn_select_file2.setFixedSize(<span class="number">120</span>, <span class="number">35</span>)</span><br><span class="line">        btn_select_file2.setStyleSheet(self.style)</span><br><span class="line">        btn_select_file2.setCursor(QCursor(Qt.PointingHandCursor))</span><br><span class="line">        btn_select_file2.clicked.connect(self.select_file)  <span class="comment"># 选择文件信号连接到选择文件槽函数</span></span><br><span class="line"></span><br><span class="line">        label_filename = QLabel(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">        label_filename.setObjectName(<span class="string">&#x27;label_filename&#x27;</span>)</span><br><span class="line">        label_filename.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">120</span>, <span class="number">35</span>)</span><br><span class="line">        label_filename.setFixedHeight(<span class="number">35</span>)</span><br><span class="line">        select_file_layout.addWidget(btn_select_file2)</span><br><span class="line">        select_file_layout.addWidget(label_filename, Qt.AlignRight)</span><br><span class="line">        select_file_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        self.label_filename2 = label_filename</span><br><span class="line">        <span class="comment"># 载入文件子布局</span></span><br><span class="line">        load_file_layout = QHBoxLayout()</span><br><span class="line">        <span class="comment"># “解压缩到“子控件</span></span><br><span class="line">        dir_to_decode = QLabel()</span><br><span class="line">        dir_to_decode.setFixedSize(<span class="number">95</span>, <span class="number">35</span>)</span><br><span class="line">        dir_to_decode.setPixmap(QtGui.QPixmap(<span class="string">&#x27;:/image/decode_to_dir.png&#x27;</span>))</span><br><span class="line">        dir_to_decode.setScaledContents(<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># ”输入路径“子控件</span></span><br><span class="line">        dir_edit2 = QPlainTextEdit()</span><br><span class="line">        dir_edit2.setFixedHeight(<span class="number">35</span>)</span><br><span class="line">        dir_edit2.setObjectName(<span class="string">&#x27;dir_edit2&#x27;</span>)</span><br><span class="line">        dir_edit2.setStyleSheet(self.style)</span><br><span class="line">        self.dir_edit2 = dir_edit2</span><br><span class="line">        <span class="comment"># &quot;更改路径&quot;子控件</span></span><br><span class="line">        btn_change_dir2 = QPushButton()</span><br><span class="line">        btn_change_dir2.setObjectName(<span class="string">&#x27;btn_change_dir2&#x27;</span>)</span><br><span class="line">        btn_change_dir2.setFixedSize(<span class="number">120</span>, <span class="number">35</span>)</span><br><span class="line">        btn_change_dir2.setStyleSheet(self.style)</span><br><span class="line">        btn_change_dir2.setCursor(QCursor(Qt.PointingHandCursor))</span><br><span class="line">        btn_change_dir2.clicked.connect(self.change_directory)  <span class="comment"># 更换目录按钮的信号连接到更换目录的槽函数</span></span><br><span class="line">        self.btn_change_dir2 = btn_change_dir2</span><br><span class="line">        <span class="comment"># 子控件加入子布局(水平布局)</span></span><br><span class="line">        load_file_layout.addWidget(dir_to_decode)</span><br><span class="line">        load_file_layout.addWidget(dir_edit2)</span><br><span class="line">        load_file_layout.addWidget(btn_change_dir2)</span><br><span class="line">        load_file_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        <span class="comment"># 子布局和load_file子控件结合</span></span><br><span class="line">        load_file = QWidget()</span><br><span class="line">        load_file.setGeometry(<span class="number">0</span>, <span class="number">35</span>, <span class="number">540</span>, <span class="number">35</span>)</span><br><span class="line">        load_file.setFixedSize(<span class="number">540</span>, <span class="number">35</span>)</span><br><span class="line">        load_file.setLayout(load_file_layout)</span><br><span class="line">        <span class="comment"># 选择文件按钮布局</span></span><br><span class="line">        choose_file = QWidget()</span><br><span class="line">        choose_file.setGeometry(<span class="number">0</span>, <span class="number">35</span>, <span class="number">200</span>, <span class="number">35</span>)</span><br><span class="line">        choose_file.setFixedSize(<span class="number">200</span>, <span class="number">35</span>)</span><br><span class="line">        choose_file.setLayout(select_file_layout)</span><br><span class="line">        <span class="comment"># 子控件载入布局</span></span><br><span class="line">        menu_layout.addWidget(choose_file)</span><br><span class="line">        menu_layout.addWidget(load_file)</span><br><span class="line">        <span class="comment"># 纵向控件，包含选择文件按钮和路径输入框等</span></span><br><span class="line">        menu = QWidget(self.tab2)</span><br><span class="line">        menu.setGeometry(-<span class="number">10</span>, <span class="number">50</span>, <span class="number">540</span>, <span class="number">100</span>)</span><br><span class="line">        menu.setFixedSize(<span class="number">540</span>, <span class="number">100</span>)</span><br><span class="line">        menu.setLayout(menu_layout)</span><br><span class="line">        self.gif.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始压缩按钮回调</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_coding</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(</span><br><span class="line">                self.dir_edit1.toPlainText().replace(</span><br><span class="line">                    self.label_filename1.text().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;.huf&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        ):</span><br><span class="line">            self.notify = Notification(message=<span class="literal">True</span>)  <span class="comment"># 提示路径错误</span></span><br><span class="line">            self.notify.show()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.notify = Notification()  <span class="comment"># 加载进度提示窗口</span></span><br><span class="line">            self.notify.show()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;开始压缩&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(self.dir_edit1.toPlainText())  <span class="comment"># 打印路径</span></span><br><span class="line">            <span class="built_in">print</span>(self.label_filename1.text())  <span class="comment"># 打印文件名，调试用</span></span><br><span class="line">            filepath = self.dir_edit1.toPlainText().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;.huf&#x27;</span>  <span class="comment"># 提取保存路径</span></span><br><span class="line">            self.mythread = encode_thread(self.loadpath, filepath)  <span class="comment"># 子线程对象实例化，默认是压缩</span></span><br><span class="line">            self.mythread.update_progress.connect(self.update_progress)  <span class="comment"># 子线程进度更新信号连接槽函数</span></span><br><span class="line">            self.mythread.finished.connect(self.notice_finished)  <span class="comment"># 子线程任务完成信号连接槽函数</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.mythread.start()  <span class="comment"># 开启子线程，进行压缩</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.notify = Notification(message=<span class="literal">True</span>)</span><br><span class="line">                self.notify.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_progress</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is amazing:&quot;</span>, value, <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        self.notify.setProgress(value)  <span class="comment"># 更新进度条值</span></span><br><span class="line">        QApplication.processEvents()  <span class="comment"># 立即刷新</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notice_finished</span>(<span class="params">self</span>):</span><br><span class="line">        self.notify.close()  <span class="comment"># 任务完成把进度加载界面关闭</span></span><br><span class="line">        self.notify = Notification(message=<span class="literal">True</span>, text=<span class="string">&#x27;任务完成！！&#x27;</span>)  <span class="comment"># 出现任务完成提示框</span></span><br><span class="line">        self.notify.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启解压回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_decoding</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(self.dir_edit2.toPlainText()):</span><br><span class="line">            self.notify = Notification(message=<span class="literal">True</span>)</span><br><span class="line">            self.notify.show()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.notify = Notification()</span><br><span class="line">            self.notify.show()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;开始解压&#x27;</span>)</span><br><span class="line">            filepath = self.dir_edit2.toPlainText()</span><br><span class="line">            self.mythread = encode_thread(self.loadpath, filepath, ena_decode=<span class="literal">True</span>)  <span class="comment"># 使能解压功能</span></span><br><span class="line">            self.mythread.update_progress.connect(self.update_progress)  <span class="comment"># 连接进度更新槽函数</span></span><br><span class="line">            self.mythread.finished.connect(self.notice_finished)  <span class="comment"># 任务完成信号连接槽函数</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.mythread.start()  <span class="comment"># 开始解压</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.notify = Notification(message=<span class="literal">True</span>)</span><br><span class="line">                self.notify.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更换目录函数回调</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change_directory</span>(<span class="params">self</span>):</span><br><span class="line">        sender = self.sender()  <span class="comment"># h获取信号发总者对象</span></span><br><span class="line">        savepath = QFileDialog.getExistingDirectory(self, <span class="string">&#x27;选择路径&#x27;</span>, <span class="string">&#x27;.&#x27;</span>)  <span class="comment"># 获取路径选择框输入的路径</span></span><br><span class="line">        <span class="keyword">if</span> savepath == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\n取消选择&#x27;</span>)  <span class="comment"># 选择为空直接退出</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> sender.objectName() == <span class="string">&#x27;btn_change_dir1&#x27;</span>:  <span class="comment"># 如果来自按钮1，也就是压缩页面的信号</span></span><br><span class="line">            filename1 = self.label_filename1.text().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 获取相应文件名</span></span><br><span class="line">            <span class="keyword">if</span> filename1 == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                filename1 = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">            self.dir_edit1.setPlainText(savepath + <span class="string">&#x27;/&#x27;</span> + filename1 + <span class="string">&#x27;.huf&#x27;</span>)  <span class="comment"># 生成压缩后的保存路径，并显示</span></span><br><span class="line">        <span class="keyword">elif</span> sender.objectName() == <span class="string">&#x27;btn_change_dir2&#x27;</span>:  <span class="comment"># 如果是来自解压页面，直接生成保存路径，并显示</span></span><br><span class="line">            self.dir_edit2.setPlainText(savepath)</span><br><span class="line">        <span class="built_in">print</span>(savepath)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;更改目录&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择文件函数回调</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">select_file</span>(<span class="params">self</span>):</span><br><span class="line">        sender = self.sender()  <span class="comment"># 获取发送者对象</span></span><br><span class="line">        filepath, _ = QFileDialog.getOpenFileName(self, <span class="string">&#x27;选择文件&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;All Files(*);;Text Files(*.txt)&#x27;</span>)</span><br><span class="line">        self.loadpath = filepath  <span class="comment"># 保存文件读取路径</span></span><br><span class="line">        <span class="keyword">if</span> filepath == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\n取消选择&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        [filename, filetype] = (filepath.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]).split(<span class="string">&#x27;.&#x27;</span>)  <span class="comment"># 获得文件名和文件类型</span></span><br><span class="line">        savepath = (filepath.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]).replace(filename, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># 默认原文件所在文件路径作为保存路径</span></span><br><span class="line">        <span class="keyword">if</span> sender.objectName() == <span class="string">&#x27;btn_select_file1&#x27;</span>:  <span class="comment"># 来自页面1，也就是压缩</span></span><br><span class="line">            self.label_filename1.setText(filename + <span class="string">&#x27;.&#x27;</span> + filetype)  <span class="comment"># 显示文件名</span></span><br><span class="line">            self.dir_edit1.setPlainText(filepath.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;.huf&#x27;</span>)  <span class="comment"># 设置保存路径，并显示</span></span><br><span class="line">        <span class="keyword">elif</span> sender.objectName() == <span class="string">&#x27;btn_select_file2&#x27;</span>:</span><br><span class="line">            self.label_filename2.setText(filename + <span class="string">&#x27;.&#x27;</span> + filetype)</span><br><span class="line">            self.dir_edit2.setPlainText(savepath)</span><br><span class="line">        <span class="comment"># print(filepath)</span></span><br><span class="line">        <span class="comment"># print(filename)</span></span><br><span class="line">        <span class="comment"># print(filetype)</span></span><br><span class="line">        <span class="comment"># print(&#x27;选择文件&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示框对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Notification</span>(<span class="title class_ inherited__">QDialog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, message=<span class="literal">False</span>, text=<span class="string">&#x27;文件或路径错误！&#x27;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Notification, self).__init__()  <span class="comment"># message参数控制是进度加载提示框还是单纯的文本提示框，text用于设置文本提示框的内容</span></span><br><span class="line">        self.message = message</span><br><span class="line">        <span class="keyword">if</span> message:  <span class="comment"># 如果是文本提示框</span></span><br><span class="line">            self.setupUi_message(text)  <span class="comment"># 进行文本提示框的初始化</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.setupUi()  <span class="comment"># 进行进度加载提示框的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setupUi</span>(<span class="params">self</span>):  <span class="comment"># 进度加载提示框初始化</span></span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;正在努力工作...&#x27;</span>)</span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">&#x27;:/image/flower.ico&#x27;</span>))</span><br><span class="line">        self.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">        self.setFixedSize(<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">        self.gif = QMovie(<span class="string">&#x27;:/image/bgi2.gif&#x27;</span>)</span><br><span class="line">        label = QLabel(self)  <span class="comment"># 动图进度加载</span></span><br><span class="line">        label.setMovie(self.gif)</span><br><span class="line">        label.setFixedSize(<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">        label.setScaledContents(<span class="literal">True</span>)</span><br><span class="line">        label.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.label = label</span><br><span class="line">        proBar = QProgressBar(self)  <span class="comment"># 进度条</span></span><br><span class="line">        proBar.setObjectName(<span class="string">&#x27;proBar&#x27;</span>)</span><br><span class="line">        proBar.setGeometry(<span class="number">20</span>, <span class="number">260</span>, <span class="number">260</span>, <span class="number">15</span>)</span><br><span class="line">        proBar.setFixedSize(<span class="number">260</span>, <span class="number">15</span>)</span><br><span class="line">        proBar.setStyleSheet(<span class="string">&quot;text-align: center;&quot;</span>)  <span class="comment"># 进度条文本居中</span></span><br><span class="line">        proBar.setValue(<span class="number">0</span>)</span><br><span class="line">        self.proBar = proBar</span><br><span class="line">        self.gif.start()</span><br><span class="line">        self.center()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setupUi_message</span>(<span class="params">self, text</span>):  <span class="comment"># 文本消息提示框</span></span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;提示框&#x27;</span>)</span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">&#x27;:/image/flower.ico&#x27;</span>))</span><br><span class="line">        self.setGeometry(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">75</span>)</span><br><span class="line">        self.setFixedSize(<span class="number">200</span>, <span class="number">75</span>)</span><br><span class="line">        label = QLabel(self)</span><br><span class="line">        label.setFixedSize(<span class="number">200</span>, <span class="number">75</span>)</span><br><span class="line">        label.setText(text)</span><br><span class="line">        label.setAlignment(Qt.AlignCenter)</span><br><span class="line">        font = QtGui.QFont()</span><br><span class="line">        font.setPointSize(<span class="number">14</span>)  <span class="comment"># 设置字体大小</span></span><br><span class="line">        label.setFont(font)</span><br><span class="line">        label.setScaledContents(<span class="literal">True</span>)</span><br><span class="line">        label.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.label = label</span><br><span class="line">        self.center()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setMessage</span>(<span class="params">self, <span class="built_in">str</span></span>):  <span class="comment"># 设置文本函数</span></span><br><span class="line">        <span class="keyword">if</span> self.message:  <span class="comment"># 文本消息框被使能才能修改文本</span></span><br><span class="line">            self.label.setText(<span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setProgress</span>(<span class="params">self, value</span>):  <span class="comment"># 设置进度条进度</span></span><br><span class="line">        <span class="keyword">if</span> self.message:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.proBar.setValue(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">center</span>(<span class="params">self</span>):  <span class="comment"># 窗口居中函数</span></span><br><span class="line">        screen = QDesktopWidget().screenGeometry()</span><br><span class="line">        size = self.geometry()</span><br><span class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>,</span><br><span class="line">                  (screen.height() - size.height()) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">encode_thread</span>(<span class="title class_ inherited__">QThread</span>):  <span class="comment"># 子线程类</span></span><br><span class="line">    update_progress = pyqtSignal(<span class="built_in">int</span>)  <span class="comment"># 向主线程发送当前进度信号</span></span><br><span class="line">    finished = pyqtSignal()  <span class="comment"># 向主线程发送任务完成的信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化参数，inputfile:件载入路径;outputfile:文件压缩完后的保存路径;ena_decode:是否使能编码功能</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inputfile=<span class="string">&#x27;.&#x27;</span>, outputfile=<span class="string">&#x27;.&#x27;</span>, ena_decode=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(QThread, self).__init__()</span><br><span class="line">        self.inputfile = inputfile</span><br><span class="line">        self.outputfile = outputfile</span><br><span class="line">        self.ena_decode = ena_decode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):  <span class="comment"># 子线程函数，子线程类只有该函数运行在子线程</span></span><br><span class="line">        self.encoder = HuffmanEncoder()  <span class="comment"># 实例化HuffmanEncoder()对象</span></span><br><span class="line">        self.encoder.progress.connect(<span class="keyword">lambda</span> x: self.update_progress.emit(x))  <span class="comment"># 给HuffmanEncoder()对象的进度信号发送设置对应的槽函数</span></span><br><span class="line">        <span class="keyword">if</span> self.ena_decode:</span><br><span class="line">            self.encoder.decodefile(inputfile=self.inputfile, outputfile=self.outputfile)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.encoder.encodefile(inputfile=self.inputfile, outputfile=self.outputfile)</span><br><span class="line">        self.finished.emit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    main = Ui_MainWindow()</span><br><span class="line">    main.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>全部代码：</p><p><a href="https://github.com/Kakaluoto/Huffman_code_decode">GitHub - Kakaluoto/Huffman_code_decode</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图像处理】MATLAB简单人脸检测</title>
      <link href="/2020/05/03/MATLAB%E7%AE%80%E5%8D%95%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
      <url>/2020/05/03/MATLAB%E7%AE%80%E5%8D%95%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-人脸检测原理框图"><a href="#1-人脸检测原理框图" class="headerlink" title="1.人脸检测原理框图"></a>1.人脸检测原理框图</h2><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171705537.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>整体思路是寻找图片中最大的连通域，将其认定为人脸。</p><p>第一个环节均值滤波，是为了减弱图像的相关细节部分，以免毛刺影响后期连通域的形成，二值化方便形态学处理，减少运算量。考虑到人脸有黑人和白人黄种人，黑人肤色较深，在二值化之后面部区域不容易形成较大的连通域，如果采取形态学边界提取的办法，就可以避免这个问题，形态学边界提取，只要结构元素够大，也可以形成较大的封闭连通域。</p><p>然后就是纵向闭合操作，这一步我选择采用竖向长条状的结构元素进行闭合运算，因为人的脸部和颈部以及头发和衣物等等都是纵向分布的，在进行形态学边界提取的时候，容易将这些靠近的成分割裂开来，这对连通域的判断极为不利，所以用竖向长条状的结构元素在在纵向进行闭合运算，将脸部上下部的区域重新连接起来。</p><p>紧接着我又用横向长条状结构元素进行横向腐蚀运算，这是因为，人的头部以下的身体部分存在有大量连通域的时候，容易对最大连通域的判决产生干扰，又因为下半部分，多半呈纵向分布，通过横向腐蚀可以将这些大块的连通域割裂开来，但是要注意的是，割裂程度不应太大，否则会使得上一步闭合操作丧失意义。</p><p>接着，由于背景杂物等因素，同样也会产生大量连通域，这会对最后结果的判决产生干扰，因此要予以剔除。</p><p>进行了层层筛选之后，在剩下的连通域里面挑一个最大的连通域，并且尺寸形状满足要求的用矩形框框起来作为人脸检测结果。</p><h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2 步骤"></a>2 步骤</h1><h2 id="2-1-均值滤波"><a href="#2-1-均值滤波" class="headerlink" title="2.1 均值滤波"></a>2.1 均值滤波</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="built_in">ones</span>(<span class="number">9</span>)/<span class="number">81</span>;</span><br><span class="line">I = uint8(conv2(I,h));</span><br><span class="line"><span class="built_in">figure</span>,imshow(I),title(<span class="string">&#x27;线性均值滤波&#x27;</span>)</span><br></pre></td></tr></table></figure><p>采用9x9模板进行线性均值滤波，因为后面调用gpuArray()函数转换对输入数据有要求，所以在进行了二维卷积之后重新将数据格式转换成8位无符号整形数据。</p><h2 id="2-2-二值化"><a href="#2-2-二值化" class="headerlink" title="2.2 二值化"></a>2.2 二值化</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BW = imbinarize(I);</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;二值化&#x27;</span>)</span><br></pre></td></tr></table></figure><p>直接调用imbinarize对图像进行二值化</p><h2 id="2-3-形态学边界提取"><a href="#2-3-形态学边界提取" class="headerlink" title="2.3.形态学边界提取"></a>2.3.形态学边界提取</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B = <span class="built_in">ones</span>(<span class="number">21</span>);<span class="comment">%结构元素</span></span><br><span class="line">BW = -imerode(BW,B) + BW;</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;形态学边界提取&#x27;</span>)</span><br><span class="line">BW = bwmorph(BW,<span class="string">&#x27;thicken&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;加粗边界&#x27;</span>)</span><br><span class="line">BW = not(bwareaopen(not(BW), <span class="number">300</span>));</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;把空洞填了&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结构元素采用21x21大小的全1矩阵，先调用imrode()进行腐蚀，再用原图减去腐蚀结果，得到边界。为了让边界更加明显，调用bmworph函数，传入’thicken’参数，意在将边界加粗加厚。最后为了把空洞就是连续的小黑色块填满，调用bwareaopen()函数，该函数是去除面积小于300的白块，为了去除黑块，先调用not(BW)给原来的二值图像取反，去掉取反后面积小于300的白块，再次取反，达到去掉面积小于300的黑块的目的。</p><h2 id="2-4-纵向闭合与横向腐蚀"><a href="#2-4-纵向闭合与横向腐蚀" class="headerlink" title="2.4 纵向闭合与横向腐蚀"></a>2.4 纵向闭合与横向腐蚀</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%进行形态学运算</span></span><br><span class="line">B = strel(<span class="string">&#x27;line&#x27;</span>,<span class="number">50</span>,<span class="number">90</span>);</span><br><span class="line">BW = imdilate(BW,B);</span><br><span class="line">BW = imerode(BW,B);</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;再闭操作之后&#x27;</span>)</span><br><span class="line">B = strel(<span class="string">&#x27;line&#x27;</span>,<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">BW = imerode(BW,B);</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;闭操作之后再腐蚀&#x27;</span>)</span><br><span class="line">BW = gpuArray(BW);</span><br></pre></td></tr></table></figure><p>调用strel()函数生成特定的结构元素，第一步调用strel(‘line’,50,90)，意思是调用直线型结构元素，长度为50，角度90度，也就是竖直的长条形结构元素。接着利用B调用imdilate和imerode，先进行膨胀再进行腐蚀完成闭操作运算。下一步，继续生成横向长条形结构元素，进行腐蚀操作，注意这里的结构元素不宜面积太大，长度太长，否则会过度影响上一步的结果</p><p>最后为了循环过程中提升运算速度，将数据类型更改为gpuArray()，可以在GPU上进行计算，节省时间。</p><h2 id="2-5-消除边界多余连通域"><a href="#2-5-消除边界多余连通域" class="headerlink" title="2.5 消除边界多余连通域"></a>2.5 消除边界多余连通域</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%最小化背景</span></span><br><span class="line"><span class="comment">%细分</span></span><br><span class="line">div = <span class="number">10</span>;</span><br><span class="line">r = <span class="built_in">floor</span>(n1/div);<span class="comment">%分成10块 行</span></span><br><span class="line">c = <span class="built_in">floor</span>(n2/div);<span class="comment">%分成10块 列</span></span><br><span class="line">x1 = <span class="number">1</span>;x2 = r;<span class="comment">%对应行初始化</span></span><br><span class="line">s = r*c;<span class="comment">%块面积</span></span><br><span class="line"><span class="comment">%判断人脸是否处于图片四周，如果不是就全部弄黑</span></span><br><span class="line"><span class="comment">%figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:div</span><br><span class="line">    y1 = <span class="number">1</span>;y2 = c;<span class="comment">%对应列初始化</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:div</span><br><span class="line">        loc = <span class="built_in">find</span>(BW(x1:x2,y1:y2)==<span class="number">0</span>);<span class="comment">%统计这一块黑色像素的位置</span></span><br><span class="line">        num = <span class="built_in">length</span>(loc);</span><br><span class="line">        rate = num*<span class="number">100</span>/s;<span class="comment">%统计黑色像素占比</span></span><br><span class="line">        <span class="keyword">if</span> (y2&lt;=<span class="number">0.2</span>*div*c||y2&gt;=<span class="number">0.8</span>*div*c)||(x1&lt;=r||x2&gt;=r*div)</span><br><span class="line">            <span class="keyword">if</span> rate &lt;=<span class="number">100</span></span><br><span class="line">                BW(x1:x2,y1:y2) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">%imshow(BW)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> rate &lt;=<span class="number">25</span></span><br><span class="line">                BW(x1:x2,y1:y2) = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">%imshow(BW)</span></span><br><span class="line">        <span class="keyword">end</span><span class="comment">%下一列</span></span><br><span class="line">        y1 = y1 + c;</span><br><span class="line">        y2 = y2 + c;</span><br><span class="line">    <span class="keyword">end</span><span class="comment">%下一行</span></span><br><span class="line">    x1 = x1 + r;</span><br><span class="line">    x2 = x2 + r;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于周围多余的杂物产生的连通域，我选择先将整幅图像划分为很多小块，对一部分在图像边缘的小块全部置成黑色，对不在边缘的通过计算其中黑色像素比例来判定是否应该全部给成白色。因为图片中央可能还会存在一些细小空洞，这些空洞在每一小块占比不是很大但有可能影响连通性，如果一个小块里面大部分是白色就全部给成白色，方便后期判定最大连通域。</p><p>Div是均分比例，我这里设置成10，也就是将整个图像划分成100个小块。r就是在行方向上一个小块占多少像素，c就是在列方向上一个小块有多少像素。用两层循环来遍历每个小块，通过find(x1:x2,y1:y2)==0返回所有满足要求的像素的索引，索引长度就是黑色像素的个数。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171705088.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>通过条件判断是否在边界。</p><h2 id="2-6-寻找最大连通域并画框"><a href="#2-6-寻找最大连通域并画框" class="headerlink" title="2.6 寻找最大连通域并画框"></a>2.6 寻找最大连通域并画框</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">imshow(BW)</span><br><span class="line">title(<span class="string">&#x27;最终处理&#x27;</span>)</span><br><span class="line">L = bwlabel(BW,<span class="number">8</span>);<span class="comment">%利用belabel函数对8连通域区间进行标号</span></span><br><span class="line">BB = regionprops(L,<span class="string">&#x27;BoundingBox&#x27;</span>);<span class="comment">%得到矩形框，框柱每一个连通域</span></span><br><span class="line">BB = cell2mat(struct2cell(BB));</span><br><span class="line">[s1,s2] = <span class="built_in">size</span>(BB);</span><br><span class="line">BB = <span class="built_in">reshape</span>(BB,<span class="number">4</span>,s1*s2/<span class="number">4</span>)&#x27;;</span><br><span class="line">pickshape = BB(:,<span class="number">3</span>)./BB(:,<span class="number">4</span>);<span class="comment">%</span></span><br><span class="line">shapeind = BB(<span class="number">0.3</span>&lt;pickshape&amp;pickshape&lt;<span class="number">3</span>,:);<span class="comment">%筛选掉尺寸比例不合格</span></span><br><span class="line">[~,arealind] = <span class="built_in">max</span>(shapeind(:,<span class="number">3</span>).*shapeind(:,<span class="number">4</span>));</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">imshow(rgb)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">rectangle(<span class="string">&#x27;Position&#x27;</span>,[shapeind(arealind,<span class="number">1</span>),shapeind(arealind,<span class="number">2</span>),shapeind(arealind,<span class="number">3</span>),shapeind(arealind,<span class="number">3</span>)],...</span><br><span class="line">    <span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;Linewidth&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">title(<span class="string">&#x27;人脸检测&#x27;</span>)</span><br></pre></td></tr></table></figure><p>经过消除边界多余连通域后得到的BW中剩下的连通域内存在着我们需要的那个对应人脸的连通域。一般情况下，对应人脸的那个连通域会是最大的连通域。</p><p>调用bwlabel(BW,8)函数给所有连通域标记，其中邻域规则采用8邻域，返回一个被标记过连通域的图像，第k个被标记的连通域所有像素值为k。</p><p>调用regionprops(L,’BoundingBox’)函数，传入参数L和’BoundingBox’，该函数用于获取图像的各种属性，传入’BoundingBox’返回的是一个结构体，每一个结构体内都包含了一个能框柱其对应连通域的最小方框。一个方框，用一个序列来描述[x,y,width,height]，这个序列包含了方框左上角像素的坐标以及长和宽。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171705913.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这三条语句，第一条用来将结构体转换成矩阵向量，方便计算。第二行获取这个矩阵的维度。由于BB刚转换成向量的时候，是一个行向量，每4个元素1组对应一个方框。为了后续计算方便，使用reshape()函数，将BB重构成一个矩阵，这个矩阵有4列，每一列对应方框的一个参数，比如坐标，长宽等等。每一行对应一个方框。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171705141.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>第一行计算长宽比，得到的pickshape向量的每一行对应每个方框的长宽比。由于有的方框明显过于扁平或者过于狭长，这种方框应该是要扔掉的。</p><p>所以第二行，通过逻辑表达式从BB内筛选出尺寸比例合格的方框，存在shapeind里面。<br> 剩下的尺寸符合要求的方框里面要选出面积最大的那个，最后一行，得到面积最大的方框对应的索引。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171705367.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>把方框画出来。</p><h1 id="3-检测结果"><a href="#3-检测结果" class="headerlink" title="3 检测结果"></a>3 检测结果</h1><p><img src="https://s4.ax1x.com/2022/01/12/7npWH1.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171705681.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>图 15rgb图像转换成灰度图像         图 16线性均值滤波结果</p><p>可以看到，均值滤波使得图像变模糊了细节减少</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171705473.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>图 17二值化结果                   图 18形态学边界提取结果</p><p>以看到边界被成功提取了出来，在人脸部形成了一个比较大的连通域</p><p><img src="https://s4.ax1x.com/2022/01/12/7npqud.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 可以看到，进行边界加粗和空洞添补之后，眼睛部分的黑块被消除了，这使得脸部连通域更大了</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171705658.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意观察图片左边的相分离的白块，在纵向闭操作之后连在了一起，同时脸部连通域进一步扩大，然后横向腐蚀在尽量维持脸部连通域大小的情况下减小了图片下方连通域。</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706690.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>可以看到效果还可以。还有其他的测试结果</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706766.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>图 24测试样例</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706233.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>图 25测试样例</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706396.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>图 26测试样例</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706231.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>图 27测试样例</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706654.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>图 28测试样例</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706167.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>图 29测试样例</p><p><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706730.png" alt="img"><img src="https://kakaluoto-hexo-blog.oss-cn-guangzhou.aliyuncs.com/img/202212171706730.png" alt="点击并拖拽以移动"></p><p>图 30测试样例</p><p>这里注意到，黑人同样也被检测到了</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%%完整代码</span></span><br><span class="line">rgb = imread(<span class="string">&#x27;f.jpg&#x27;</span>);</span><br><span class="line">I = rgb2gray(rgb);</span><br><span class="line">[n1,n2] = <span class="built_in">size</span>(I);</span><br><span class="line"><span class="comment">%灰度图</span></span><br><span class="line"><span class="built_in">figure</span>,imshow(I),title(<span class="string">&#x27;灰度图&#x27;</span>)</span><br><span class="line">tic</span><br><span class="line">h = <span class="built_in">ones</span>(<span class="number">9</span>)/<span class="number">81</span>;</span><br><span class="line">I = uint8(conv2(I,h));</span><br><span class="line"><span class="built_in">figure</span>,imshow(I),title(<span class="string">&#x27;线性均值滤波&#x27;</span>)</span><br><span class="line">BW = imbinarize(I);</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;二值化&#x27;</span>)</span><br><span class="line">B = <span class="built_in">ones</span>(<span class="number">21</span>);<span class="comment">%结构元素</span></span><br><span class="line">BW = -imerode(BW,B) + BW;</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;形态学边界提取&#x27;</span>)</span><br><span class="line">BW = bwmorph(BW,<span class="string">&#x27;thicken&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;加粗边界&#x27;</span>)</span><br><span class="line">BW = not(bwareaopen(not(BW), <span class="number">300</span>));</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;把空洞填了&#x27;</span>)</span><br><span class="line"><span class="comment">%进行形态学运算</span></span><br><span class="line">B = strel(<span class="string">&#x27;line&#x27;</span>,<span class="number">50</span>,<span class="number">90</span>);</span><br><span class="line">BW = imdilate(BW,B);</span><br><span class="line">BW = imerode(BW,B);</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;再闭操作之后&#x27;</span>)</span><br><span class="line">B = strel(<span class="string">&#x27;line&#x27;</span>,<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">BW = imerode(BW,B);</span><br><span class="line"><span class="built_in">figure</span>,imshow(BW),title(<span class="string">&#x27;闭操作之后再腐蚀&#x27;</span>)</span><br><span class="line">BW = gpuArray(BW);</span><br><span class="line"></span><br><span class="line"><span class="comment">%最小化背景</span></span><br><span class="line"><span class="comment">%细分</span></span><br><span class="line">div = <span class="number">10</span>;</span><br><span class="line">r = <span class="built_in">floor</span>(n1/div);<span class="comment">%分成10块 行</span></span><br><span class="line">c = <span class="built_in">floor</span>(n2/div);<span class="comment">%分成10块 列</span></span><br><span class="line">x1 = <span class="number">1</span>;x2 = r;<span class="comment">%对应行初始化</span></span><br><span class="line">s = r*c;<span class="comment">%块面积</span></span><br><span class="line"><span class="comment">%判断人脸是否处于图片四周，如果不是就全部弄黑</span></span><br><span class="line"><span class="comment">%figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:div</span><br><span class="line">    y1 = <span class="number">1</span>;y2 = c;<span class="comment">%对应列初始化</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:div</span><br><span class="line">        loc = <span class="built_in">find</span>(BW(x1:x2,y1:y2)==<span class="number">0</span>);<span class="comment">%统计这一块黑色像素的位置</span></span><br><span class="line">        num = <span class="built_in">length</span>(loc);</span><br><span class="line">        rate = num*<span class="number">100</span>/s;<span class="comment">%统计黑色像素占比</span></span><br><span class="line">        <span class="keyword">if</span> (y2&lt;=<span class="number">0.2</span>*div*c||y2&gt;=<span class="number">0.8</span>*div*c)||(x1&lt;=r||x2&gt;=r*div)</span><br><span class="line">            <span class="keyword">if</span> rate &lt;=<span class="number">100</span></span><br><span class="line">                BW(x1:x2,y1:y2) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">%imshow(BW)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> rate &lt;=<span class="number">25</span></span><br><span class="line">                BW(x1:x2,y1:y2) = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">%imshow(BW)</span></span><br><span class="line">        <span class="keyword">end</span><span class="comment">%下一列</span></span><br><span class="line">        y1 = y1 + c;</span><br><span class="line">        y2 = y2 + c;</span><br><span class="line">    <span class="keyword">end</span><span class="comment">%下一行</span></span><br><span class="line">    x1 = x1 + r;</span><br><span class="line">    x2 = x2 + r;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">imshow(BW)</span><br><span class="line">title(<span class="string">&#x27;最终处理&#x27;</span>)</span><br><span class="line">L = bwlabel(BW,<span class="number">8</span>);<span class="comment">%利用belabel函数对8连通域区间进行标号</span></span><br><span class="line">BB = regionprops(L,<span class="string">&#x27;BoundingBox&#x27;</span>);<span class="comment">%得到矩形框，框柱每一个连通域</span></span><br><span class="line">BB = cell2mat(struct2cell(BB));</span><br><span class="line">[s1,s2] = <span class="built_in">size</span>(BB);</span><br><span class="line">BB = <span class="built_in">reshape</span>(BB,<span class="number">4</span>,s1*s2/<span class="number">4</span>)&#x27;;</span><br><span class="line">pickshape = BB(:,<span class="number">3</span>)./BB(:,<span class="number">4</span>);<span class="comment">%</span></span><br><span class="line">shapeind = BB(<span class="number">0.3</span>&lt;pickshape&amp;pickshape&lt;<span class="number">3</span>,:);<span class="comment">%筛选掉尺寸比例不合格</span></span><br><span class="line">[~,arealind] = <span class="built_in">max</span>(shapeind(:,<span class="number">3</span>).*shapeind(:,<span class="number">4</span>));</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">imshow(rgb)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">rectangle(<span class="string">&#x27;Position&#x27;</span>,[shapeind(arealind,<span class="number">1</span>),shapeind(arealind,<span class="number">2</span>),shapeind(arealind,<span class="number">3</span>),shapeind(arealind,<span class="number">3</span>)],...</span><br><span class="line">    <span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;Linewidth&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">title(<span class="string">&#x27;人脸检测&#x27;</span>)</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
